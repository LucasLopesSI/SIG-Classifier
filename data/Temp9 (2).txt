Geoinformatica (2014) 18:95–133
DOI 10.1007/s10707-013-0192-0

Protecting query privacy in location-based services

Xihui Chen · Jun Pang

Received: 30 May 2013 / Revised: 28 August 2013 /
Accepted: 24 September 2013 / Published online: 18 October 2013
© Springer Science+Business Media New York 2013

Abstract The popularity of location-based services (LBSs) leads to severe concerns
on users’ privacy. With the fast growth of Internet applications such as online social
networks, more user information becomes available to the attackers, which allows
them to construct new contextual information. This gives rise to new challenges for
user privacy protection and often requires improvements on the existing privacy-
preserving methods. In this paper, we classify contextual information related to
LBS query privacy and focus on two types of contexts—user prof iles and query
dependency: user profiles have not been deeply studied in LBS query privacy
protection, while we are the first to show the impact of query dependency on users’
query privacy. More specifically, we present a general framework to enable the
attackers to compute a distribution on users with respect to issuing an observed
request. The framework can model attackers with different contextual information.
We take user profiles and query dependency as examples to illustrate the implemen-
tation of the framework and their impact on users’ query privacy. Our framework
subsequently allows us to show the insufficiency of existing query privacy metrics,
e.g., k-anonymity, and propose several new metrics. In the end, we develop new
generalisation algorithms to compute regions satisfying users’ privacy requirements

This article is a revised and extended version of our two conference papers [7, 8].

Xihui Chen is supported by an AFR PhD grant from the National Research Fund, Luxembourg.
X. Chen (B)
Interdisciplinary Centre for Security, Reliability and Trust,
University of Luxembourg,
6 rue Richard Coudenhove-Kalergi, 1359 Luxembourg, Luxembourg
e-mail: xihui.chen@uni.lu

J. Pang
Faculty of Science, Technology and Communication,
University of Luxembourg,
6 rue Richard Coudenhove-Kalergi, 1359 Luxembourg, Luxembourg
e-mail: jun.pang@uni.lu

96

Geoinformatica (2014) 18:95–133

expressed in these metrics. By experiments, our metrics and algorithms are shown to
be effective and efficient for practical usage.

Keywords Location-based services · Query privacy · Anonymity · Measurement

1 Introduction

Location-based services (LBSs) are services customised according to users’ locations.
In the last fifteen years, LBSs have endured a great growth, especially after GPS-
enabled devices such as smartphones became popular. An LBS request contains the
issuer’s location and a query—the type of information of interest, for instance, ‘where
the nearest gas stations are’. In spite of the great convenience brought to users’ daily
life, LBSs lead to severe privacy concerns especially in cases where LBS providers
are not considered trustworthy and share users’ request with the attackers. In the
literature, two major privacy concerns in LBSs have been studied—location privacy
and query privacy [22]—in terms of the types of sensitive information. The former
is related to the disclosure of users’ exact locations while query privacy, the focus of
our paper, concerns the disclosure of queries.

The basic idea to protect users’ query privacy in LBSs is to break the link
between user identities and requests [4]. However, in the context of LBSs, only
removing or replacing identities with pseudonyms has been proved insufficient.
Locations contained in requests can still reveal issuers’ identities, since attackers
can acquire users’ locations through a number of methods, e.g., triangulating mobile
phones’ signals and localising users’ access points to the Internet. In such cases,
users’ spatial and temporal information serves as quasi-identif iers. Anonymisation
techniques from other research areas such as sensitive data release [22] are thus
introduced, including k-anonymity and its different extensions (e.g., (cid:2)-diversity and
t-closeness [29, 30]). Locations or time are replaced with regions or periods so
that a certain number of users (at least k for k-anonymity) share the same quasi-
identifier with the real issuer. The calculation of the regions or periods is termed as
generalisation or cloaking. Since in practice LBS providers are usually required to
offer immediate responses, throughout the paper, temporal generalisation is out of
the scope. We call a request generalised if the location is generalised and the user
identity is removed.

However, when the adversary has access to additional information, new privacy
risks will emerge. For instance, “outlier” attacks are found on some existing gen-
eralisation algorithms when their implementation is made public [33]. Some users
are eliminated from the set of potential issuers as the algorithms cannot output the
same generalised region to all of them when they issue the request. Such information
is classified as contextual information in the literature and the privacy in LBSs
related to contextual information has been recognised as context-aware privacy [37].
Many types of contextual information have been studied so far. For example, Shin
et al. [42, 43] study user profiles and propose metrics based on k-anonymity by
restricting levels of similarity among users in terms of their profiles. Cheng et al. [10]
propose the concept of historical k-anonymity against attacks where the adversary
learns a trace of associated requests, e.g., issued by the same user.

Geoinformatica (2014) 18:95–133

97

Our motivations The research on context-aware privacy usually follows a two-step
approach. It starts with identifying a type of contextual information and demonstrat-
ing its impact on users’ privacy and then it proceeds with developing specific privacy
protection mechanisms. There are a few restrictions with this line of research. First,
the privacy concern of contextual information is usually illustrated in a possibilistic
way with a focus on whether the impact exists or not. In spite of the claim that attack-
ers can learn more information about issuers, it is not clear what changes have been
exactly made on the attackers’ knowledge by this piece of contextual information.
Second, variants of contextual information are studied independently. Although new
privacy properties are defined and based on them privacy protection mechanisms
are proposed, they are only effective for the identified contextual information. In
particular, with the fast development of information and communication techniques,
new contextual information will always be identified. We need a framework to
uniformly capture contextual information. Moreover, we need to define new generic
privacy metrics for users to express their privacy requirements precisely and design
(generalisation) algorithms to support such requirements.

Our contributions We summarise our main contributions in this paper as follows to
address the above identified research questions:

1. We develop a formal framework for context-aware query privacy analysis. In
particular, this framework gives a probabilistic interpretation of the attacks on
query privacy. With this interpretation, we show how query privacy can be
breached form the adversary’s viewpoint. We take the contextual information—
user prof iles as an example to illustrate the instantiation of our framework.
2. Within the formal framework, we propose a systematic classification of contex-
tual information related to query privacy, according to whether the information
changes over time—static and dynamic.

3. Along with the development of LBSs, new contextual information can be
collected and abused by the attackers. We identify a new type of contextual
information—query dependency and study its impact on query privacy within
our framework.

4. Our probabilistic framework allows us to define several new metrics to measure
users’ query privacy from different perspectives. Moreover, these metrics enable
users to express their privacy requirements effectively. In order to compute gen-
eralised regions that satisfy users’ requirements, we propose new generalisation
algorithms which are efficient and can ensure a good quality of the responses
from the LBS providers.

5. Through experiments, we show that our framework can significantly improve the
adversary’s analysis of users’ query privacy. In particular, we validate that query
dependency can effectively reduce the uncertainty of the adversary about the
real issuer of a request. Furthermore, we show that our generalisation algorithms
are efficient to meet the demands on real-time responses and can generate
regions satisfying privacy requirements when various contextual information are
considered. We also show that the different strengths of our metrics can help a
user choose a right metric to achieve a balance between privacy and the quality
of service delivered by different LBS providers.

98

Geoinformatica (2014) 18:95–133

Structure of the paper
In Section 2, we discuss the related work. We define our
formal framework and the adversary model in Section 3. In Section 4 we take user
profiles as an example of contextual information to show the application of our
framework. We formally study the impact of query dependency on query privacy
in Section 5 by incorporating it into our framework. Our query privacy metrics are
defined in Section 6 and our new generalisation algorithms are presented in Section 7.
Section 8 summarises the experimental results and the corresponding analysis. We
conclude the paper in Section 9.

2 Related work

2.1 Query privacy and request generalisation

Protecting users’ query privacy is essentially to prevent the adversary from learning
their issued queries. A number of techniques have been proposed in the literature
to protect query privacy and they can be classified into three main groups—
obfuscation [28, 49], generalisation [22, 48] and cryptographic transformation [17].
The methods of obfuscation forge dummy requests with different queries such that
the real queries are hidden in the dummy ones. The idea of generalisation is to hide
the real issuer in a number of users such that he is indistinguishable from the others
from the view of the adversary. The concept of k-anonymity has been extensively
studied in this group. In the methods exploring cryptographic transformation, users’
queries are encrypted and remain secret for LBS providers so as to offer strong
privacy protection. All of these methods introduce extra processing overhead. For
instance, Ghinita et al. [17] build a protocol based on computational private infor-
mation retrieval (cPIR)—their protocol requires one extra round of communication
between users and LBS providers and imposes additional computation overheads on
both sides due to the encryption of queries and decryption of responses. In this paper
we focus on request generalisation and use it to protect query privacy with respect to
contextual information.

The notion of k-anonymity was originally proposed by Samarati and Sweeney in
the field of database privacy [39]. The idea of k-anonymity is to guarantee that a
database entry’s identifier is indistinguishable from other k−1 entries. However, this
method does not always work. For instance, the fact that an HIV carrier is hidden
in k carriers does not protect his infection of the virus. Further research has been
done to fix this problem [29]. In the context of privacy in LBSs, k-anonymity was first
studied by Gruteser and Grunwald [22]. Its purpose is to compute a region containing
at least other k−1 users (i.e., area generalisation) and replace the issuer’s location
with it. Because of its simplicity, k-anonymity has been studied and refined in many
ways. For instance, Tan et al. define information leakage to measure the amount
of revealed location information in spatial cloaking, which quantifies the balance
between privacy and performance [46]. Xue et al. [48] introduce the concept of
location diversity to ensure generalised regions to contain at least (cid:2) semantic locations
(e.g., schools). However, deeper understanding of k-anonymity reveals its drawbacks
in preserving location privacy. Shokri et al. analyse the effectiveness of k-anonymity
in protecting location privacy in different scenarios in terms of adversaries’ back-
ground information [45], i.e., real-time location information, statistical information

Geoinformatica (2014) 18:95–133

99

Fig. 1 A centralised framework of LBSs

and no information. They show its flaws which the adversary can exploit to infer
users’ current locations and conclude that spatial cloaking (e.g., k-anonymity) is only
effective for protecting query privacy. As a consequence, in this work we use area
generalisation only to protect query privacy.

The generalisation of LBS requests is usually implemented in two ways—
centralised and distributed. A centralised structure (depicted in Fig. 1) relies on
a trusted agent, the anonymiser, to collect users’ requests and anonymise them
before sending them to LBS providers. However, in a distributed implementation
users cooperate with each other to construct a generalised region [18, 40]. The
centralised framework is easy to implement and well-studied in the literature while
the distributed framework requires more communications between collaborators and
security analysis, e.g., with respect to insiders, is not well studied. In the centralised
framework, normally it is assumed that the communication channels between users
and the anonymiser are secure while the ones between the anonymiser and the LBS
provider are public.

2.2 Context-aware privacy analysis

The effectiveness of area generalisation can be compromised when the adversary has
access to auxiliary contextual information. In fact, area generalisation guaranteeing
k-anonymity is proposed to protect query privacy against the adversary who has
users’ real-time locations in their knowledge. Mascetti et al. [33] identify the ‘outlier’
attack on some generalisation algorithms if the adversary learns their implemen-
tations. k-anonymity is violated because the algorithms cannot ensure that all the
potential issuers have the same generalised area as the real issuer. Shokri et al. [44]
use mobility patterns modelled as Markov chains of location transition and propose
a probabilistic framework to de-anonymise generalised traces. Personal information
(e.g., gender, job, salary) has been becoming more accessible on the Internet, e.g.,
due to online social networks such as Facebook and LinkedIn, and can also serve
as a type of contextual information which we call user prof iles. Shin et al. [42, 43]
identify the concern of query privacy caused by user profiles and propose metrics
based on k-anonymity by restricting similarity levels between users in terms of their
profiles.

The contextual information (e.g., user profiles and generalisation algorithms)
mentioned above is irrelevant to users’ past LBS requests. Actually LBS requests
can also be explored by the adversary to refine his guess on the issuers. Two types
of LBS requests have been studied in the literature—associated requests [4, 10, 13]
and recurrent requests [38]. Requests are associated once they are recognised
as issued by a same (anonymous) user, which can be achieved for example by

100

Geoinformatica (2014) 18:95–133

multi-target tracking techniques [24] or probabilistic reasoning [44]. By calculating
the intersection of all associated requests’ anonymity sets the adversary can reduce
the number of possible issuers. To handle such privacy threats, Cheng et al. [10],
Bettini et al. [4] introduce historical k-anonymity, which is then extended for con-
tinuous LBSs by Dewri et al. [13]. Historical k-anonymity aims to guarantee that
associated requests share at least k fixed users in the generalised regions. Requests
are recurrent when they are issued at the same time. When multiple recurrent
requests contain the same query and region, the protection of query privacy offered
by spatial cloaking (e.g., k-anonymity) will be degraded [38]. For instance, in the
extreme case, when all users in a region send an identical query, no user has
query privacy. Riboni et al. [38] identify the threat and make use of t-closeness
to guarantee that the distance between the distribution over the queries from an
issuer’s generalised region and that of the whole region is below a threshold. Dewri
et al. [14] identify a scenario in continuous LBSs which has both associated and
recurrent requests. They propose m-invariance to ensure that in addition to k fixed
users shared by the associated requests, at least m different queries are generated
from each generalised region.

2.3 Area generalisation algorithms

The first generalisation algorithm called IntervalCloaking is designed by Gruteser
and Grunwald [22]. Their idea is to partition a region into quadrants with equal
area. If the quadrant where the issuer is located contains less than k users, then the
original region is returned. Otherwise, the quadrant with the issuer is taken as input
for the next iteration. The algorithm CliqueCloak [16] is proposed by Gedik and Liu
in which regions are generalised based on the users who have issued queries rather
than all potential issuers. The major improvement is that this algorithm enables users
to specify their personal privacy requirements by choosing different values for k.
Mokbel et al. [11, 34] design the algorithm Casper which employs a quadtree to
store the two-dimensional space. The root node represents the whole area and each
of other nodes represent a quadrant region of its parent node. The generalisation
algorithm starts from the leaf node which contains the issuer and iteratively traverses
backwards to the root until a region with more than k users is found. Another
algorithm nnASR [27] simply finds the nearest k users to the issuer and returns the
region containing these users as the anonymising spatial region.

The above algorithms suffer from a particular attack called “outlier problem” [3],
where the attackers have the generalisation algorithms and users’ spatial distribution
as part of their knowledge. An algorithm against this attack needs to ensure that
for any user in the anonymity set it returns the same region. Kalnis et al. design the
first algorithm called hilbASR that does not suffer from the outlier problem [27].
The algorithm exploits the Hilbert space filling curve to store users in a total order
based on their locations. The curve is then partitioned into blocks with k users. The
block with the issuer is returned as the generalised region. Mascetti et al. propose
two algorithms, dichotomicPoints and grid, which are also secure against the outlier
problem [33]. The former iteratively partitions the region into two blocks until less
than 2k users are located in the region while the latter draws a grid over the two-
dimensional space so that each cell contains k users and returns the cell with the
issuer. Because of the simplicity of implementation and the relatively smaller area of

Geoinformatica (2014) 18:95–133

101

the generalised regions, we adopt and extend these two algorithms in our algorithm
design (see Section 7). The area of generalised regions is usually used to measure the
quality of the LBS response, as smaller regions lead to more accurate results and less
communication overhead.

In this section, we present our framework for query privacy analysis in LBSs. This
framework allows us to precisely specify relevant components and attacks on query
privacy with various contextual information.

3 Our framework

3.1 Mobile users

We assume a set of users who subscribe an LBS and use the service frequently during
their movements. Let U be the set of such users. We use L to denote the set of all
possible positions where a user can issue a request. The accuracy of any position
(cid:2) ∈ L is determined by the positioning devices used. We represent time as a totally
ordered discrete set T , whose granularity, e.g., minutes or seconds, is decided by
the LBS provider. The function whereis : U × T → L gives the exact position of a
user at a given time. Thus, for any time t ∈ T , users’ spatial distribution is dist =
{(cid:4)u, whereis(u, t)(cid:5)|u ∈ U }. Suppose the set of queries (e.g., the nearest gas station)
supported by LBS providers is represented by Q. An LBS request is then in the form
of (cid:4)u, (cid:2), t, q(cid:5) ∈ U × L × T × Q, where (cid:2) = whereris(u, t).

3.2 Request generalisation algorithms

Given a request (cid:4)u, (cid:2), t, q(cid:5), the anonymising server (anonymiser) will remove the
issuer’s identity (i.e., u) and replace his location (i.e., (cid:2)) with an area to protect his
query privacy. We only consider spatial generalisation in this paper as in LBSs users
require instant responses. Let 2L be the power set of L and then the set of all possible
generalised regions can be denoted by R ⊆ 2L. Given (cid:4)u, (cid:2), t, q(cid:5), the anonymising
server outputs a generalised request in the form of (cid:4)r, t, q(cid:5), where r ∈ R is the
generalised area and (cid:2) ∈ r. The generalisation algorithm of the anonymiser can thus
be represented as a function f : U × L × T × Q → R × T × Q. We use function
query to obtain the query of a (generalised) request (i.e., query((cid:4)u, (cid:2), t, q(cid:5)) = q and
query((cid:4)r, t, q(cid:5)) = q).

The generalisation algorithm also takes users’ privacy requirements as part of
its input. In our framework, a privacy requirement is represented by a pair—a
chosen privacy metric and the corresponding value (e.g., (cid:4)k−anonymity, 5(cid:5)). We use
req((cid:4)u, (cid:2), t, q(cid:5)) to represent u’s privacy requirement on request (cid:4)u, (cid:2), t, q(cid:5).

3.3 The adversary

Privacy risks and countermeasures should be categorised according to the adver-
sary’s model and goals [4]. For query privacy, the adversary’s goal is obviously to
associate issuers to their queries while the model should be defined in terms of his
knowledge and attack(s) [43].

102

Geoinformatica (2014) 18:95–133

The knowledge of an adversary can be interpreted as the contextual information
that he has access to. We denote by Ct his collection of contextual information at time
t. In this paper, we assume that some contextual information is inherently contained
in Ct.

The adversary knows the deployed request generalisation algorithm (i.e., f ) and
users’ spatial distributions before the current time t (i.e., Dt = (dist1
) where
tn = t and ∀1≤i<nti < ti+1). This is a common assumption used in the literature and it
makes a strong adversary which allows us to analyse query privacy in the worst cases.
The availability of dist enables the adversary to obtain the set of users located in any
region r at time t, which is denoted as u(cid:2)(r, t).

, . . . , distn

Given a generalised request (cid:4)r, t, q(cid:5) and Ct, the objective of an attack performed by
the adversary on query privacy is to track the request’s issuer. In most of the cases,
it is not practical for the adversary to be completely sure of the issuer. Uncertainty is
thus inevitable. We use a posterior probability distribution over users to capture his
certainty and quantify the expected correctness of his attack. Let variable U be the
issuer of (cid:4)r, t, q(cid:5). For any user u ∈ U , his probability to issue the request (cid:4)r, t, q(cid:5) from
the view of the adversary with Ct can be represented as p(U = u|(cid:4)r, t, q(cid:5), Ct). In the
following, we give one method the adversary can adopt to calculate the distribution.
Through the Bayesian rule we have equation:

p(U = u|(cid:4)r, t, q(cid:5), Ct) = p((cid:4)r, t, q(cid:5)|u, Ct)
p((cid:4)r, t, q(cid:5), Ct)

=

(cid:2)

p((cid:4)r, t, q(cid:5)|u, Ct) · p(u|Ct) · p(Ct)
u(cid:9) p((cid:4)r, t, q(cid:5)|u(cid:9), Ct) · p(u(cid:9)|Ct) · p(Ct)

.

In the above equation, there are three new distributions. The distribution p(Ct)
measures the probability of the adversary having learned the collection of contextual
information Ct. It is difficult to evaluate its value. Whereas, since it appears in
both the numerator and the denominator, we can eliminate it from the formula.
The distribution p(u|Ct) represents the probability for user u to issue a request
at time t based on the contextual information Ct. As we have no information
about the distribution, it can be assumed as uniform according to the principle of
maximum entropy [25, 26], which leads to p(u|Ct) = p(u(cid:9)|Ct) (∀u(cid:9) ∈ U ). Thus, the
target posterior distribution can be further simplified as:

p(U = u|(cid:4)r, t, q(cid:5), Ct) =

(cid:2)

p((cid:4)r, t, q(cid:5)|u, Ct)
u(cid:9)∈U p((cid:4)r, t, q(cid:5)|u(cid:9), Ct)

.

(1)

The probability p((cid:4)r, t, q(cid:5)|u, Ct) indicates the likelihood that ‘if user u generates
a request at time t then the request will be generalised as (cid:4)r, t, q(cid:5)’. This is actually a
joint probability of the following two probabilities. The first is the probability that
user u issues the request (cid:4)u, whereis(u, t), t, q(cid:5) when he sends a request at t. It can
also be formulated as the probability that u chooses query q at time t to consult
the LBS provider. We call this probability the a priori probability of user u. The
second probability is the likelihood that the area generalisation algorithm outputs a
region r for whereis(u, t). We use pu(q|Ct) and p( f ((cid:4)u, whereis(u, t), t, q(cid:5)) = (cid:4)r, t, q(cid:5))

Geoinformatica (2014) 18:95–133

Table 1 Notations

103

U
T
L
R
q ∈ Q
(cid:4)u, (cid:2), t, q(cid:5)
(cid:4)r, t, q(cid:5)
whereis(u, t)
f ((cid:4)u, (cid:2), t, q(cid:5))
dist
u(cid:2)(r, t)
req((cid:4)u, (cid:2), t, q(cid:5))
query((cid:4)r, t, q(cid:5))

Set of users
Set of time instances
Set of locations
Set of possible generalised regions
A query supported by the LBS
A request issued by u at position (cid:2) at time t
A generalised request
Position of user u at time t
An algorithm computing generalised queries
Spatial distribution of users in U at time t
Set of users located in region r at time t
User u’s privacy requirement on (cid:4)u, (cid:2), t, q(cid:5)
The query of (cid:4)r, t, q(cid:5)

to represent these two probabilities, respectively. Based on the above discussion,
formally we have

p((cid:4)r, t, q(cid:5)|u, Ct) = pu(q|Ct) · p( f ((cid:4)u, whereis(u, t), t, q(cid:5)) = (cid:4)r, t, q(cid:5)).

(2)

We assume that the generalisation algorithms mentioned in this paper are deter-
ministic. In other words, there is always a unique generalised request corresponding
to each LBS request, which leads to p( f ((cid:4)u, whereis(u, t), t, q(cid:5)) = (cid:4)r, t, q(cid:5)) being
either 1 or 0. Furthermore, given an LBS request and a generalised request, the
value of this probability is available to the adversary as generalisation algorithms
are public. Therefore, the key of query privacy analysis is to calculate pu(q|Ct) for
any query q ∈ Q.

The calculation of pu(q|Ct) depends on Ct, i.e., the available contextual infor-
mation. In the following discussion, we give the instantiations of our framework
when two different types of contextual information are added into the adversary’s
knowledge, i.e., user profiles (see Section 4) and query dependency (see Section 5). In
this way, we not only show that our framework can handle the contextual information
that has been studied (i.e., user profiles), but also demonstrate that it is generic
to cope with new context (i.e., query dependency). The important notations are
summarised in Table 1.

3.4 Classifying contextual information

From the above discussion, we can see that the adversary can learn new knowledge
along with time and we should explicitly distinguish some contextual information at
different time. For instance, the contextual information about users’ spatial distri-
butions (i.e., Dt) records the sequence of the snapshots of mobile users’ locations
up to time t and this knowledge keeps growing with time. However, we also notice
that certain contextual information remains stable over time such as user mobility
patterns and user profiles.

According to this observation, we classify contextual

information into two

classes—static and dynamic. Formally they can be defined as follows:

Definition 1 (Static & dynamic context) Let ϕt ∈ Ct be the value of a type of
contextual information at time t. We say that the contextual information is static

104

Geoinformatica (2014) 18:95–133

user
proﬁles

generalisation
algorithms

mobility
patterns

query
dependency

static

Contextual
information

dynamic

spatial
distribution

recurrent
requests

associated
requests

observed
requests

request
history

Fig. 2 A classification of contextual information

if and only if for any two time points t and t(cid:9) in T , ϕt = ϕt(cid:9) . Otherwise, the contextual
information is dynamic.

Note that in practice the above definition can be relaxed. When a type of contex-
tual information keeps stable for a sufficiently long period, we can also consider it as
static. For instance, a user profile can be interpreted as static even though the user
may change his job as switching jobs is not frequent.

In Fig. 2, we classify the contextual information mentioned in this paper. To attack
query privacy, the adversary usually combines different contextual information. For
instance, when associated requests are explored [4, 10, 13], request generalisation
algorithms and users’ real-time spatial distribution are also part of the adversary’s
knowledge.

4 Privacy analysis based on user profiles

In this section, we demonstrate the implementation of our framework when user
profiles are explored by the adversary. Although user profiles and their impact on
query privacy have been discussed by Shin et al. [42], they do not describe precisely
how to exploit user profiles and quantify the amount of benefits gained by the
adversary. On the contrary, with our framework we can formally define the attack
and use a posterior probability distribution to describe the adversary’s knowledge
about the issuer.

As discussed in Section 3, given a generalised request (cid:4)r, t, q(cid:5) the key of query
privacy analysis is to compute users’ a priori probabilities, e.g., pu(q|Ct). Before
presenting the calculation, we start with formulating the adversary’ knowledge. User
profiles are associated with a set of attributes, e.g., contact attributes (zip codes,
addresses), descriptive attributes (age, nationalities, jobs) and preference attributes
(hobbies, moving patterns) [42]. The values of these attributes can be categorical
(e.g., nationality) or numerical (e.g., salary, age). Let (cid:4)a1 : A1, . . . , am : Am(cid:5) be the list
of the attributes where ai is the name of the attribute and Ai is its domain. The profile
of user u can be represented as a tuple of values each of which corresponds to an
attribute. Let (cid:4)u = (cid:4)α1, . . . , αm(cid:5) ∈ A1 × . . . × Am be the tuple where αi is the value

Geoinformatica (2014) 18:95–133

105

of ai and denoted by (cid:4)ai
time t can be represented as the following:

u . Thus the contextual information learnt by the adversary at

Ct = {Dt, f, {(cid:4)u|u ∈ U }}.

Our main idea to calculate pu(q|Ct) is to compute the relevance of user u’s profile
to each query and compare the relevance to q with those to other queries. Given
an attribute ai, we can discretise its domain Ai into intervals if it is numerical or
divide the domain into sub-categories if it is discrete. For instance, the domain of
attribute address can be categorised in terms of districts while the numerical values
of salary can be discretised into three intervals, such as ‘≤1000’, ‘1000–5000’ and
‘≥5000’. Note that the intervals are mutually exclusive and their union is equal to the
original domain.

With the list of the intervals, we can transform the value of an attribute into a
vector of binary values based on which interval or category it belongs to. Suppose Ai
∩ Ay
is divided into the list of intervals (A1
, . . . , Ak
i
i
i
and ∪1≤ j≤kA j
] j be the jth value. Thus, we
u be the vector of (cid:4)ai
i
have

) where for any 1 ≤ x, y ≤ k, Ax
i
u and [(cid:2)ai

= Ai. Let (cid:2)ai

u

[(cid:2)ai
u

] j =

(cid:3)

1
0

if (cid:4)ai
u
if (cid:4)ai
u

∈ A j
;
i
(cid:13)∈ A j
i .

If a user has a salary of 3000 euros, then (cid:2)salary

= [0 1 0].

u
Each query q ∈ Q has a set of related attributes that determines whether it is
likely for a user to issue the query q. Furthermore, for a given related attribute,
its value decides the amount of likelihood. For instance, for the query asking for
expensive hotels, the associated attributes should include salary, jobs and age while
gender is irrelevant. Among them, a salary is much more relevant than age and
moreover, a salary of more than 5000 euros is much more important than one of
less than 1000 euros. Therefore, we introduce a relevance vector for each attribute to
= [w1 . . . wn] be
express the relation between attributes’ values and queries. Let Wai
q
the relevance vector of query q of attribute ai. For any u ∈ U and q ∈ Q, the relevance
value of user u’s profile to query q can be calculated as follows:

]T is the transpose of Wai

where [Wai
q . Suppose the relevance vector of attribute salary
q
to a five-star hotel is [0 0.2 0.6] then vu(q) = [0 1 0] · [0 0.2 0.6]T = 0.2. Finally, we
can calculated u’s a priori probability pu(q|Ct) as follows:

vu(q) =

(cid:2)ai
u

· [Wai
q

]T

(cid:4)

i≤m

pu(q|Ct) =

(cid:2)

vu(q)
q(cid:9)∈Q vu(q(cid:9))

.

As users are independent from each other to decide next queries to issue and user
profiles are the only additional information in Ct to the inherent contexts, for the sake
of simplicity we use pu(q|Pu) to replace pu(q|Ct) when there is no confusion from the
context.

106

Geoinformatica (2014) 18:95–133

5 Privacy analysis based on query dependency

In this section, we identify a new type of contextual information—query dependency
and present how to incorporate it into our framework.

Since the first commercial LBSs launched in 1996, LBSs have evolved from simple
single-target finder to diverse, proactive and multi-target services [2]. However, due
to the lack of user privacy protection, especially at the beginning, LBS providers
accumulate a large amount of users’ historical requests. What makes the situation
worse is the shift of LBS providers from telecom operators (who were viewed
as trusted entities) to open businesses such as Google Latitude, Foursquare, and
MyTracks. This increases the risk of potential misuse of the accumulated records
due to the new sensitive information derived from them.

The dependency between queries is one type of such sensitive but personal
information. It is contained in users’ requests because of users’ preference in
arranging their daily activities [21]. This preference leads to a repetitive pattern in
their requests. For instance, a user often posts a check-in of a coffee house after
lunch. The fact that users’ frequent queries are usually restricted to a small set makes
the extraction of query dependency more precise.

Users’ query dependency can be abused and becomes a potential risk to users’
query privacy. As far as we know, we are the first to explore query dependency for
query privacy protection. We illustrate this by a simple example.

Example 1 Bob issues a request about the nearest night clubs in a 2-anonymous
region with Alice being the other user. Suppose the adversary has also learnt that
Alice just issued a query about the nearest clinics and Bob queried about bars. As it
is not common to ask clubs after clinics compared to bars, the adversary can infer that
Bob is more probable to issue the request about night clubs. In this example, even
if Alice and Bob share a similar profile, the dependency between queries obviously
breaks 2-anonymity for all users in the region who are supposed to be equally likely
to issue the request.

In the rest of this section, we start with a formal definition of the adversary’s
knowledge and then give an approach to derive dependency between queries for a
user from his request history. Then we propose a method for the adversary to breach
users’ query privacy by exploring query dependency.

5.1 Updating the adversary’s knowledge

Besides the contextual information considered in Section 4, there are two new types
of contextual information added—request history and observed request traces.

As we have mentioned before, LBS providers have collected users’ request his-
tory. For each user u, we assume that the adversary has a user u’s request history for a
sufficiently long period. We use a sequence to denote the requests of user u collected
by the adversary, i.e., Hu = ((cid:4)u, (cid:2)1, t1, q1(cid:5), . . . , (cid:4)u, (cid:2)n, tn, qn(cid:5)) (∀1≤i≤n−1ti < ti+1). The
ith request in Hu is represented by Hu(i). We call this sequence user request history,
whose length is denoted as len(Hu). For the sake of simplicity, we assume that Hu

Geoinformatica (2014) 18:95–133

107

is complete, namely there do not exist any requests that are issued by u during the
period but are not included in Hu.

Another assumption is that the adversary has access to the public channel which
transmits generalised requests. This means that the adversary can obtain any gener-
alised requests from users. We denote this contextual information by a sequence
of generalised requests in the chronologically ascending order. Up to time t, the
sequence of observed requests is Ot = ((cid:4)r1, t1, q1(cid:5), . . . , (cid:4)rn, tn, qn(cid:5)) (∀1≤i≤nti < ti+1 and
tn < t)). For the sake of simplicity, we do not consider recurrent queries, i.e., those
elements in Ot with the same time-stamps. Furthermore, for each request in Ot, the
adversary calculates its anonymity set, i.e., the users located in the generalised region.
Thus, for each user, the adversary can maintain a sequence of generalised requests,
whose anonymity sets contain this user. We call this sequence an observed request
trace and denote the one of user u up to t as Ou,t whose length is len(Ou,t). Obviously
with time passing, a user’s observed request trace keeps growing. The difference
between Hu and Ou,t is that the adversary is certain about the issuer of each request
in Hu but uncertain about the issuers of the requests in Ou,t.

To summarise, the knowledge of the adversary can be formulated as the following:

Ct = {Dt, f, {(cid:4)u|u ∈ U }, Ot, {Hu|u ∈ U }}.

5.2 Deriving query dependency

Query dependency can be used to predict a user’s next query based on his past
queries. However, when a user has no past queries or the past queries have little
impact on his future queries, we need to consider users’ a priori preference on queries.

Query dependency We model query dependency with the assumption that the
query that a user will issue next can only be affected by the last query that the user
has issued (i.e., the Markov property). For a pair of queries qi and q j, the dependency
of query q j on qi can thus be expressed by the conditional probability pu(q j|qi).

To find dependent queries, we need to identify the successive requests. Intuitively,
two requests are successive if there are no other requests between them in the
request history. This simply means that Hu(i +1) is the successive request of Hu(i) for
i < len(Hu). All the occurrence of query q j depending on qi can be captured by the set
of successive request pairs Si, j = {(Hu(k), Hu(k+1))|req(Hu(k)) = qi ∧ req(Hu(k+
1)) = q j, 0 < k < len(Hu)}. Given a request history Hu, the adversary can derive for
the user u his dependency between any pair of queries based on the sets Si, j. In this
paper we make use of Lidstone’s or additive smoothing [32] to ensure that there is
no dependency of degree zero for q j on qi due to no occurrence of the pair (qi, q j) in
the request history. Formally, let λ be the smoothing parameter which is usually set
to 1. The dependency pu(q j|qi) is calculated as follows:

pu(q j|qi) =

(cid:2)

|Si, j| + λ
qk∈Q |Si,k| + |Q| · λ

.

108

Geoinformatica (2014) 18:95–133

A priori preference There are many cases that a query does not depend on its past
queries. For example, users may issue an LBS query for the first time or accidentally
for an emergent need. In such cases, the best the adversary can do is to apply users’
a priori preference to find the possible issuer.

We model the a priori preference of a user u as a distribution over the set of
queries indicating the probability of the user to issue a query. For query qi ∈ Q, we
denote by pu(qi) the probability that user u issues the query qi when there is no
dependence on any previous queries. It is obvious that

(cid:2)

qi∈Q pu(qi) = 1.

There are many sources of information reflecting users’ a priori preference. Users’
personal information, i.e., user profiles, have been discussed in Section 4 and shown
effective in assessing users’ preference on queries [42, 43]. Moreover, a user’s request
history also reflects his preference. Thus, we estimate a user’s a priori preference by
combining his request history (Hu) and his user profile. Recall that we calculate a
distribution for each user over the set of queries indicating the probability that the
user issues a query based on his profile, i.e., pu(qi|Pu). Moreover, let pu(qi|Hu) be the
likelihood for user u to issue qi based on his request history. We can use the frequency
of the occurrence of the query in the request history to estimate pu(qi|Hu):

pu(qi|Hu) =

|{Hu(k)|query(Hu(k)) = qi}|
len(Hu)

.

The two distributions evaluate a user’s a priori preference on next queries from
two different perspectives. An agreement between them is needed. This is equivalent
to aggregate expert probability judgements [5]. We use linear opinion pool aggrega-
tion which is empirically effective and has been widely applied in practice [1]. By
assigning a weight to each distribution, i.e., wP and wH with wP + wH = 1, we can
calculate pu(qi) as follows:

pu(qi) = wP · pu(qi|Pu) + wH · pu(qi|Hu).

Remark 1 The way we model users’ query dependency and a priori preference has
some restrictions. For instance, we do not consider the influence of factors such as
the time when LBS requests are issued—usually a user’s behaviours on weekdays
are different from weekends. By distinguishing the request history at different time
periods, the impact of time can be taken into account. We have also assumed that
a query is only dependent on its immediate previous query. This restriction can be
lifted by considering, e.g., the last k historical queries. However, such dependency
might not be as efficient and accurate as the probabilities of the form of pu(qi|q j).
An interesting factor is the time intervals between successive requests, which may
present certain patterns as well. For instance, a user may prefer to issue a request
within a specific amount of time after the previous one. This leads to various
probabilities for a user to issue a query when he chooses different issuing time. In
Section 5.4, we take time intervals between requests as an example to illustrate how
to extend our model of query dependency to capture more influencing factors.

5.3 Query privacy analysis

Recall that the purpose of the adversary is to calculate the distribution p(U =
u|(cid:4)r, t, q(cid:5), Ct) given a generalised request (cid:4)r, t, q(cid:5). In the adversary’s knowledge, the

Geoinformatica (2014) 18:95–133

109

Fig. 3 A history window of n observed requests

observed request list (Ot) is the only dynamic context besides the spatial distrib-
ution (i.e., Dt) which is inherently contained. For the sake of simplicity, we use
p(u|(cid:4)r, t, q(cid:5), Ot) for short to represent p(U = u|(cid:4)r, t, q(cid:5), Ct) whenever no confusion
exists.

The key of query privacy analysis is still to calculate pu(q|Ct) (i.e., pu(q|Ot) for
short). Due to the independence between users with respect to issuing requests,
a user’s requests have no influence on the next query of any other user. Thus,
pu(q|Ot) = pu(q|Ou,t).

The size of Ou,t is an important factor determining the accuracy and the com-
plexity of the calculation of pu(q|Ou,t). Recall that Ou,t consists of all the observed
requests that may be issued by user u up to time t. Intuitively, the longer Ou,t is, the
more computational overhead is required to obtain p(u|(cid:4)r, t, q(cid:5), Ot). Therefore, it is
not practical to consider the complete Ou,t. Instead, we fix a history window which
consists of the latest n observed requests of user u (n ≤ len(Ou,t)). Our problem can
thus be reformulated as to compute pn(u|(cid:4)r, t, q(cid:5), Ot), indicating that the distribution
is based on the last n observed requests.

, ti1

, tin

, qi1

, qin

In Fig. 3, we show an example of a history window which contains n observed
(Ou,t) be the jth
requests, (cid:4)ri1
latest observed request in Ou,t, whose query is query((cid:2)q j
(Ou,t)) = qi j. In the following
discussion, we simply write (cid:2)q j if Ou,t is clear from the context. It is obvious that (cid:2)q1
is the latest observed request of user u.

> ti j−1 ( j > 1). Let (cid:2)q j

(cid:5), . . . , (cid:4)rin

(cid:5) with ti j

Once pn(u|(cid:4)r, t, q(cid:5), Ot) is calculated, it is added into the adversary’s knowl-
edge. Therefore, for a past request (cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5) in Ou,t (t(cid:9) < t), the adversary has
p(u|(cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5), O(cid:9)
). In the sequel, we simply denote it as p(u|(cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5)) in cases without
t
confusion.

A user’s latest request determines the probability distribution of his next query.
Whereas, it is uncertain which is the latest in the history window. To handle this
uncertainty, we distinguish three cases which are depicted in Fig. 4.

1. User u has issued both the last request (i.e., (cid:2)q1, see Fig. 4a) and the current
request (i.e., (cid:4)r, t, q(cid:5)). Considering query dependence, the probability of this
case is

pu(u|(cid:2)q1) · pu(q|qi1

).

2. User u has issued the current request (cid:4)r, t, q(cid:5) and his latest request is (cid:2)qm
(1 < m ≤ n) (see Fig. 4b). The probability of (cid:2)qm being the latest request is the
production of the probability that the last m − 1 requests are not issued by u
and the probability that u has issued (cid:2)qm, i.e., p(u|(cid:2)qm) ·
(1 − p(u|(cid:2)q j)).

(cid:5)

m−1
j=1

110

Fig. 4 The three cases

Geoinformatica (2014) 18:95–133

Considering query dependence, the probability of this case is

pu(q|qim

) · p(u|(cid:2)qm) ·

(1 − p(u|(cid:2)q j)).

m−1(cid:6)

j=1

3. User u did not issue any request in the history window (see Fig. 4c). In this case,
we suppose that the user issued the current request according to his a priori
preference, i.e., pu(q). Based on the probability that the user’s latest request
n
(1 − p(u|(cid:2)q j)), the probability of this
is outside of the history window as
j=1
case is

(cid:5)

pu(q) ·

(1 − p(u|(cid:2)q j)).

n(cid:6)

j=1

We sum up the above three probabilities to compute the probability for user u in
region r at time t to issue q when a history window of size n is considered:

pn
u

(q|Ou,t) = p(u|(cid:2)q1
n(cid:4)

) · pu(q|query((cid:2)q1

))

+

p(u|(cid:2)qm

) · pu(q|query((cid:2)qm

)) ·

(1 − p(u|(cid:2)q j

))

m−1(cid:6)

j=1

m=2

n(cid:6)

j=1

+ pu(q) ·

(1 − p(u|(cid:2)q j

)).

(3)

We use the following example with n = 2 to show the calculation.

Geoinformatica (2014) 18:95–133

111

Example 2 Suppose the last two requests are (cid:4)r(cid:9)(cid:9), t(cid:9)(cid:9), q(cid:9)(cid:9)(cid:5) and (cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5) with t(cid:9)(cid:9) < t(cid:9) < t
in Ou,t. Let (cid:4)r, t, q(cid:5) be an observed request. Then for user u, the probability that he
issues the request is computed as follows:

p2
u

(q|Ou,t) = pu(q|q(cid:9)) · p(u|(cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5))

(cid:7)
1 − p(u|(cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5))
(cid:7)
1 − p(u|(cid:4)r(cid:9), t(cid:9), q(cid:9)(cid:5))

(cid:8)

(cid:8)

+

+

· p(u|(cid:4)r(cid:9)(cid:9), t(cid:9)(cid:9), q(cid:9)(cid:9)(cid:5)) · pu(q|q(cid:9)(cid:9))
(cid:7)
1 − p(u|(cid:4)r(cid:9)(cid:9), t(cid:9)(cid:9), q(cid:9)(cid:9)(cid:5))
·

(cid:8)

· pu(q).

5.4 Handling the time intervals between requests

In this section, we study a factor that has impact on query dependency—time
intervals between two successive requests.

It has been noted that not only the behaviours of a user follow certain patterns but
also the amount of time between behaviours. For instance, Giannotti et al. [19, 20]
study and extract the pattern of the time intervals between events in sequential
pattern mining. The idea is also adopted by Chen et al. [9] for constructing and
comparing user mobility profiles. Similarly, with respect to LBS requests, users can
also have their preferences on the time intervals between two successive requests.

Example 3 Consider a user who is in a city centre and wants to meet his friends at
a bar. He first sends an LBS request asking for nearby friends who can potentially
meet together. Then the user contacts those friends and discuss with them about their
availability, which takes about half an hour. Afterwards, he issues another request for
nearby bars.

In the above example, the time interval between the two requests should usually
be around 30 min. Suppose that the user sent another query 2 min after the first
query about nearby friends. Then this query is less likely to be a query on nearby
bars, compared to the situation when a query is issued about 30 min later. Therefore,
query dependency should vary according to when the next query is issued.

To capture the influence of query issuing time, given two queries qi and q j, instead
of pu(q j|qi) we calculate the distribution pu(q j|qi, τ ), where τ is the amount of time
after user u issued the last request with query qi. This distribution can be calculated
based on other distributions deduced from the following equation:

pu(q j|qi, τ ) = pu(τ |q j, qi) · pu(q j, qi)

pu(τ |qi) · pu(qi)

= pu(τ |q j, qi)
pu(τ |qi)

· pu(q j|qi).

There are two new distributions in the above equation. The first one is pu(τ |q)
indicating the probability that a user issues a successive query with time interval
τ after issuing query q ∈ Q. The other distribution is pu(τ |q j, qi) meaning the
likelihood that if user u issues query q j after qi, then time interval between them
is τ .

The time interval between requests can be considered as a random variable T.
The above two distributions can thus be calculated based on the probability density

112

Geoinformatica (2014) 18:95–133

functions of T in different cases, i.e., ˆf (T|q) and ˆf (T|q j, qi). Let (cid:8) be the granularity
of time, e.g., a second or a minute. Then given a time interval τ , we have

pu(τ |qi) =

ˆf (T|qi)dT;

pu(τ |q j, qi) =

ˆf (T|q j, qi)dT.

(cid:9) τ +(cid:8)

τ

(cid:9) τ +(cid:8)

τ

The problem of density estimation based on observed data has been extensively
studied and some classic methods have been developed in practice, e.g., the kernel
estimator [12]. In our case, the key to estimate the density function of T is to extract
the corresponding set of observed samples of time intervals. Take ˆf (T|q j, qi) as an
example. The samples of time intervals form a multi-set which can be obtained from
users’ request history, e.g., Hu. Recall that Si, j is the set of pairs of successive requests
whose queries are qi and q j, respectively. Then the observed set of time intervals is
{t(cid:9) − t|((cid:4)r, t, qi(cid:5), (cid:4)r(cid:9), t(cid:9), q j(cid:5)) ∈ Si, j}.

The calculation of user u’s a priori probability at time t to issue query q (i.e., Eq. 3)
can thus be extended to handle the query dependency with respect to time intervals.
The calculation is shown in Eq. 4:

pn
u

(q|Ou,t) = p(u|(cid:2)q1
n(cid:4)

) · pu(q|query((cid:2)q1

), t − time((cid:2)q1

))

+

p(u|(cid:2)qm

) · pu(q|query((cid:2)qm

), t − time((cid:2)qm

)) ·

(1 − p(u|(cid:2)q j

))

m−1(cid:6)

j=1

m=2

n(cid:6)

j=1

+ pu(q) ·

(1 − p(u|(cid:2)q j

)).

(4)

6 Measuring query privacy

LBS requests are generalised to protect the issuers’ query privacy. The level of query
privacy offered by the generalisation algorithms should be quantified precisely. This
is due to (i) the generalisation algorithm requires the evaluation so as to improve
their performance; (ii) LBS users need the quantification to express their privacy
requirements for their requests.

Besides k-anonymity, many privacy metrics have been proposed in the literature,
such as correctness-based [44], estimation error-based [35] and feeling-based [47].
These metrics quantify query privacy from different perspectives. For instance, the
feeling-based metric makes use of entropy to evaluate the average uncertainty of
the adversary to guess the issuer in a given scenario (e.g., shopping mall) which is
subsequently used as the privacy requirement of users. Correctness-based metrics
quantify privacy as the probability of the adversary choosing the right issuer when
he makes a single guess. Using our framework, we can adopt the ideas of these
metrics, which leads to a diverse and comprehensive series of measurements for
query privacy. In this section, we present three new metrics on query privacy and
formally define them using our framework.

Inspired by anonymity degrees defined by Reiter and Rubin [36], we come up
with the following two new privacy metrics—k-approximate beyond suspicion and
user specif ied innocence. Note that user specified innocence coincides with the idea

Geoinformatica (2014) 18:95–133

113

of correctness-based metrics. Furthermore, we propose a third metric by exploring
entropy.

k-approximate beyond suspicion Beyond suspicion means from the attacker’s view-
point the issuer cannot be more likely than other potential users in the anonymity
set to issue the query. In the context of LBSs, we need to find a set of users in
which users are the same likely to send a given query. This set is taken as the
anonymity set whose size determines the degree of users’ privacy as in k-anonymity.
Let AS : Q(cid:9) → 2U denote the anonymity set of a generalised request. The issuer of
query (cid:4)u, whereis(u, t), t, q(cid:5) is beyond suspicious with respect to the corresponding
generalised request (cid:4)r, t, q(cid:5) if and only if ∀u(cid:9) ∈ AS((cid:4)r, t, q(cid:5)),

p(u|(cid:4)r, t, q(cid:5), Ct) = p(u(cid:9)|(cid:4)r, t, q(cid:5), Ct).

In practice, the number of users with the same probability to send a query is usually
small, which leads to a large generalised area with a fixed k. So we relax the re-
quirement to compute an anonymity set consisting of users with similar probabilities
instead of the exact same probability. Let (cid:15) p1, p2(cid:15) denote the difference between
two probabilities and (cid:8) be the pre-defined parameter describing the largest difference
allowed between similar probabilities.

Definition 2 (k-approximate beyond suspicion) Let (cid:4)u, whereis(u, t), t, q(cid:5) ∈ Q be a
query and (cid:4)r, t, q(cid:5) ∈ Q(cid:9) the corresponding generalised request. The issuer u is k-
approximate beyond suspicious if

| {u(cid:9) ∈ AS((cid:4)r, t, q(cid:5)) | (cid:15) p(u|(cid:4)r, t, q(cid:5), Ct), p(u(cid:9)|(cid:4)r, t, q(cid:5), Ct)(cid:15) < (cid:8) | ≥ k.

Different from k-anonymity, the set of users that are k-approximate beyond suspi-
cious is computed based on the spatial distribution of users with similar probabilities
rather than the original distribution involving all users. The users in an anonymity
set have similar probabilities and the size of the anonymity set is larger than k.
Therefore, k-approximate beyond suspicion can be seen as a generalised version of
k-anonymity. If for a specific query q ∈ Q, any two users have the same probability
to issue it, then k-approximate beyond suspicion is equivalent to k-anonymity. For
short, we use k-ABS to denote k-approximate beyond suspicion in the following
discussion.

User specif ied innocence Probable innocence and possible innocence are proposed
by Reiter and Rubin [36]. An issuer is probably innocent if from the attacker’s view
the issuer appears no more likely to be the originator of the query. In other words, the
probability of each user in the anonymity set to be issuer should be less than 50 %.
Meantime, possible innocence requires the attacker not be able to identify the issuer
with a non-trivial probability. We extend these two notions into a metric with user-
specified probabilities (instead of restricting to 50 % or non-trivial probability which
is not clearly defined). We call the new anonymity metric user specif ied innocence
where α ∈ [0, 1] is the specified probability given by the issuer. Intuitively, for a
query, an issuer is α-user specified innocent, if the anonymiser generates the same
region for any user in the region with the same specified value α. In other words,
in the generalised region, the most probable user has a probability smaller than α.

114

Geoinformatica (2014) 18:95–133

Recall that u(cid:2)(r, t) denotes the set of users in region r at time t. It is clear that the
anonymity set consists of all users in the generalised area.

Definition 3 (User specified innocence) Let α ∈ [0, 1], (cid:4)u, whereis(u, t), t, q(cid:5) ∈ Q be
a query and (cid:4)r, t, q(cid:5) ∈ Q(cid:9) the corresponding generalised request. The issuer u is α-user
specif ied innocent if for all u(cid:9) ∈ u(cid:2)(r, t),

p(u(cid:9)|(cid:4)r, t, q(cid:5), Ct) ≤ α.

We abbreviate α-user specified innocence as α-USI.

An entropy-based metric Serjantov and Danezis [41] define an anonymity metric
based on entropy and Díaz et al. [15] provide a similar metric that is normalised by
the number of users in the anonymity set. The concept entropy of a random variable
x∈X p(x) · log p(x) where X is the domain (all possible
X is defined as H(X) = −
values) of X. In our context, entropy can also be used to describe the attacker’s
uncertainty to identify the issuer of a generalised request. Let variable U denote the
issuer of query (cid:4)r, t, q(cid:5). Then the uncertainty of the attacker can be expressed as

(cid:2)

H(U|(cid:4)r, t, q(cid:5), Ct) = −

p(u(cid:9)|(cid:4)r, t, q(cid:5), Ct) · log p(u(cid:9)|(cid:4)r, t, q(cid:5), Ct).

(cid:4)

u(cid:9)∈u(cid:2)(r,t)

For a given generalised request (cid:4)r, t, q(cid:5) and a given value β, we say that the issuer
is entropy-based anonymous with respect to the value β if all users in region r
can have r as the generalised region when issuing the same query and the entropy
H(U|(cid:4)r, t, q(cid:5), Ct) is not smaller than β.

Definition 4 (Entropy-based anonymity) Let β > 0, (cid:4)u, whereis(u, t), t, q(cid:5) ∈ Q be a
query and (cid:4)r, t, q(cid:5) ∈ Q(cid:9) the corresponding generalised request. The issuer u is β-
entropy based anonymous if

H(U|(cid:4)r, t, q(cid:5), Ct) ≥ β.

For short, we call β-entropy based anonymity β-EBA.

Remark When users use these metrics to express their privacy requirements, at least
three elements should be provided—a metric, the values of the parameters required
by the chosen metric (e.g., k, α), and the values of the parameters used to calculation
posterior probabilities (e.g., the size of history windows).

In practice it is difficult and cumbersome for a user to give exact values to the
elements. First, all the metric values in requirements should be determined before
requests are generalised (i.e., ex-ante) but they are defined ex-post in nature in the
metric. Furthermore, users need to understand the meaning of each parameter and
the corresponding implication on privacy protection. To avoid this situation, in this
paper we provide a list of privacy levels, e.g., from low to very high. Each level
corresponds to a setting of privacy parameters. For example, when query dependency
is considered, a user’s privacy requirement can be represented as (cid:4)kABS, high(cid:5),
which is then transformed into (cid:4)kABS, (10, 0.05), (5)(cid:5). This ensures that whenever a
request is successfully generalised, the region contains 10 users with similar posterior
probabilities to the issuer’s, after taking into account the last 5 observed requests.

Geoinformatica (2014) 18:95–133

115

Furthermore, the distance between two such users’ posterior probabilities is bounded
by 0.05. In practice, the transformation can be made automatic and embedded in the
request generalisation process. Note that the existing works can also be adapted to
determine the values, e.g., the feeling-based privacy metric [47].

7 Generalisation algorithms

In this section, we develop area generalisation algorithms to compute regions satisfy-
ing users’ privacy requirements expressed in the proposed metrics in Section 6. As to
find a region satisfying k-ABS is similar to compute a region satisfying k-anonymity
on a given spatial distribution, we design an algorithm for k-ABS by combining the
algorithm grid [33] with a clustering algorithm. For the other metrics, we design a
uniform algorithm based on dichotomicPoints [33].

7.1 An algorithm for k-ABS

To find an area that satisfies k-ABS is to guarantee that at least k users in the area
have similar posterior probabilities. This task can be divided into two main steps.
The first is to obtain the spatial distribution of the users who have similar a priori
probabilities to the issuer (e.g., pu(q|Ct)). The second step is to run a k-anonymity
generalisation algorithm to find a region with at least k users based on the spatial
distribution computed at the first step.

The first step can be transformed to the clustering problem. Given q ∈ Q, we need
to cluster the users in U such that the users with similar a priori probabilities with
respect to issuing q are grouped together.

For the second step, we use algorithm grid by Mascetti et al. [33] as it generates
regular regions with smaller area compared to others. A two-dimensional space is
partitioned into a grid with (cid:16) N
(cid:17) cells each of which contains at least k users, where N
k
denotes the number of users in U . A user’s position is represented by two dimensions
x and y. The algorithm grid consists of two steps. First, users are ordered based on
dimension x, and then on y. The ordered users are divided into (cid:16)
(cid:17) blocks of
consecutive users. The block with the issuer enters the second step. The users in
this block are then ordered first based on dimension y and then x. These users are
also partitioned into (cid:16)
(cid:17) blocks. Then the block with the issuer is returned as the
anonymity set. Details of the grid algorithm can be found in [33].

(cid:10)

(cid:10)

N
k

N
k

Algorithm 1 describes our algorithm for k-ABS. In general, it gives the generalised
region as output which satisfies the user requirement k. Function cluster returns the
cluster of users with similar probabilities to that of u with respect to query q. Then
the function grid outputs a subset of sim_users with at least k users who are located
in the rectangular region. The generalised region is computed by function region.

Note that the clustering algorithm does not have to run each time when there
is a request coming to the anonymiser. As long as the spatial distribution remains
static or does not have big changes, for the requests received during this period,
the anonymiser just executes the clustering algorithm once and returns the cluster
containing the issuer as output of function cluster. The choice of the clustering
algorithms has an impact on the performance of the generalisation algorithm.

116

Geoinformatica (2014) 18:95–133

Algorithm 1 A generalisation algorithm for k-ABS.

1: FUNCTION: kABS
2: INPUT: (cid:4)u, whereis(u, t), t, q(cid:5), dis(t), k, M(q) = { pu(cid:9) (q|Ct)|u
3: OUTPUT: A region r that satisfies k-ABS
4:
5: sim_users :=cluster(u, q, M(q));
6: AS := grid(sim_users, dis(t), k);
7: r := region(AS)

(cid:9) ∈ U}

The complexity of Algorithm 1 is the sum of those of the clustering algorithm
implemented and the gird algorithm (O(
kN) [33]). The correctness of
Algorithm 1 is stated as Theorem 1 and its proof is rather straightforward.

kN log

√

√

Theorem 1 For any (cid:4)u, (cid:2), t, q(cid:5) ∈ Q, Algorithm 1 computes a generalised region in
which the issuer u is k-approximate beyond suspicious.

7.2 An algorithm for α-USI and β-EBA

For privacy metrics α-USI and β-EBA, we design a uniform algorithm where users
can specify which metric to use. Recall that in grid, the number of cells is pre-
determined by k and the number of users. Thus it is not suitable to perform area
generalisation for metrics without a predefined number k. Instead we use algorithm
dichotomicPoints.

The execution of dichotomicPoints involves multiple iterations in each of which
users are split into two subsets. Similar to grid, positions are represented in two
dimensions x and y, and users are also ordered based on their positions. How-
ever, different from grid the orders between axes are determined by the shape of
intermediate regions rather than fixed beforehand. Specifically, if a region has a
longer projection on dimension x, then x is used as the first order to sort the users.
Otherwise, y is used as the first order. Users are then ordered based on the values
of their positions on the first order axis and then the second order. Subsequently,
users are partitioned into two blocks with the same or similar number of users along
the first order axis. The block containing the issuer is taken into the next iteration.
This process is repeated until any of the two blocks contains less than 2k users. This
termination criterion is to ensure security against the outlier problem (see Section 2).
However, in our uniform algorithm, instead of checking the number of users, we
take the satisfaction of users’ privacy requirement as the termination criterion, e.g.,
if all users in the two blocks have a probability smaller than α.

Given a request, our uniform algorithm executes three main steps to calculate
the generalised region. The first step is to update users’ a priori probabilities (at
time t) based on the latest contextual information Ct. This is done by the procedure
updatePriori. This step can be skipped if the evolution of the contextual information
does not affect the a priori probabilities, e.g., when only user profiles are contained.
In the second step, after determining the first order axis, we call function updateAS
to find a smaller anonymity set. It takes a set of users and partitions them into two
subsets along the first order axis, both of which should satisfy the issuer’s privacy
requirement and updateAS returns the one containing the issuer as the updated

Geoinformatica (2014) 18:95–133

117

(cid:9)).x;
(cid:9)).y;
(cid:9)).x;
(cid:9)).y;

(cid:9) ∈ AS, calculate pu(q|Ct). ∗\

if (maxx − minx) ≥ (maxy − minx) then

Algorithm 2 The uniform generalisation algorithm for α-USI and β-EBA.
1: FUNCTION: uniformDP
2: INPUT: qu = (cid:4)u, (cid:2), t, q(cid:5), req(qu), Ct
3: OUTPUT: Region r that satisfies req(qu)
4:
5: AS := U;
6: updatePriori(AS); \∗ for each u
7: cont := check(AS, req(qu));
8: if cont = false then
return ∅;
9:
10: end if
11: while cont do
12: minx := minu(cid:9)∈AS whereis(u
13: miny := minu(cid:9)∈AS whereis(u
14: maxx := maxu(cid:9)∈AS whereis(u
15: maxy := maxu(cid:9)∈AS whereis(u
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32: end while
33:
34: updateContext(Ct);
35: return region(AS);

(cid:9) = AS then
(cid:9) = updateAS(AS, req(qu), second);

(cid:9) = updateAS(AS, req(qu), f irst);

end if
AS
if AS
AS
end if
if AS

f irst := x;
second := y;

f irst := y;
second := x;

(cid:9) (cid:13)= AS then

cont := false;

cont := true;

end if

else

else

anonymity set. When it is not possible to partition users along the first order axis,
i.e., one of the two blocks generalised by any partition fails the issuer’s requirement,
the second order axis will be tried. If both tries have failed, updateAS simply returns
the original set, which means no possible partition can be made with respect to the
privacy requirement. In this situation, the whole algorithm terminates. Otherwise,
the new set of users returned by updateAS is taken into the next iteration. Last, if
the request can be generalised, then we should update the contextual information to
include the generalised request, e.g., the observed request lists (i.e., Ot, Ou,t). This is
done by calling the function updateContext whose implementation is determined by
the exploited contextual information.

118

Geoinformatica (2014) 18:95–133

Algorithm 2 describes

the uniform algorithm in detail. The function
check(AS, req(qu)) calculates the normalised a priori probability of each user
in AS. Then the function takes the resulted normalised probabilities as the users’
posterior probabilities and check whether they satisfy the requirement req(qu). The
boolean variable cont is used to decide whether the algorithm should continue. It
is set to false when the set of users in U does not satisfy the requirement (line 7)
or when AS cannot be partitioned furthermore (line 30). The former case means
that the requirement req(qu) is set too hight to be satisfied and the algorithm should
immediately terminate while the latter case indicates that the generalised region
is found. The anonymity set AS is represented as a two-dimensional array. After
ordering users in AS, AS[i] consists of all users whose positions have the same value
on the first order axis. We use len(order) to denote the size of AS in the dimension
denoted by order. For instance, in Fig. 5a, axis x is the first order axis and AS[3] has
three users with the same x values. Moreover, len(f irst) is 6.

The function updateAS shown in Algorithm 3 is critical for our algorithm uni-
formDP. It takes as input a set of users and outputs a subset that satisfies the
issuer’s privacy requirement req(qu). It first orders the users and then divides
them into two subsets with the same number of users along the first order axis
(indicated by the variable order). This operation is implemented by the function
mid(AS, order) which returns the middle user’s index in the first dimension of AS. If

(a)

(c)

(b)

(d)

Fig. 5 An example execution of our algorithm uniformDP

Geoinformatica (2014) 18:95–133

119

Algorithm 3 The function updateAS.

(cid:9) ⊆ AS that contains u and satisfies req(qu)

AS := part(i, u);

1: FUNCTION: updateAS
2: INPUT: AS, req(qu), order
3: OUTPUT: AS
4:
5: AS := reorder(AS, order);
6: i := mid(AS, order);
7: if check(left(i), req(qu)) ∧ check(right(i), req(qu)) then
8:
9: else
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20: end if
21: return AS;

found := false;
j := 0;
while j ≤ len(order) ∧ ¬found do

found := true;
AS := part( j, u);

end if
end while

j := j + 1;

else

if check(left( j), req(qu)) ∧ check(right( j), req(qu)) then

both of the two subsets satisfy req(qu), then the one containing the issuer is returned
(implemented by function part(i, u)). Otherwise, an iterative process is started. In
jth iteration, the users are partitioned into two sets one of which contains the users
in AS[1], . . . , AS[ j] (denoted by left( j)) and the other contains the rest (denoted by
right( j)). These two sets are checked against the privacy requirement req(qu). If both
left( j) and right( j) satisfy req(qu), the one with issuer u is returned by part( j, u). If
there are no partitions feasible after len(order) iterations, the original set of users is
returned.

An example execution of Algorithm 2 is shown in Fig. 5. The issuer is represented
as a black dot. In Fig. 5a the users are first partitioned into two parts from the middle.
Assume both parts satisfy req(qu), so the set b 1 is returned as the anonymity set
AS for the next iteration. As b 1’s projection on axis y is longer, the first order is
set to axis y (Fig. 5b). If after dividing the users from the middle, the set b 2 does
not satisfy req(qu). Thus, the users are partitioned from AS[1] to AS[4] (Fig. 5c).
Suppose no partitions are feasible. The first order axis is then switched to axis x.
Function updateAS is called again to find a partition along axis x (Fig. 5d).

We can see Algorithm 2 iterates for a number of times. In each iteration, some
users are removed from the previous anonymity set. Operations such as partition
and requirement check are time-linear in the size of the anonymity set. The number
of iterations is logarithmic in the number of the users. So in the worst case, the time
complexity of Algorithm 2 is O(N log N), where N denotes the number of all users
in U . The correctness of Algorithm 2 is stated as Theorem 1.

Theorem 2 For any query (cid:4)u, (cid:2), t, q(cid:5), Algorithm 2 computes a generalised region that
satisf ies the issuer u’s privacy requirement req((cid:4)u, whereis(u, t), t, q(cid:5)).

120

Geoinformatica (2014) 18:95–133

Proof By Deﬁnitions 3 and 4, Algorithm 2 computes a region r for a query
(cid:4)u, whereis(u, t), t, q(cid:5) that satisfies a constraint related to the issuer’s posterior prob-
ability and the entropy about the issuer. We take α-USI as an example to show the
correctness of our algorithm and the proofs of the other two are analogous.

By Deﬁnition 3, we have to prove the posterior probability of each user u(cid:9) ∈
u(cid:2)(r, t) is smaller than α, i.e., p(u(cid:9)|(cid:4)r, t, q(cid:5), Ct) ≤ α. According to Eqs. 1 and 2, we
need to prove for any u(cid:9) ∈ u(cid:2)(r, t) (1) f ((cid:4)u(cid:9), whereis(u(cid:9), t), t, q(cid:5)) = (cid:4)r, t, q(cid:5) and (2) his
normalised a priori probability over those of all users in region r should be smaller
than α, i.e.,

(cid:2)

p(q|u(cid:9), Ct)
u(cid:9)(cid:9)∈U p(q|u(cid:9)(cid:9), Ct)

≤ α.

(5)

(cid:9)
Let u(cid:9) be any user in the generalised region r of Algorithm 2. Let AS j and AS
j be
the values of AS in the jth iteration of Algorithm 2 of u and u(cid:9), respectively. To prove
(1), we show that ASj = AS

by induction on the number of iterations, i.e., j.

(cid:9)

Induction basis: Initially, we suppose that U satisfied the requirement. Then we have

AS1 = AS

(cid:9)
1.

Induction step: Assume at jth iteration AS j = AS
algorithm either terminates with AS j and AS
tion with AS j+1 = AS
mid(AS j, order) = mid(AS

j+1. The equality that AS j = AS

(cid:9)

(cid:9)
j

(cid:9)
j. We have to show that the
(cid:9)
j, or enters the next itera-
is followed by that

, order). There are three possible executions.

(cid:9)
j

Case 1 if left(i) and right(i) of AS j and AS

(cid:9)
j satisfy the requirements (line 7 of
Algorithm 3), the part containing the issuer is returned. Thus AS j+1 contains
u as well as all other users in u(cid:2)(r, t), including u(cid:9). Thus, AS j+1 = AS
Case 2 if the check at line 7 of Algorithm 3 fails, then the algorithm switches to
find from the beginning the first feasible partition. Suppose the partition is
(cid:9)
made at the position x for AS j. Then x is also the right position for AS
j as
(cid:9)
AS j = AS
j. Because of the similar reason in the previous possible execution,
the same subset is set to AS j+1 and AS

j+1. Thus, AS j+1 = AS

Case 3 if there are no possible partitions, Algorithm 3 returns AS j+1 and AS

(cid:9)
j+1 in
both cases. Then the first order is changed and Algorithm 3 is called again.
If one of the first two execution is taken, with the analysis above, we have
j+1. Otherwise, Algorithm 2 terminates with region(AS j) and
AS j+1 = AS
(cid:9)
region(AS
) which are equal.
j

(cid:9)
j+1.

(cid:9)
j+1.

(cid:9)

(cid:9)

We proceed with (2). Recall that the function check(AS, req(qu)) returns true for
metric α-USI only if Eq. 5 holds for each user in AS because it takes users’ normalised
a priori probabilities as their posterior probabilities. At the line 5 of Algorithm 2,
we set AS to the original user set U and the algorithm continues only if the function
check(U , req(qu) returns true. Otherwise, it is impossible to return a region satisfying
the requirement. The set AS is only reassigned to another set when a partition is
made (line 8 or line 15 in Algorithm 3). For the two sets by the partition check all
returns true and the one containing the issuer is assigned to AS. Thus, it is guaranteed
that for each user u(cid:9) ∈ u(cid:2)(r, t), Eq. 5 holds.
(cid:21)(cid:22)

Geoinformatica (2014) 18:95–133

121

8 Experimental results

We conduct experiments to evaluate our work from two aspects. First, we test
the effectiveness of our framework in terms of the changes of issuers’ posterior
probabilities. In this way, we illustrate that users’ personal profiles and request
histories do cause privacy risks. Second, we implement our algorithms presented in
Section 7 and with the experimental results we show and compare the characteristics
of our new metrics proposed in Section 6.

To perform the experiments, we construct two sample datasets to simulate the
spatial distributions of a collection of mobile users (mobility dataset) and their issued
requests during movements (request dataset). We generate the mobility dataset using
the moving object generator [6] and it consists of the trajectories of 38,500 users
in a period with 50 discrete time points. We compose a series of request datasets
corresponding to different numbers of active users. A user is called active if he
subscribes certain LBSs and would issue requests during the period. Given a number
of active users, we simulate a trace of requests for each of them according to his
query dependency and his a priori preference on queries. Note that throughout
the experiments, we do not distinguish users’ a priori preferences from the a priori
probabilities computed based on user profiles. This is because they are both static
and a priori probabilities have already been considered in the calculation of a priori
preferences. We assume 6 types of queries for users to choose. This makes users’
a priori preference around 17 % on average. As we mentioned, our purpose is to
evaluate the privacy risk incurred by contextual information and the effectiveness
of the algorithms. Thus we assume that users’ query dependency is available and
generate it by a random procedure. Users’ a priori preference is assessed in a
similar way.

Our simulation is implemented with Java and run on a Linux laptop with 2.67 Ghz

Intel Core (TM) and 4GB memory.

8.1 Impact of contextual information

We validate the effectiveness of our framework by checking if it can increase the
likelihood of the adversary to correctly identify issuers by obtaining more contextual
information. Given a generalised request, we can use the issuer’s posterior prob-
ability as the measurement of the correctness of the adversary’s attack on query
privacy [44]. If a type of contextual information can help breach users’ query privacy,
then issuers will have larger posterior probabilities than those computed without the
information on average. The main idea of our validation is to check whether the
framework can capture this increase.

In our experiments, we construct three attack scenarios where k-anonymity spatial
generalisation is deployed. In the first scenario, the adversary only learns the inherent
contextual information while in the other two scenarios, users’ a priori preferences
and request histories are added sequentially to the adversary’s knowledge. We
denote the corresponding contextual information by Cbasic
, respectively.
We define correctness increase ratio (CIR), and use it to quantify the increase
of issuers’ posterior probabilities when more contextual information is explored.
Specifically, it is computed as the ratio of the increase over the posterior probabilities
calculated without considering the contextual information. In this paper, we consider

t and Cdep

, Cpf

t

t

122

Geoinformatica (2014) 18:95–133

two CIRs, i.e., (cid:10)ppf and (cid:10)pdep. For a generalised request (cid:4)r, t, q(cid:5) issued by u, they can
be calculated as follows:

where

and similarly,

(cid:10)ppf = p(u|(cid:4)r, t, q(cid:5), Cpf

t

) − p(u|(cid:4)r, t, q(cid:5), Cbasic

)

t

p(u|(cid:4)r, t, q(cid:5), Cbasic

)

t

p(u|(cid:4)r, t, q(cid:5), Cbasic

) =

t

1
|{u ∈ U |whereis(u, t) ∈ r}|

,

(cid:10)pdep = p(u|(cid:4)r, t, q(cid:5), Cdep

t

) − p(u|(cid:4)r, t, q(cid:5), Cpf
t
)

)

.

p(u|(cid:4)r, t, q(cid:5), Cpf
t

In Fig. 6, we show how the correctness increase ratio changes with issuers’ a
priori preferences and the dependency between the last two queries. With respect
to query dependency, we also illustrate the impact of the history window sizes (see
Fig. 6b). The results are obtained by a simulation with 8,000 requests. We divide
the requests into clusters according to the a priori preference or query dependency
of the issuers when sending the requests. Specifically, we set pq = 0.05 · cid where
cid (1 ≤ cid ≤ 20) is the identifier of a cluster to be the maximum value of issuers’
a priori preference allowed in the cluster cid. For example, if pq = 0.15, the issuer
of any request in the cluster has an a priori preference between 0.1 and 0.15 with
= 0.05 · cid to represent the
respect to the issued query. Similarly, we define pqi|qi−1
maximum query dependency allowed in cluster cid when the issuers issue the queries.
Figure 6 depicts the average (cid:10)ppf and (cid:10)pdep of the generalised requests in each
cluster satisfying k-anonymity with k = 10 and with 2.6 % of the users being active.
We observe that the curves in Fig. 6a and b follow two similar patterns. First, the
CIR increases monotonically when ρ grows. Second, the average correctness increase
ratio reaches 0 when the a priori preferences and query dependency fall into the
interval between 0.15 and 0.2. This is due to the fact that users’ average a priori

Fig. 6 Impact of user profiles and query dependency on (cid:10)p

Geoinformatica (2014) 18:95–133

123

preference on each type of queries ( pu(qi)) is around 17 %. With regard to (cid:10)ppf, the
issuer with an a priori preference of 0.17 will eliminate his difference from the other
users in the same region as the average of their a priori preferences is also close to
0.17. For (cid:10)pdep, the little difference between pu(qi|qi−1) and pu(qi) eliminates the
influence of query dependency.

We can see that (cid:10)pdep is also sensitive to the size of history windows in Fig. 6b.
Larger history windows lead to bigger correctness increase ratios when the depen-
dency between the last two queries (i.e., pu(qi|qi−1)) is bigger than 0.17. For instance,
for the requests with query dependency between 0.3 and 0.4, the average value of
(cid:10)pdep increases by 0.051, 0.036, 0.031 when n grows from 1 to 2, from 2 to 3, from
3 to 4, respectively. By more experiments with larger n, we can show that bigger
window sizes do not necessarily lead to more privacy leakage. For instance, when n
is set to 5, the average increase of CIR is 0.029 which is almost the same as the case
of n = 4.

From the above discussion, we can conclude that if a user issues a query with
a large preference value or high dependency on the last queries, he will have less
privacy if the adversary adopts our framework. This also shows that our framework
is useful to increase the likelihood of attackers to correctly learn the real issuers
although we have negative CIRs when users issue queries independently from their
profiles or last queries. This is because in most of the cases, users’ behaviour should
be consistent with their profiles and past habits.

Beside the size of history windows, the number of active users has impact on
(cid:10)pdep as well. It decreases when there are more active users issuing LBS requests,
but the influence becomes smaller with larger history windows. Figure 7 shows that
the average (cid:10)pdep decreases by 30 %, 24 % 19 % and 18 % for n = 1, 2, 3 and 4,
respectively, when the percentage of active users increases from 2.5 % to 7.5 %.
This is because more active users lead to more observed requests added into users’
observed request traces and mixed with users’ real requests, while bigger history
windows have larger chances to include users’ real requests.

Fig. 7 (cid:10)p vs. #active users and
n

124

Geoinformatica (2014) 18:95–133

8.2 Effectiveness of the new privacy metrics

In this section we discuss the features of our privacy metrics in terms of (1) area
of the generalised regions and (2) issuers’ posterior probabilities. To compare the
metrics presented in Section 6, we define a normalised value norm: norm = k for
query-dependent k-ABS while norm = 2β for β-EBA and norm = 1
α for α-USI. In
the following experiments, we take Cdep
as the knowledge of the adversary due to its
large coverage of contextual information.

t

Experiment setting We set the percentage of active users to 2.6 % and use the first
1,000 requests after 8,000 requests have been observed. Each number shown in the
following discussion is an average of the 1,000 samples.

Recall that in the generalisation algorithm kABS (see Algorithm 1) we make
use of a clustering algorithm to calculate the set of users with similar a priori
probabilities. Clustering has been extensively studied in the literature and a number
of clustering algorithms have been proposed to satisfy different properties, e.g.,
density-based and distribution-based [23]. In the case of generalising LBS requests,
the chosen clustering algorithm should satisfy at least two properties. First, the
clustering algorithm should be efficient because LBS responses need to be sent back
to uses in real time. Second, we need a strict partitioning clustering algorithm as each
user should belong to exact one cluster.

In the implementation of kABS, we use the K-means clustering algorithm [31].
This is mainly due to its linear time complexity with the number of users. Its main
idea is to choose K centroids, one for each cluster. In our algorithm, the K centroids
are selected randomly among the users. Then each user is associated to the nearest
centroid according the difference between their a priori probabilities, which results in
K clusters. The centroids of these K clusters are updated as the new centroids based
on which all users re-calculate their centroids to associate. The process continues
until the centroids remain unchanged between two consecutive iterations. In our
case, K is selected and fixed by the anonymiser. In fact, it defines the ‘similarity’
in the definition of k-ABS in Section 6, i.e., (cid:8). The larger K is, the smaller (cid:8) becomes.
In order to determine a proper value of K, we run our kABS algorithm by
assigning different values to K. In Fig. 8, we show the changes of the average distance
between any two users’ a priori probabilities in the calculated clusters and the area
of the generalised regions along with K. It can be seen that a larger K enables users
to have closer a priori probabilities but leads to larger generalised areas. In addition,
the area increases faster than the decrease of the distance. Considering the relatively
small generalised regions and the similarity between users in the resulted clusters, we
set K to 10 in the following experiments.

Impact of history window sizes From the above discussion, we learn that users will
have less query privacy when larger history windows are used in our framework.
Figure 9 shows how issuers’ posterior probabilities and the area of generalised
regions change according to the normalised value norm and the history window size
n. Note that when n = 0, the generalisation algorithm only considers users’ a priori
preference.

For k-ABS, issuers’ posterior probabilities are about 1

k as the generalised regions
have at least k users with similar posterior probabilities. However, after taking a

Geoinformatica (2014) 18:95–133

Fig. 8 The impact of K

125

closer look, we can find that a larger n leads to a larger distance to 1
k . This is because
larger history windows make the issuers’ posterior probabilities more different from
the others, which in turn makes it more difficult to find users with similar posterior
probabilities. This also explains why the generalised regions become larger with
larger history windows as shown in Fig. 9b.

For α-USI, issuers’ posterior probabilities are always below 1

norm , which satisfies
its definition (see Fig. 9c). Moreover, issuers’ posterior probabilities become larger
when more historical observed requests are explored. However, the area of gen-
eralised regions differs little between different history window sizes (see Fig. 9d).
This is because the increase of the posterior probabilities is too small to initiate the
computation of a new region.

For β-EBA, issuers’ posterior probabilities can remain almost unchanged in some
segments of the curves. The projection of the middle point of such a segment on
axis norm has an logarithm of integer, such as 16 and 32 (see in Fig. 9e). Similar
to k-ABS, larger history windows increase the issuers’ posterior probabilities, which
leads to smaller entropy. This can be seen from Fig. 9f where the generalised regions
of larger n double their sizes earlier than the regions of smaller n.

We can also observe from Fig. 9 that for the same value of norm, although the
metric β-EBA cannot always ensure issuers’ posterior probabilities as close to 1
k as
k-ABS, the area of generalised regions is about ten times smaller than that of k-ABS
and only half of that of α-USI. Since bigger regions lead to worse quality of service,
this indicates that a balance between privacy protection and quality of services needs
to be considered in practice.

Impact of query dependency The protection of issuers’ privacy varies with issuers’
query dependency. Figure 10 plots posterior probabilities and average area of gener-
alised regions for issuers with different levels of query dependency. The results are
collected with the history window size n = 3. Our general observation is that issuers
with larger dependencies have bigger posterior probabilities and larger generalised
regions.

126

Geoinformatica (2014) 18:95–133

Fig. 9 Impact of history window size n

Table 2 summarises the corresponding average increases (in percentage) for is-
suers with high (≥0.45) and medium (0.25–0.45) dependencies, when compared with
those with low dependencies (≤0.25). The table shows that posterior probabilities of
the issuers, when β-EBA is used, are more sensitive to the degree of dependency
(43.1 % increase for high-level dependency), while the generalised regions are more

Geoinformatica (2014) 18:95–133

127

Fig. 10 Impact of dependency p(qi|qi−1)

sensitive to dependency (62.9 % increase for high-level dependency) when k-ABS
is used.

Performance of the proposed generalisation algorithm In Fig. 11, we present the per-
formance of our generalisation algorithms to deal with users’ various requirements.
For the sake of comparison, we show in Fig. 11 the performance of the algorithms

128

Geoinformatica (2014) 18:95–133

Table 2 Increases in posterior
probabilities and average area
of generalised regions

k-ABS

β-EBA

α-USI

Medium High Medium High Medium High
(%)
(%)

(%)

(%)

(%)

(%)

Posterior prob.
Avg area

2.1
21.3

9.5
62.9

11.1
23.3

43.1
30.1

11.9
10.7

40.0
19.1

when contextual information is set to Cpf
, respectively. The computation
time recorded is the average time per request based on executions with the same 100
requests.

t and Cdep

t

t

As discussed in Section 7, it is necessary to update the status of each user when
dynamic contextual information is explored. For instance, observed request traces
and the corresponding posterior probabilities have to be updated for each request
when Cdep
is used. This is time-consuming, especially when the initial region is
huge and contains a large number of users. In our implementation, we reduce the
computation overhead by restricting the size of initial regions. The number of users
located in an initial region is fixed as ten times as many as what users require for.
For instance, for k-ABS, if k = 10, then we first call k-anonymity generalisation
algorithm to get an initial region with 100 users. As the generalisation algorithm is
deterministic, which means for any user in a generalised region, it always returns the
same region. Thus, our implementation does not have the “outlier” problem [33].

From Fig. 11, we can see that the computation time increases as norm gets bigger.
This is because the algorithm has to consider larger initial regions and more users
are involved in the calculation of dependency-based posterior probabilities. For β-
EBA and α-USI, about 20 ms are needed when norm = 50, while k-ABS requires
more time (around 35 ms) as the K-means clustering algorithm is executed first to
find similar users. When compared to the original algorithms, the computation time

Fig. 11 Average
computational time (history
window n = 3)

Geoinformatica (2014) 18:95–133

129

increases by about two times for β-EBA and α-USI while it is about four times for
k-ABS when norm = 50.

There are some ways to improve the efficiency of our implementation. For
instance, we can use better data structures to maintain users’ status. We can expect
that with a powerful anonymiser our algorithms are efficient enough to handle
concurrent requests and give real-time responses.

9 Conclusion

In this paper, we have developed a formal framework for query privacy analysis
exploring contextual information. In the framework, we systematically categorise
contextual information and propose a probabilistic way to model the adversary’s
attacks on query privacy. Specifically, we use a posterior probability distribution to
describe the knowledge learnt by the adversary about the issuers after the analysis.
This interpretation allows us to define new metrics for query privacy from different
perspectives, which also facilitate users to flexibly and precisely express their privacy
requirement.

We took two types of contextual information to exemplify the application of
our framework. One application focuses on user profiles while the other one is
further extended with contextual information—query dependency, which has not
been investigated in the literature. To protect query privacy we have designed
new spatial generalisation algorithms to generalise requests which can satisfy users’
privacy requirements in various metrics.

Through experiments, we have shown (1) our framework is effective to increase
the correctness of the adversary’s guess on real issuers; (2) the newly identified
query dependency does cause privacy leakage about users’ queries; (3) the proposed
metrics are effective to protect users’ query privacy; and (4) the generalisation
algorithms are efficient.

For experiments, we made use of simulated datasets about users’ movements and
request traces due to the lack of real-life data with respect to LBSs. This causes some
difficulties for us to test the impact of time intervals between requests. As part of our
future work, we want to check whether we can collect and use users’ logs in Geo-
social networks in order to have a more comprehensive validation of our work.

References

1. Ariely D, Au WT, Bender RH, Budescu DV, Dietz CB, Gu H, Wallsten TS, Zauberman G
(2000) The effects of averaging subjective probability estimates between and within judges. J
Exp Psychol Appl 6:130–147

2. Bellavista P, Küpper A, Helal S (2008) Location-based services: back to the future. IEEE

Pervasive Comput 7(2):85–89

Cambridge

3. Beresford AR (2005) Location privacy in ubiquitous computing. PhD thesis, University of

4. Bettini C, Mascetti S, Wang XS, Freni D, Jajodia S (2009) Anonymity and historical k-anonymity
in location-based services. In: Privacy in location-based applications. Lecture Notes in Computer
Science, vol 5599. Springer, pp 1–30

130

Geoinformatica (2014) 18:95–133

5. Bolger F, Wright G (1993) Coherence and calibration in expert probability judgement. Omega

6. Brinkhoff T (2002) A framework for generating network-based moving objects. Geoinformatica

21(6):629–644

6(2):153–180

7. Chen X, Pang J (2012) Measuring query privacy in location-based services. In: Proc. 2nd
ACM conference on data and application security and privacy (CODASPY). ACM Press,
pp 49–60

8. Chen X, Pang J (2013) Exploring dependency for query privacy protection in location-based ser-
vices. In: Proc. 3rd ACM conference on data and application security and privacy (CODASPY).
ACM Press, pp 37–47

9. Chen X, Pang J, Xue R (2013) Constructing and comparing user mobility proﬁles for location-
based services. In: Proc. 28th ACM Symposium on Applied Computing (SAC). ACM Press,
pp 261–266

10. Cheng R, Zhang Y, Bertino E, Prabhakar S (2006) Preserving user location privacy in mobile
data management infrastructures. In: Proc. 6th international workshop on Privacy Enhancing
Technologies (PET). Lecture Notes in Computer Science, vol 4258. Springer, pp 393–412

11. Chow CY, Mokbel MF, Aref WG (2009) Casper(cid:12): query processing for location services without

compromising privacy. ACM Trans Database Syst 34(4):1–48

12. Devroye, L., Lugosi, G.: Combinatorial methods

in density

estimation. Springer

(2001)

13. Dewri R, Ray I, Ray I, Whitley D (2010) On the formation of historically k-anonymous
anonymity sets in a continuous LBS. In: Proc. 6th international conference on security and
privacy in communication networks (SecureComm). Lecture Notes in Computer Science, vol 50.
Springer, pp 71–88

14. Dewri, R., Ray, I., Ray, I., Whitley, D.: Query m-invariance: preventing query disclosures in
continuous location-based services. In: Proc. 11th international conference on Mobile Data
Management (MDM). IEEE Computer Society, pp 95–104 (2010)

15. Díaz C, Seys S, Claessens J, Preneel B (2003) Towards measuring anonymity. In: Proc. 2nd
international workshop on Privacy Enhancing Technologies (PET). Lecture Notes in Computer
Science, vol 2482. Springer, pp 54–68

16. Gedik B, Liu L (2008) Protecting location privacy with personalized k-anonymity: architecture

and algorithms. IEEE Trans Mob Comput 7(1):1–18

17. Ghinita G, Kalnis P, Khoshgozaran A, Shahabi C, Tan KL (2008) Private queries in location
based services: anonymizers are not necessary. In: Proc. the ACM SIGMOD international
conference on management of data. ACM Press, pp 121–132

18. Ghinita G, Kalnis P, Skiadopoulos S (2007) PRIVE: anonymous location-based queries in dis-
tributed mobile systems. In: Proc. 16th international conference on World Wide Web (WWW).
ACM Press, pp 371–380

19. Giannotti F, Nanni M, Pedreschi D, Pinelli F (2006) Mining sequences with temporal an-
notations. In: Proc. 21st ACM Symposium on Applied Computing (SAC). ACM Press,
pp 593–597

20. Giannotti F, Nanni M, Pedreschi D, Pinelli F, Axiak M (2007) Trajectory pattern mining. In:
Proc. 13th ACM SIGKDD international conference on Knowledge Discovery and Data Mining
(KDD). ACM Press, pp 330–339

21. González MC, Hidalgo CA, Barabási AL (2008)Understanding individual human mobility pat-

terns. Nature 453:779–782

22. Gruteser M, Grunwald D (2003) Anonymous usage of location-based services through spatial
and temporal cloaking. In: Proc. 1st international conference on Mobile Systems, applications,
and services (MobiSys). USENIX Association

23. Han J, Kamber M (2000) Data mining: concepts and techniques. Morgan Kaufmann
24. Hoh B, Gruteser M, Xiong H, Alrabady A (2007) Preserving privacy in GPS traces via
uncertainty-aware path cloaking. In: Proc. 14th ACM conference on Computer and Commu-
nications Security (CCS). ACM Press, pp 161–171

25. Jaynes ET (1957) Information theory and statistical mechanics. Phys Rev 106(4):620–630
26. Jaynes ET (1957) Information theory and statistical mechanics II. Phys Rev 108(2):171–190
27. Kalnis P, Ghinita G, Mouratidis K, Papadias D (2007) Preventing location-based identity infer-

ence in anonymous spatial queries. IEEE Trans Knowl Data Eng 19(12):1719–1733

Geoinformatica (2014) 18:95–133

131

28. Kido H, Yanagisawa Y, Satoh T (2005) Protection of location privacy using dummies for
location-based services. In: Proc. 21st International Conference on Data Engineering (ICDE).
IEEE Computer Society, pp 12–48

29. Li N, Li T, Venkatasubramanian S (2007) t-closeness: privacy beyond k-anonymity and l-
diversity. In: Proc. 23rd International Conference on Data Engineering (ICDE). IEEE Computer
Society, pp 106–115

30. Machanavajjhala A, Kifer D, Gehrke J, Venkitasubramaniam M (2007) (cid:2)-diversity: Privacy

beyond k-anonymity. ACM Trans Knowl Discov Data 1(1), Article 3

31. MacQueen JB (1967) Some methods for classiﬁcation and analysis of multivariate observations.
In: Proc. 5th Berkeley symposium on mathematical statistics and probability, vol 1. University of
California Press, pp 281–297

32. Manning C, Schuütze H (1999) Foundations of statistical natural language processing. Cambridge
33. Mascetti S, Bettini C, Freni D, Wang XS (2007) Spatial generalization algorithms for LBS privacy

preservation. J Location Based Services 1(3):179–207

34. Mokbel MF, Chow CY, Aref WG (2007) The new casper: a privacy-aware location-based
database server. In: Proc. 23rd International Conference on Data Engineering (ICDE). IEEE
Computer Society, pp 1499–1500

35. Rebollo-Monedero D, Parra-Arnau J, Díaz C, Forné J (2013) On the measurement of privacy as

an attacker’s estimation error. Int J Inf Secur 12(2):129–149

36. Reiter MK, Rubin AD (1998) Crowds: anonymity for web transactions. ACM Trans Inf Syst

Secur 1(1):66–92

37. Riboni D, Pareschi L, Bettini C (2008) Privacy in georeferenced context-aware services: a survey.
In: Proc. 1st international workshop on Privacy in Location-Based Applications (PiLBA). CEUR
Workshop Proceedings, vol 397. CEUR

38. Riboni D, Pareschi L, Bettini C, Jajodia S (2009) Preserving anonymity of recurrent location-
based queries. In: Proc. 16th international symposium on temporal representation and reasoning
(TIME). IEEE Computer Society, pp 62–69

39. Samarati P (2001) Protecting respondents’ identities in microdata release. IEEE Trans Knowl

Data Eng 13(6):1010–1027

40. Santos F, Humbert M, Shokri R, Hubaux JP (2011) Collaborative location privacy with ra-
tional users. In: Proc. 2nd international conference on decision and game theory for security
(GameSec). Lecture Notes in Computer Science, vol 7037. Springer, pp 163–181

41. Serjantov A, Danezis G (2003) Towards an information theoretic metric for anonymity. In:
Proc. 2nd international workshop on Privacy Enhancing Technologies (PET). Lecture Notes in
Computer Science, vol 2482. Springer, pp 41–53

42. Shin H, Atluri V, Vaidya J (2008) A proﬁle anonymization model for privacy in a personalized
location based service environment. In: Proc. 9th international conference on Mobile Data
Management (MDM). IEEE Computer Society, pp 73–80

43. Shin H, Atluri V, Vaidya J (2011) A proﬁle anonymization model for location-based services. J

Comput Secur 19(5):795–833

44. Shokri R, Theodorakopoulos G, Boudec JYL, Hubaux JP (2011) Quantifying location privacy.

In: Proc. 32nd IEEE symposium on Security and Privacy (S&P). IEEE Computer Society

45. Shokri R, Troncoso C, Díaz C, Freudiger J, Hubaux JP (2010) Unraveling an old cloak: k-
anonymity for location privacy. In: Proc. 2010 ACM Workshop on Privacy in the Electronic
Society (WPES). ACM Press, pp 115–118

46. Tan KW, Lin Y, Mouratidis K (2009) Spatial cloaking revisited: distinguishing information leak-
age from anonymity. In: Proc. 11th international Symposium on Spatial and Temporal Databases
(SSTD). Lecture Notes in Computer Science, vol 5644. Springer, pp 117–134

47. Xu T, Cai Y (2009) Feeling-based location privacy protection for location-based services. In:
Proc. 16th ACM conference on Computer and Communications Security (CCS). ACM Press,
pp 348–357

48. Xue M, Kalnis P, Pung HK (2009) Location diversity: enhanced privacy protection in location
based services. In: Proc. 4th international symposium on Location and Context Awareness
(LoCA). Lecture Notes in Computer Science, vol 5561. Springer, pp 70–87

49. Yiu ML, Jensen CS, Huang X, Lu H (2008) Spacetwist: managing the trade-offs among location
privacy, query performance, and query accuracy in mobile services. In: Proc. 24th International
Conference on Data Engineering (ICDE). IEEE Computer Society, pp 366–375

132

Geoinformatica (2014) 18:95–133

Xihui Chen a PhD student at University of Luxembourg within the Security and Trust of Software
Systems (http://satoss.uni.lu) research group under the supervision of Prof. Dr. Sjouke Mauw. He was
funded by the Luxembourgish national funding agency (FNR), in cooperation with a Luxembourgish
company (itrust) and the European Space Agency (ESA) since August 2010. His research project is
“Secure and Private Location Proofs: Architecture and Design for Location-based Services”.

Jun Pang is a senior researcher in the “Security and Trust of Software Systems” research group at
University of Luxembourg within the Computer Science and Communications Research Unit.

He received a PhD in Computer Science from Free University Amsterdam, based on his
research performed at CWI in Amsterdam as a junior researcher. Before joining the University of
Luxembourg in 2008, he was research assistant at the Computer Science Department of University
of Oldenburg in Germany, where he contributed to the DFG transregional collaborative research
center AVACS (Automatic Veriﬁcation and Analysis of Complex Systems) and developed theory,
techniques and tools for veriﬁcation of hybrid systems. Before Oldenburg, he was postdoctoral
researcher at the Comète project (Concurrency, Mobility and Transactions) of INRIA Futurs and
Ecole Polytechnique in France, where he studied quantitative aspects of computation including
semantics for timed and probabilistic process algebras and applied probabilistic concurrency theory
for the analysis of anonymity.

His research interests are mainly in formal methods and computer security, e.g., process algebra,
model checking, probabilistic systems, and formal veriﬁcation with a strong focus on application of
formal techniques to security and privacy in large and distributed systems. He has been working
on formalising security and privacy properties in different application domains such as electronic
voting, online auction and healthcare, and developing algorithms to support automatic veriﬁcation.
More recently, he is working on an ESA project on “Location Assurance Service Provider” and
supervising an FNR-AFR PhD project on “Secure and Private Location Proofs”. Within these two
projects, he starts to work on quantitative and statistical aspects of privacy in location-based services.

Geoinformatica (2014) 18:95–133

133

Dr Pang was and is member of many scientiﬁc committees (e.g., ICTAC’13, FHIES’13, TASE’13,
ACCESS’13, ICECCS’13, ICFEM’13, ATVA’12), and organized a number of conferences and
workshops (e.g., Luxembourg Day on Security and Reliability’09, SecCo’11, SAC-SVT’12, SAC-
SVT’13, ESSS’13). He has co-organized the international summer school “Veriﬁcation Technology,
Systems & Applications” since 2009. At the University of Luxembourg, he has supervised 11 Master
students and 3 PhD students. He has published more than 80 refereed publications in international
competitive conferences/workshops and prestige journals. His h-index is 17 according to citation
statistics by Google Scholar.

