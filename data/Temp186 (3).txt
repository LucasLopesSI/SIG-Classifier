This article was downloaded by: [Colorado College]
On: 08 October 2014, At: 17:44
Publisher: Taylor & Francis
Informa Ltd Registered in England and Wales Registered Number: 1072954 Registered
office: Mortimer House, 37-41 Mortimer Street, London W1T 3JH, UK

International Journal of Geographical
Information Science
Publication details, including instructions for authors and
subscription information:
http://www.tandfonline.com/loi/tgis20

Determining directional distances
between points and shorelines using
sweep line technique
Mika MurtojÄrvi a , Ville LeppÄnen a & Olli S. Nevalainen a
a Department of Information Technology and Turku Centre for
Computer Science (TUCS) , University of Turku , FI‐20014, Finland
Published online: 07 Oct 2010.

To cite this article: Mika MurtojÄrvi , Ville LeppÄnen & Olli S. Nevalainen (2009) Determining
directional distances between points and shorelines using sweep line technique, International
Journal of Geographical Information Science, 23:3, 355-368, DOI: 10.1080/13658810801909607

To link to this article:  http://dx.doi.org/10.1080/13658810801909607

PLEASE SCROLL DOWN FOR ARTICLE

Taylor & Francis makes every effort to ensure the accuracy of all the information (the
“Content”) contained in the publications on our platform. However, Taylor & Francis,
our agents, and our licensors make no representations or warranties whatsoever as to
the accuracy, completeness, or suitability for any purpose of the Content. Any opinions
and views expressed in this publication are the opinions and views of the authors,
and are not the views of or endorsed by Taylor & Francis. The accuracy of the Content
should not be relied upon and should be independently verified with primary sources
of information. Taylor and Francis shall not be liable for any losses, actions, claims,
proceedings, demands, costs, expenses, damages, and other liabilities whatsoever or
howsoever caused arising directly or indirectly in connection with, in relation to or arising
out of the use of the Content.

This article may be used for research, teaching, and private study purposes. Any
substantial or systematic reproduction, redistribution, reselling, loan, sub-licensing,
systematic supply, or distribution in any form to anyone is expressly forbidden. Terms &
Conditions of access and use can be found at http://www.tandfonline.com/page/terms-
and-conditions

International Journal of Geographical Information Science
Vol. 23, No. 3, March 2009, 355–368

Research Article

Determining directional distances between points and shorelines using
sweep line technique

MIKA MURTOJA¨ RVI*, VILLE LEPPA¨ NEN and OLLI S. NEVALAINEN
Department of Information Technology and Turku Centre for Computer Science
(TUCS), University of Turku, FI-20014, Finland

(Received 19 October 2007; in final form 21 December 2007 )

Distances from points to closest shorelines in a given direction are used, for
example, in some models for estimating wave exposure. Such distances, also
called fetch lengths, can be determined using standard geographic information
systems. However, performance may be a problem if these distances are required
for a great number of study points. Two new algorithms for determining fetch
lengths for study points in the same directions are presented in this paper. It is
assumed that the two-dimensional map is stored in vector format, i.e. shorelines
of islands and mainland are stored as polygons. The first algorithm works on a
set of undirected line segments derived from the shoreline polygons. The other
works on a raster representation of the map. The algorithm saves memory by
postponing the rasterisation until necessary. Both of the new algorithms have
superior efficiency to a previously reported algorithm when the number of study
points is large.

Keywords: Computational geometry; Fetch length; Efficient algorithms;
Digitised maps 2000 Mathematics Subject Classifications: 68U05; 68W01; 68W40

1.

Introduction

Distances from points to closest shorelines are needed in some applications using
digitised maps. For example, in environmental research such quantities are required
in models for estimating wave exposure or for quantifying general openness of study
points (Anon. 1984). Despite the shortcomings of these models, such as not taking
refraction and diffraction into account, they have recently been applied in wave
exposure calculations (Ekebom et al. 2003, Tolvanen and Suominen 2005). A central
concept in these models is fetch length, which stands for the distance from a point to
the nearest land area in a given direction. The concept of fetch length is illustrated in
figure 1, where the map is represented as a set of polygons. In the example of
figure 2, fetch lengths are shown for 3 study points on a water area in 48 directions.
The maps are considered two-dimensional, i.e. no depth or height information is
used. Neither is it taken into account that the maps are actually projections of the
nearly spherical surface of the Earth.

Fetch lengths can be determined using standard geographic information system
(GIS) software. However, if they are required for a large number of study points in
several directions, the standard tools may be too slow. In Ekebom et al. (2003),

*Corresponding author. Email: mika.murtojarvi@utu.fi; Tel: + 358-2-333 8658; fax:

+ 358-2333 8600

International Journal of Geographical Information Science
ISSN 1365-8816 print/ISSN 1362-3087 online # 2009 Taylor & Francis
http://www.tandf.co.uk/journals
DOI: 10.1080/13658810801909607

Downloaded by [Colorado College] at 17:44 08 October 2014 356

M. Murtoja¨rvi et al.

calculating the fetch lengths for 441 study points in 48 directions required one day
when using a map of the Finnish archipelago and ArcView version 3.2 (ESRI#)
software. Although the specifications of the computer used in (Ekebom et al. 2003)
are not known, the running time suggests that the method is best suited for a
relatively small number of study points.

Determining fetch lengths for a greater number of study points is a rather
specialised problem, and little attention has been paid to developing efficient
algorithms for this task. In the algorithm by Murtoja¨ rvi et al. (2007), the coordinate
system is rotated so that the fetch lines determined during one pass of the algorithm
are horizontal. For each study point s, the algorithm uses an interval tree (Cormen
et al. 2001) to find all line segments of the coastal lines intersecting the horizontal
line passing through s. The fetch length for s in the desired direction is the smallest
distance from s to such an intersection that lies to the right of s. The algorithm has
been used for determining fetch lengths for more than 10 million study points in 48
directions using a map that contained 3.7 million vertices (Kalliola and Suominen
2007). While the algorithm performs well in practice, it suffers from a theoretically
weak worst case performance. One can construct a map with n vertices and a set of
m study points such that the number of intersections between the lines passing
through the study points and the line segments of the map is m:n (for an illustration,
see figure 2 in Murtoja¨ rvi et al. 2007). This result applies when the fetch lengths are
determined in one direction, but the worst-case time complexity of the algorithm is
poor for any fixed number of fetch line directions.

In the raster-based algorithm by Finlayson (2004), raster grid squares (cells)
whose associated values are greater than zero represent land area and other cells
stand for water area. The fetch lengths are determined for all cells that are in the
water area. The algorithm first rotates the map in raster format so that the fetch
lines are vertical. The fetch lengths in one direction are then determined using an
is essentially a raster-based sweep line algorithm with some
approach that
postprocessing steps.

Figure 1. Fetch lengths in the direction p/4 for m54 study points A, B, C and D. For B and
D the fetch length is zero, because the immediate vicinities of the points in the specified
direction are inside a polygon.

Downloaded by [Colorado College] at 17:44 08 October 2014 Determining directional distances

357

Figure 2. Fetch lengths for three study points in 48 directions.

The fetch length problem can also be solved by transforming it into a line segment
intersection problem (or red/blue line segment intersection problem), and using
standard algorithms like those by Balaban (1995) or Mairson and Stolfi (1988). For
a survey of algorithms for line segment intersection problems, see Andrews et al.
(1994). The worst-case time complexity of such an approach is poor, and the worst
case occurs in a similar situation as in the algorithm by Murtoja¨ rvi et al. (2007). The
fetch length problem considered in this paper is, however, simpler than the general
line segment intersection problem. In particular, the fetch lengths are determined in
the same directions for all study points and only one intersection (the closest one)
needs to be determined for each study point and fetch line direction. These
observations suggest that it is possible to develop a more efficient algorithm than the
general line segment intersection algorithms.

2. A vector-based algorithm

If an algorithm for finding the intersections of line segments or the algorithm by
Murtoja¨ rvi et al. (2007) is applied to the fetch length problem, the computation time
is bounded from below by the number of intersections between the lines passing
through the m study points and the n line segments in the map. As discussed earlier,
in the worst case this number is m:n for a direction h. While the worst case is unlikely
in practice, there are usually still several intersections for each study point and
direction. Fetch lengths can be computed faster by determining only one intersection
for each study point in one direction.

Downloaded by [Colorado College] at 17:44 08 October 2014 358

2.1 Method

M. Murtoja¨rvi et al.

Our algorithm (vector_fetch)
is based on the sweep line technique
described, e.g. in Preparata and Shamos (1988) and de Berg et al. (2000). Here,
an imaginary line is moved in some direction, in our case a horizontal sweep line is
moved upwards starting below all the objects (the line segments and the study
points) in the input data. As the line meets parts of the objects, a data structure
called sweep line status is modified to reflect how the sweep line intersects the
objects. The status structure is updated at certain points, called the event points. In
vector_fetch the event points are the end points of the line segments.
Another kind of event points are the study points which involve computing output
data but not modifying the status structure. When all the event points have been
handled, the algorithm has computed the required output data.

Algorithm vector_fetch has some similarities to the well-known line
segment intersection algorithm by Bentley and Ottmann (1979) and to the line
segment intersection detection algorithm by Shamos and Hoey (1976). The main
similarity is that the line segments intersected by the sweep line are ordered
according to the x-coordinates of the intersections of the sweep line and the line
segments. By this property, the closest line segment to the left of a given point can be
found efficiently. Because the line segments do not cross each other in a map, the
only event points originating from the map data are the end points of the line
segments. The algorithm is described here assuming that the fetch lengths are
determined in one horizontal direction: to the left of the study points. Fetch lengths
can easily be determined in other directions h by rotating the coordinate system by
h2p radians. The input of the algorithm consists of the set S~ s1,s2, . . . ,sm
g of
study points and the set E~ e1,e2, . . . ,en
g of undirected line segments describing the
polygon boundaries of land areas (i.e. the island polygons). To allow operations
such as sorting, these sets are represented by lists.

f

f

The sweep line status data structure contains the line segments intersected by the
sweep line (figure 3). When the next event point to be handled is an end point of a
line segment e, the status structure is updated by either adding or removing e,

Figure 3. Sweep line status consists of those line segments that intersect the current sweep
line. The sweep line is marked by a dashed line. Note that there are two corner points that are
intersected by the sweep line. When such a corner point has not yet been processed, the line
segment below the corner point is in the status structure. After processing the corner point the
line segment above it is in the status structure.

Downloaded by [Colorado College] at 17:44 08 October 2014 Determining directional distances

359

depending on whether the point in question is a lower or an upper end point.
When the next point is a study point, a fetch length is determined in a horizontal
direction. This includes two basic steps, determining whether the study point s is
inside a polygon and finding the shortest horizontal distance from s to a line
segment e[E.

Because the line segments in the status structure are ordered by x-coordinates, the
closest line segment to the left of s can be found efficiently. We call this line segment
the predecessor of s. Determining whether s is an interior point can be done by
counting the number of line segments that lie to the left of s (Preparata and Shamos
1988). This number is the same as the ordinal number (rank) of the predecessor line
segment of s in the sweep line status. An odd number indicates that s is an interior
point or a border point whose immediate vicinity on the half line is inside a polygon.
Keeping the line segments of the sweep line status ordered by x-coordinates and
finding their ranks can be done efficiently, if the sweep line status is represented by
an order-statistic tree (Cormen et al. 2001). An order-statistic tree is a balanced
binary search tree, thus having height O(log n) for n objects. Each node of the tree
stores the size of its subtree. The predecessor of a study point and the rank of any
element in the tree can be found in O(log n) time. The operations that modify the
tree also require O(log n) time.

A special case occurs when a study point s lies on the same horizontal line as an
end point of a line segment. Then, for finding the closest line segment one must take
into account all the line segments that cross or have an end point on this horizontal
line. To determine whether s is inside a polygon one must consider, in addition to
the line segments that cross the sweep line, either the line segments whose upper end
point lies on the sweep line or the ones whose lower end point lies on the sweep line,
but not both (Preparata and Shamos 1988). Other special cases are horizontal line
segments. These do not affect the horizontal fetch lengths and need not be stored in
the status structure.

The pseudocode of vector_fetch is given below in a somewhat simplified
form. In practice, because of the possibility of rounding errors, it may be preferable to
consider a point to lie on a line segment whenever its distance to the line segment is
below a given limit. If the fetch lengths are required in two opposite directions, one
might also speed up the algorithm by handling both of these directions in the same pass.

Algorithm vector_fetch. The algorithm determines the fetch lengths L(s, h), sgS for
a list S of study points in the direction h. List E contains the line segments of the
polygons in the map. The order-statistic tree method ‘rank’ gives the ordinal number
of the specified object in the tree, ‘predecessor’ returns the closest line segment that
lies to the left of the given point, and ‘dist’ determines the horizontal distance from a
point to a line segment. The list ‘endpoints’ contains objects that represent the end
points of the line segments. An object in this list also contains the line segment
object associated with the end point. A line segment object contains both end points
of a line segment.

Procedure vector_fetch (S: list of points, E: list of line segments, h: real
number):
begin

rotate all coordinates by h2p radians;
endpoints r end points of segments in E, together with line segment objects;
sort S and endpoints according to y-coordinates;

Downloaded by [Colorado College] at 17:44 08 October 2014 360

M. Murtoja¨rvi et al.

T r an empty order-statistic tree; // the sweep line status
while not all points of S have been processed do

s r the next point of S; p r the next point of endpoints;
if (p.y,s.y) then // the point to process is an end point, update T

remove segments ending at p from T;
add segments starting from p to T;
step back by one element in S; // no element from S was processed

elseif (s.y,p.y) then // the point to process is a study point

eleft r T.predecessor(s); nleft r T.rank(eleft);
if nleft is even then L(s, h ) r dist(s, eleft) else L(s, h ) r 0;
step back by one element in endpoints; // no end point was processed

else // the next study point and end point have the same y-coordinate

proc_once r a new empty list; // the study points need to be handled twice
// find fetch lengths not taking into account the line segments that
// start at the sweep line
s’ r s; p’ r p;
while s’ exists and s’.y5s.y do

determine L(s’, h ) for s’ in the same way as in the case where s.y,p.y;
add s’ to proc_once; s’ r the next point of S;

endwhile
// step back in S so that the next element in S will be the first
// above the sweep line
if s’ exists then step back by one element in S;
while p’ exists and p’.y5s.y do

remove segments ending at p’ from T;
add segments starting from p’ to T;
p’ r the next point in endpoints;

endwhile
if p’ exists then step back by one element in endpoints;
// now the line segments that start at the sweep line are in T
for all study points s’ in proc_once do // update the fetch lengths if necessary

eleft r T.predecessor(s’); L(s’, h ) r min{ L(s’, h ), dist(s’, eleft)};

endfor

endif
endwhile

end

Although not stated in the pseudocode, the fetch length is defined to be infinite if
the study point s does not have a predecessor. Thus, if all end points have been
processed when there are still study points to process, the fetch lengths for the
remaining study points will be infinite. On the other hand, the end points that are
above all
the study points need not be considered. The corresponding line
segments are either above the study points (if both end points are above all
study points), or they are in the status structure when needed because the lower
end point has been processed. Several study points on a horizontal line are also
handled correctly: If there are no end points on this horizontal line, the fetch
lengths for these study points will be determined during consecutive iterations of the
outer while-loop. If there is at least one end point on this horizontal line, the fetch
lengths of all these study points will be determined in one iteration of the outer
while-loop.

Downloaded by [Colorado College] at 17:44 08 October 2014 Determining directional distances

361

2.2 Time complexity

The lists of m study points and n end points of the line segments can be sorted in
O(m log m) and O(n log n) time, respectively, using generic sorting algorithms. In a
practical setting, sorting the two lists is possible even in linear, i.e. O(m + n), total
time using radix sort, if the coordinates are represented by fixed-precision floating
point numbers (see Cormen et al. 2001 and Terdiman 2000). The rotation step
requires O(m + n) time. Processing a study point or an end point requires O(log n)
time and the algorithm requires thus, in addition to sorting, O((m + n)log n) time.
The worst-case time complexity of the algorithm is then O(m log m + n log n) using a
generic sorting algorithm and O((m + n)log n) using radix sort. If the number of
study points is small, e.g. m5O(log n), the algorithm is not efficient compared to a
simple algorithm that finds the intersections between the m half lines originating
from the study points and the n line segments in O m:n
Þ time by testing all pairs of
line segments and half lines.

ð

3. A raster-based algorithm

In the raster-based algorithm (raster_fetch) each study point is processed
in O(1) time but a loss of precision due to rasterisation must then be accepted. One
reason for the inaccuracy is that a raster cell stands for an area in a map, and
distances are calculated between the centres of raster cells. The actual running time
also depends on the required accuracy and the total length of the coastal lines. Like
the vector-based algorithm, raster_fetch is based on the sweep line
technique. The coordinates of the study points are converted to integers and line
segments are converted into sets of raster points with integer coordinates. The map
can then be visualised as a grid of squares, also called cells (figure 4). A cell is said to
be nonempty if it contains a part of a line segment.

A map in raster format can require a lot of storage space. If, for example, an area
of 1000 km61000 km is rasterised using 25 m accuracy, there will be 1.66109 fixed-
size cells. In our algorithm the sweep line status is the only data structure that needs
map data in raster form, and it only contains for each rasterised value of the
horizontal (x) coordinate one value of rasterised vertical (y) coordinate. This is
the greatest y-coordinate of a nonempty cell below the sweep line with the specified

Figure 4. A part of the map shown in figure 2 rasterised using 10 m accuracy. The
rasterisation algorithm used here is different from the one used in the raster-based fetch line
algorithm.

Downloaded by [Colorado College] at 17:44 08 October 2014 362

M. Murtoja¨rvi et al.

the sweep line is horizontal

x-coordinate. Like in vector_fetch,
in
raster_fetch, and it moves upwards. However, it turned out easier and
more efficient to determine fetch lengths in a direction perpendicular to the sweep
line in the raster algorithm. Therefore raster_fetch determines fetch lengths
in vertical direction in the rotated coordinate system. To be able to make the required
modifications to the status structure during the execution of the algorithm, a list of
line segments currently intersecting the sweep line is maintained. The end points of
these line segments are stored in full precision to allow accurate rasterisation.

The steps for determining fetch lengths are similar to those in vector_
fetch. One step is determining whether or not a cell containing a study point is
inside a polygon. This information is called the label of the cell, and it may be either
‘exterior’ (the cell is not inside any island) or ‘interior’ (the cell is inside an island).
The other step is determining the distance to the closest nonempty cell in vertical
direction. Algorithms for labelling the cells are known (Zˇ alik and Kolingerova 2001,
Gombosˇi and Zˇ alik 2005), but they are not directly applicable because we want to
avoid storing the whole map in raster form. The main idea of our method is to use a
reference point inside the cell for labelling.

Before discussing the method, let us elaborate on the difference between a cell and
a point. A cell is specified by two integer coordinates, and it corresponds to a square-
shaped area in a map. In the algorithm the coordinates are scaled and the origin is
shifted so that all cells have integer x-coordinates in the range 0,1,…,X and y-
coordinates in the range 0,1,…,Y. A point, on the other hand, has no dimensions
and corresponds to an exact location on a map. The coordinates of a point are real
numbers in the ranges [0, X + 1) and [0, Y + 1). There is a correspondence between
the coordinates of a point and those of a cell: A point (x, y) is inside the cell (xR, yR)
if xR(x,xR + 1 and yR(y,yR + 1. The letter R stands for ‘rasterised’, and it
indicates that the quantity involved is an integer. Note that, for example, the point
(xR, yR) is the lower left corner of the cell (xR, yR).

Now, let us consider the somewhat tricky labelling of a cell (xR, yR). We do this by
using a reference point inside the cell. Intuitively the most appealing selection is to
use the middle point (xR + 1/2, yR + 1/2) for this purpose. However, when there are
no parts of line segments inside the cell, any point inside the cell can be used. If there
are parts of line segments inside the cell, some parts of the cell are inside an island
and some parts are not. A label and a raster representation of the map are then not
sufficient for reliably classifying all points inside this cell. Hence, the choice of the
point used for labelling the cell is irrelevant, and we choose to use the point (xR + 1/2,
yR) for labelling the cell (xR, yR).

The labels of the cells are a part of the sweep line status, and they are initially set
to ‘exterior’. Now, consider the situation shown in figure 5, where the cells with y-
coordinate less than or equal to yR have already been labelled, and the parts of the
line segments with unrasterised y-coordinates in the range [yR, yR + 1) are being
rasterised. The label of a point p5(xR + 1/2, yR + 1) (or, equivalently, the cell c5(xR,
yR + 1)) is the same as that of p95(xR + 1/2, yR) (or the cell c95(xR, yR)), if there is an
even number of intersections between the line segment from p to p’ and the line
segments of the map. It is then possible to label the cells while rasterising the line
segments. In figure 5, rasterising a line segment produces, among others, a cell
c95(xR, yR), and the horizontal coordinates of the end points of the part of this line
segment with vertical coordinates in the range [yR, yR + 1] are xleft and xright. If xleft is
strictly less than xR + 1/2 and xright is at least xR + 1/2, the label of the cell c is

Downloaded by [Colorado College] at 17:44 08 October 2014 Determining directional distances

363

Figure 5. Rasterising a part of line segment l and determining the label of cell c5[xR, yR + 1].
When considering the rasterised y-coordinate yR, the cells shown in bold result from
rasterising l. Point p is used for labelling the whole cell c, i.e. for determining whether c is an
interior or exterior cell. The label of p is determined by considering the label of p’ and the
number of intersections between the line segment from p to p’ and the line segments of the
map.

switched from ‘exterior’ to ‘interior’ (or vice versa). If several line segments produce
the same rasterised cell, the same procedure is repeated for all the line segments.
After all of them have been processed, the point p has the correct label, which is
assigned to the whole cell c. The algorithm only needs the labels of the cells stored in
the sweep line status, i.e. only X + 1 labels need to be stored in memory.

3.1 Algorithm raster_fetch

Three main data sets are used by the algorithm.

1. The study points and lower end points of the line segments are stored in two
arrays of lists, s_points and e_points, respectively, depending on the rasterised
y-coordinates of the points. Both of these arrays contain Y + 1 lists. The order
of the points in the x-direction is not relevant in determining fetch lengths.
New elements can therefore be added to these two arrays of lists in constant
time. The lists in s_points and e_points are processed in an increasing order of
rasterised y-coordinates (given by the variable index).

2. The sweep line status is expressed by two arrays of X + 1 elements, last_y and
label. Each element last_y[xR] contains the y-coordinate of a nonempty cell
whose x-coordinate is xR and y-coordinate is maximal of those with position
xR below the sweep line. The element label[xR] is the status (‘interior’ or
‘exterior’) of the cell (xR, last_y[xR]).

3. The sweep line status is maintained using the information in the list
active_lines. When a lower end point of a line segment is encountered (while
processing a nonempty list e_points[index]), the line segment is added to
active_lines. When considering the rasterised y-coordinate index, the parts of
all the active lines within the row of cells with y-coordinate index are
rasterised. Rasterising this part of an active line (the unrasterised y-
coordinates are in the range [index, index + 1]) produces a consecutive range
xA,…,xA + D of rasterised x-coordinates (in figure 5 the five cells resulting
from rasterising one such part of a line segment are shown in bold). The values
xleft and xright are determined analytically from the equation of the line

Downloaded by [Colorado College] at 17:44 08 October 2014 364

M. Murtoja¨rvi et al.

segment, and xA is the rasterised value of xleft and xA + D is the rasterised value
of xright. For each xR in this range, last_y[xR] is set to yR and label[xR] is
modified as described earlier. If the y-coordinate of the upper end point of an
active line segment is in the range [index,
index + 1], the line segment is
removed from active_lines. The border points could be detected by rasterising
the parts of line segments within the row of cells with rasterised y-coordinate
index before determining the fetch lengths for the study points in this row of
cells; if the vertical distance s.y-last_y[s.x] is zero, s is in a border cell.

Algorithm raster_fetch. The algorithm determines for a list S of study
points the fetch lengths L(s, h), sgS in direction h. List E contains the line segments
of the map in vector form. Fetch lengths are determined in a direction perpendicular
to the sweep line (the direction of the fetch lines is downwards from the study points,
opposite to the direction in which the sweep line moves). Therefore the original
coordinates are rotated by h + p/2. Variable scale gives the side length of the cells.
Procedure ‘rasterise_line’ updates, given a line segment line, the sweep line status, i.e.
the arrays last_y and label. In addition, the procedure removes line from active_lines
if its upper end point has rasterised y-coordinate index.

Procedure raster_fetch (S: list of points, E: list of line segments, h: real
number, scale: real number):

begin

rotate all coordinates by h + p/2 radians;
determine the smallest x- and y-coordinates xmin and ymin in the map (list E);
determine the maximum rasterised coordinates X and Y in the map (list E);
let s_points and v_points be arrays of Y + 1 empty lists of study points and end
points;
store points of S and lower end points of E in proper lists of s_points and
v_points;
// together with an end point, store the line segment whose lower point it is
last_y r an array of X + 1 initial values (2‘); // sweep line status
label r an array of X + 1 initial values (‘exterior’); // sweep line status
for index r 0 to Y do

for each study point s in s_points[index] do
if label[s.x]5‘interior’ then L(s, h) r0;
elseif last_y[s.x]52‘ then // The real fetch length is unknown

L(s, h) r‘;

else // The study point is an exterior point and the fetch length is known

L(s, h) r scale?(s.y-last_y[s.x]);

endif
endfor
for all end points p_lower in v_points[index] do // Add new active lines

add the line segment stored in p_lower to the list active_lines;

endfor
for all line segments line in active_lines do

rasterise_line(line, index, active_lines, last_y, label, scale, xmin, ymin);

endfor

endfor

end

Downloaded by [Colorado College] at 17:44 08 October 2014 Determining directional distances

365

Figure 6. An example of inconsistent classification of a study point in raster_fetch. When
the sweep line is horizontal, the study point is classified as an interior point, but in the rotated
direction it is in the same square as a part of the borderline and is classified as an exterior
point.

One can expect that the algorithm may produce inaccurate results for study points
near a border of an island. In the rasterised form it is not possible to say whether a
study point s that lies in the same cell as a part of a borderline is inside an island,
outside the islands or on the border of an island. It is even possible that s is classified
as an interior point in some direction, but as an exterior point in some other
direction (figure 6). This limits the usefulness of the algorithm, but it is easy to detect
the questionable results by modifying the algorithm. One may also note that the
labels of the cells are initialised as ‘exterior’ which corresponds to assuming that the
border of the map represents sea area. This is not as serious a restriction as it seems,
because the map can be completed so that the parts of the map border that are in
land area are bounded by line segments. The algorithm then immediately switches
the label to ‘interior’ when this border is crossed.

3.2 Time and space complexity

ð

The algorithm raster_fetch processes a study point in O(1) time. This time
includes rasterising the point, storing it in the array of lists s_points and determining
a fetch length for it. Storing (retrieving) an end point to (from) the array of lists
e_points also requires O(1) time per end point. Rasterising a line segment requires
O(1) time per produced cell. For a line segment with length l, the number of
resulting cells is of the order O ql=scaler
Þ. The time required for creating the 2(Y + 1)
arrays of lists, s_points and e_points, is not significant unless the number of study
points is small and the map data consist of a few short line segments that are far
from each other in the vertical direction. In such a case the initialisation time could
be greater than the running time of the rest of the algorithm. Similarly, the time for
initialising the sweep line status arrays, which contain X + 1 elements,
is not
significant in practice. Thus, the worst-case time complexity of the algorithm,
O(m + n + X + Y + ltot/scale), reduces to O(m + n + ltot/scale) in a practical setting. In
these formulae m stands for the number of study points, n the number of end points,
ltot the total length of coastal lines, and the side length of cells is scale.

Downloaded by [Colorado College] at 17:44 08 October 2014 366

M. Murtoja¨rvi et al.

As to the space complexity, each of the n line segments is stored with exactly one
end point in one of the lists e_points. In the worst case all these line segments are also
stored simultaneously in the list active_lines. Each of the m study points is stored in
exactly one of the lists s_points. There are Y + 1 lists of study points and end points,
and the two sweep line status structures contain X + 1 elements. The space
complexity of the algorithm is thus O(m + n + X + Y).

4. Performance testing

The new algorithms were implemented in Java (Sun Java SDK 1.5.0) on a 1.92 GHz
AMD Athlon computer with 1 GB RAM. There were some differences between the
implementation and the pseudocode of vector_fetch. In particular, the
algorithm determined the fetch lengths in two opposite directions in one pass.
Further, instead of storing the rotated coordinates in memory, the cosine and sine of
the rotation angle were stored, and the rotated coordinates were calculated on-line
when required. This had a negligible (negative) impact on performance, although
some coordinates were rotated several times.

As test material we had a map of a portion of the Finnish archipelago. The map
contained 1277 islands with a total of 53,301 vertices. The total length of the coastal
lines was 973,778.1 m, and the area covered by the map was ca. 30 km620 km. The
map did not contain the coastal line of the mainland. For testing the algorithms with
a greater number of vertices (end points of line segments), semi-artificial map data
were created by tiling copies of the original map next to each other. The study points
were located randomly on the map and their number was varied so that the
performance of the algorithms could be compared in different situations. The
performance tests were also run for the algorithm by Murtoja¨ rvi et al. (2007).
The sizes of the test cases were selected so that the algorithms could be run in main
memory. Our implementations were not very memory-economic in all respects, nor
did we attempt to fine-tune them for best possible performance. We only tested the
algorithms using 2 or 48 directions, because the performance of the algorithms
depends linearly on the number of required directions.

The results of the performance test are summarized in table 1. It can be seen that
the interval tree based algorithm IV by Murtoja¨ rvi et al. (2007) is the fastest when
the number of study points is small. Algorithm vector_fetch is efficient
already with a moderate number of study points. When the number of study points
is increased, the difference in the execution time compared to IV grows. Algorithm
raster_fetch is more efficient than vector_fetch with 10 m but not
with 2 m cell size, which was close to the length of the shortest line segment in the
map. The average length of the line segments was approximately 18 m. Overall, the
results show that vector_fetch is very efficient, and raster_fetch is
even faster when the required accuracy is not very high. One should note, however,
that there are faster rasterisation methods (e.g. Cleary and Wyvill 1988) than the
straightforward method used in our tests.

The tests also showed that study points near the border of an island were
problematic for raster_fetch. There were cases where the fetch lengths were
incorrectly found to be zero for some direction but nonzero for a direction that did
not differ very much from that direction. The results of these border points are
discarded, and they may be determined using another algorithm, e.g. by
vector_fetch or IV. When the study points were selected randomly, up
to 4% of them were in the same cell as an island border in at least one of the 48

Downloaded by [Colorado College] at 17:44 08 October 2014 Determining directional distances

367

Table 1. Performance of vector- (VF) and raster-based (RF) sweep line algorithms for
determining fetch lengths. Vertices gives the number of vertices in the map data, Study points
the number of Study points, and Angles the number of directions in which the fetch lengths
were determined. Column IV gives the running time (s) of the interval tree-based algorithm.
The cell sizes used with the raster algorithm were 2 m and 10 m. The smallest execution times
in each case are shown in bold.

Case

Vertices Study points Angles

IV (s)

VF (s)

RF 2m (s) RF 10m (s)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

53,301
53,301
53,301
213,204
213,204
213,204
852,816
852,816
852,816
1,918,836
1,918,836
1,918,836
3,411,264
3,411,264
3,411,264

10,000
50,000
200,000
10,000
50,000
200,000
10,000
100,000
500,000
50,000
500,000
3,000,000
50,000
500,000
3,000,000

48
48
48
48
48
48
48
48
48
2
2
2
2
2
2

10.2
30.4
102.9
27.8
69.9
212.0
100.5
290.6
1045.4
19.1
90.2
461.5
31.7
128.2
654.1

13.1
17.0
38.1
51.8
54.5
76.5
210.0
221.6
292.9
24.1
26.4
48.3
44.3
46.5
62.4

20.77
23.04
34.87
70.54
75.58
86.40
260.87
275.16
309.06
30.58
31.95
46.58
54.10
56.03
73.07

11.8
14.4
23.7
41.8
45.5
54.5
153.8
165.8
195.5
19.5
20.5
33.5
35.1
36.5
52.5

directions for cell size 10 m. With 2 m accuracy the same was true for 0.9% of the
points, only. We also tested the performance of a hybrid algorithm that first runs
raster_fetch and then vector_fetch for the study points near a
border. When there were 858,816 vertices and 3,000,000 study points, determining
the fetch lengths in 48 directions took 778 s using the hybrid approach and 905 s
using vector algorithm alone. This result confirms what could be expected from
table 1: the hybrid algorithm is only efficient when the number of study points is
very large. Storing the results would have required more memory than was
available, and hence this test was a simulation, where all steps of the actual
calculation were done, but the results were stored in main memory in only two
directions instead of all 48 directions.

5. Discussion

We presented two new algorithms for determining fetch lengths. The central idea in
them is that for determining the fetch length it is only necessary to determine the
distance to the line segment that is closest to the study point in the desired direction.
The coordinate system is rotated so that the fetch lines are parallel to the horizontal
(the vector algorithm) or vertical (the raster algorithm) axis of the coordinate
system. In the vector algorithm the line segments of the shorelines intersecting the
sweep line are kept in a sorted order, which enables us to quickly determine the
closest line segment to the left of a given point. In the raster algorithm the line
segments are converted into sets of raster points, and the sweep line is divided into
slots. Each slot contains the relevant information of the latest encountered cell
whose x-coordinate is the same as the index of the slot. Thus, determining the fetch
length for a study point does not require much more than a simple table lookup.

Algorithm raster_fetch has better theoretical time complexity than
vector_fetch, but in practice the difference was relatively small. This is in
part a result of the inefficient rasterisation method used in the implementation. The

Downloaded by [Colorado College] at 17:44 08 October 2014 368

Determining directional distances

most significant shortcoming of raster_fetch is, however, that it does not
handle study points near polygon borders consistently. Thus it should only be used
if the results are required for open-water areas or the results are required for a large
number of study points and another algorithm is available for determining the fetch
lengths for the border points. The raster algorithm is significantly easier to program
on a computer than the vector algorithm.

References
ANDREWS, D.S., SNOEYINK, J., BORITZ, J. and CHAN, T., 1994, Further comparison of
algorithms for geometric intersection problems. In Proceedings of the 6th International
Symposium on Spatial Data Handling, pp. 709–724. Available at: http://citeseer.
ist.psu.edu/andrews94further.html (accessed 12 June 2007).

ANON., 1984, Shore Protection Manual, 4th edn, vol. 1 (Washington, DC: U.S. Army Corps of

Engineers, Coastal Engineering Research Center).

BALABAN, I.J., 1995, An optimal algorithm for finding segment intersections. In Proceedings
of the 11th ACM Symposium on Computational Geometry (New York: ACM Press),
pp. 211–219.

BENTLEY, J.L. and OTTMANN, T.A., 1979, Algorithms for reporting and counting geometric

intersections. IEEE Transactions on Computers, C-28, pp. 643–647.

DE BERG M., VAN KREVELD, M., OVERMARS, M. and SCHWARZKOPF, O., 2000, Computational
geometry, algorithms and applications, 2nd edn (Berlin, Heidelberg: Springer-Verlag).
CLEARY, J. and WYVILL, G., 1988, Analysis of an algorithm for fast ray tracing using uniform

space subdivision. The Visual Computer, 4, pp. 65–83.

CORMEN, T., LEISERSON, C., RIVEST, R. and STEIN, C., 2001, Introduction to Algorithms, 2nd

edn (Cambridge, MA: The MIT Press).

EKEBOM, J., LAIHONEN, P. and SUOMINEN, T., 2003, A GIS-based step-wise procedure for
assessing physical exposure in fragmented archipelagos. Estuarine, Coastal and Shelf
Science, 57, pp. 887–898.

FINLAYSON, D., 2004, Puget Sound fetch, 2004. Available at: http://david.p.finlayson.
googlepages.com/pugetsoundfetch. Software available at: http://david.p.finlayson.
googlepages.com/UWWaves.zip (accessed 12 June 2007).

GOMBOSˇ I, M. and Zˇ

ALIK, B., 2005, Point-in-polygon tests for geometric buffers. Computers &

Geosciences, 31, pp. 1501–1512.

KALLIOLA, R. and SUOMINEN, T., 2007, Spatial modelling in coastal areas. Mapping of exposure,
sea surface temperature and shore occupation. UTU-LCC Publications, 13. Available at:
http://utu-lcc.utu.fi/publications/lcc_publications/ (accessed 12 October 2007).

MAIRSON, H.G. and STOLFI, J., 1988, Reporting and counting intersections between two sets
of line segments. Theoretical Foundations of Computer Graphics and CAD. NATO ASI
Series, F40, pp. 307–326 (Berlin: Springer-Verlag).

MURTOJA¨ RVI, M., SUOMINEN, T., TOLVANEN, H., LEPPA¨ NEN, V. and NEVALAINEN, O.S., 2007,
Quantifying distances from points to polygons—applications in determining fetch in
coastal environments. Computers & Geosciences, 33, pp. 843–852.

PREPARATA, F. and SHAMOS, M., 1988, Computational Geometry, An Introduction (New York:

Springer-Verlag).

SHAMOS, M.I. and HOEY, D., 1976, Geometric intersection problems. In Proceedings of the
17th Annual IEEE Symposium on Foundations of Computer Science (Washington DC:
IEEE Computer Society Press), pp. 208–215.

TERDIMAN, P.,

2000, Radix

sort

revisited. Available

at: http://codercorner.com/

RadixSortRevisited.htm (accessed 12 June 2007).

TOLVANEN, H. and SUOMINEN, T., 2005, Quantification of openness and wave activity in

archipelago environments. Estuarine, Coastal and Shelf Science, 64, pp. 436–446.

Zˇ

ALIK, B. and KOLINGEROVA, I., 2001, A cell-based point-in-polygon algorithm suitable for

large sets of points. Computers & Geosciences, 27, pp. 1135–1145.

Downloaded by [Colorado College] at 17:44 08 October 2014 