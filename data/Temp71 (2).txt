Geoinformatica (2008) 12:117–142
DOI 10.1007/s10707-007-0027-y

One Way Distance: For Shape Based Similarity Search
of Moving Object Trajectories

Bin Lin · Jianwen Su

Received: 26 June 2006 / Revised: 10 January 2007 /
Accepted: 14 March 2007 / Published online: 17 August 2007
© Springer Science + Business Media, LLC 2007

Abstract An interesting issue in moving object databases is to ﬁnd similar tra-
jectories of moving objects. Previous work on this topic focuses on movement
patterns (trajectories with time dimension) of moving objects, rather than spatial
shapes (trajectories without time dimension) of their trajectories. In this paper we
propose a simple and effective way to compare spatial shapes of moving object
trajectories. We introduce a new distance function based on “one way distance”
(OWD). Algorithms for evaluating OWD in both continuous (piece wise linear) and
discrete (grid representation) cases are developed. An index structure for OWD in
grid representation, which guarantees no false dismissals, is also given to improve
the efﬁciency of similarity search. Empirical studies show that OWD out-performs
existent methods not only in precision, but also in efﬁciency. And the results of OWD
in continuous case can be approximated by discrete case efﬁciently.

Keywords moving objects · trajectory · similarity search · one way distance · index

1 Introduction

Advances in wireless communications and ubiquitous computing technologies pro-
vide signiﬁcant stimuli for location dependent applications. The available hardware
for both collecting and storing data makes it more tempting than ever to obtain and
manage various types of data for applications. Among these data of general interest
are location information of “moving objects.” Indeed, global positioning systems

The preliminary version of this paper was published in ACMGIS 2005 (B. Lin and J. Su.
“Shapes based trajectory queries for moving objects,” pp. 21–30).

Department of Computer Science, University of California, Santa Barbara, USA
e-mail: linbin@cs.ucsb.edu

B. Lin (B) · J. Su

J. Su
e-mail: su@cs.ucsb.edu

118

Geoinformatica (2008) 12:117–142

(GPS) are now widely adopted in variety of applications. Navigation and positioning
are becoming more important and even critical in many cases. One interesting type
of applications requires ﬁnding “similar” trajectories of moving objects. For instance,
in many sports such as football and tennis, it is very useful for sports researchers to
ﬁgure out the movement patterns of top players by ﬁnding similar trajectories of
objects’ (players, balls) motions. By analyzing similar trajectories of animals, it is
possible to determine migration patterns of them. In a city trafﬁc monitoring system,
it is helpful to locate popular routes by comparing similarity between vehicles’
trajectories. This paper aims at similarity search for trajectories.

Similarity search is not a new topic and has been investigated in various context,
e.g., motion tracking in videos [10], [12], time series analysis [4], [5], [8], [9], [14],
[16], [17], and recently, trajectories, [6], [11], [13], [16], [18]–[20]. Partly due to the
difﬁculty in formalizing “similarity” and partly due to the diversity of applications,
known results are not satisfactory in many application contexts.

Consider an imaginary trafﬁc control application where commuters are tracked
and their daily trajectories are stored. The trajectories of a commuter can be aggre-
gated over a speciﬁc time interval (e.g. a month) to ﬁnd its typical shape. An interest-
ing problem is to analyze the aggregated trajectories to investigate the feasibility of a
new bus route. The goal is to ﬁnd how much beneﬁt commuters can get. In this case,
the similarity of the planned bus route and a commuter trajectory concerns more
about the shared segments or location proximity, rather than completely matching
the actual timed location sequences. In other words, speed and direction information
of trajectories are not critical, but “spatial shape” is. For example, in Fig. 1, trajectory
B is more similar to A than C, while C is more similar to D than B. Analogously if the
aggregated commuter trajectories are stored and compared, the similarity will also
focus on the spatial closeness. In fact, the time ordering of an aggregated location
sequence does not have much semantic meanings in this context.

In many applications, similarity of routes focus primarily on the closeness of the
physical positions of the routes, while detailed timing and speed information may
not be as important. This motivates the need for a new similarity notion based on
closeness of their spatial shapes. Compared with movement pattern similarity, spatial
shape similarity has the following characteristics:

• Time is not sensitive, and thus trajectories are represented without time

information.

• Trajectories can be of different length.
•
• When performing similarity comparison, the mapping between trajectories may

Similar trajectories must be spatially close to each other.

not be continuous and monotonic.

Known results in dealing with similarity are not well suited for dealing with
aggregated trajectory information. Similarity notion for motion tracking in videos are
typically invariant with respect to rotations and translations. In time series analysis,
trajectories are one dimensional and the time dimension is treated very differently;
it is not trivial to employ the techniques in the moving objects setting. In prior work
on similarity search of moving object trajectories, similarity notion takes the time
ordering into consideration.

Since existing algorithms focus on movement patterns of moving objects, they
cannot be directly applied to spatial shape similarity search problems. In this paper,

Geoinformatica (2008) 12:117–142

119

Fig. 1 Spatial similarity
of trajectories (the map
is obtained from
http://maps.google.com)

A
B
C
D

we propose a simple but effective similarity distance function and develop algorithms
based on this distance function for spatial shapes similarity search of moving object
trajectories. The major contributions of this paper are:
• We introduce a new similarity distance deﬁnition based on “one way distance”

(OWD, Section 3) of trajectories (continuous and discrete).

• We develop an efﬁcient algorithm for computing similarity distance between
trajectories in discrete case (grid representation), which achieves a O(mn)
complexity, where n is the length of a trajectory and m is the number of local
min points.

• An index structure, which guarantees no false dismissals, is also introduced to

enhance the performance of OWD algorithm.

The remainder of this paper is organized as follows. Section 2 discusses related
works. Section 3 deﬁnes trajectories, OWD distance in different representation, and
similarity search problem. Detailed algorithm description and analysis of OWD are
given in Section 4. An index structure for OWD is described in Section 5. Section 6
evaluates OWD by comparing it other algorithms. Section 7 concludes this paper.

2 Related work

Similarity search has been well studied in context of time series [4], [5], [8], [9], [14],
[16], [17]. Original similarity search algorithm is based on Euclidean distance, which
is sensitive to noise and cannot be performed on sequences with different length
and sampling rate. References [8] and [4] are dimensionality reduction methods
based on discrete fourier transformation (DFT) and discrete wavelet transformation

120

Geoinformatica (2008) 12:117–142

(DWT) respectively to improve search performance with approximation. Reference
[9] presents an indexing method called adaptive piecewise constant approximation
(APCA), which is also a dimensionality reduction technique for sequence matching
based on Euclidean distance. This technique uses constant-value segments to approx-
imate sequences and achieves better approximation quality [9]. [14] approximates
trajectories with Chebyshev polynomials (Chebyshev), and then compute distance
based on the polynomials. However, similar to Euclidean distance, these measures
also require that trajectories are of the same length.

Reference [17] introduces dynamic time warping (DTW) distance to make it pos-
sible compare sequences with different lengths, with and without time information.
DTW is a method that allows local stretch of sequences to minimize distance between
sequences. [16] gives an improved version of DTW, which ﬁlters out unpromising
sequences by using an index structure with segmentation and lower bounded distance
measure. Its indexing techniques are extended and utilized in our index structure
(see Section 5). A distance measure which is both metric and allowing time-shifting
is introduced in [5]. But all their algorithms require mapping between trajectories to
be continuous and monotonic.

Recently interests of similarity search also arise in trajectory comparison [1],
[2], [6], [10]–[13], [16], [18]–[20]. DTW has some variants for trajectories similarity
search [12], [18]. [12], [18] both present a representation of trajectories invariant
to rotation, shifting, and scaling. [11] utilizes distance between minimum bounding
rectangle to compute distance between two multidimensional sequences. But the
distance function can not avoid false dismissals. [20] shows an algorithm extended
from time series similarity search method which is based on Euclidean distance.
But this algorithm can only compare trajectories with the same lengths or with
the same time interval. [10] proposes a method which allows global stretch to
match sequences similar but in different scale. [6] introduces EDR (edit distance
on real sequence) distance function based on edit distance. But mapping between
trajectories in these two algorithms is still continuous and monotonic. [19] compares
sequences by extracting their longest common subsequences (LCSS). This method
removes the mapping continuity requirement and is more ﬂexible in similarity
comparison. But it still requires mapping between trajectories to be monotonic. In
[13] an aggregation method based on rasters is developed for both spatial and spatial-
temporal trajectories. But the method can only support aggregation queries, not
similarity search queries. [2] and [1] focus on computing distance between two curves
(trajectories) using Frechet distance. But the computational complexity is high.

Most of these algorithms focus on movement patterns of moving object trajec-
tories. As we discussed in Section 1, most techniques cannot be directly applied to
spatial shape similarity search. One exception is DTW technique, which is originally
introduced in sequences comparison [17]. But its complexity is quadratic and its
mapping requires continuity and monotonicity. Comprehensive comparison of DTW
and OWD will be presented in Section 5.

3 Trajectory similarity

In this section we ﬁrst introduce a detailed categorization of similarity search for
moving object trajectories. We then deﬁne two notions of a trajectory based on

Geoinformatica (2008) 12:117–142

121

“linear” and “grid” representations, and notions of similarity between a pair of
trajectories (in their respective representations) using “one way distance” (OWD)
from one trajectory to the other. A formulation of the similarity search problem for
trajectories is given in Section 3.4.

3.1 Classiﬁcation of similarity

In Section 1 we discussed two different categories of similarity for moving object
trajectories: motion based similarity and shape based similarity. This categorization is
made according to dimensions under consideration: spatio-temporal or spatial only.
Based on features of distance functions, similarity search of moving object trajec-
tories can also be categorized into ﬁve more groups: rotation and translation free,
order preserving, time preserving, distance preserving, and continuous mapping.

Some distance functions are rotation and translation free. That means when two
trajectories are compared, they can be rotated and translated in any way to minimize
the distance function. In motion analysis, functions with this feature are required to
measure similarity between different trajectories.

Order preserving means the mapping between two trajectories is monotonic in
distance computation. More precisely, for any two points x1 and x2 in trajectory T1
and their mapped points x(cid:2)
2 (respectively) in trajectory T2, if x1 appears before
x2 along the direction of T1, x(cid:2)
2 along the direction of
T2, and vice versa. Most existing algorithms use order preserving distance functions,
which will miss some similarities (e.g. the bus rout example in Section 1). OWD
eliminates this restriction and can capture such similarities.

1 should also appear before x(cid:2)

1 and x(cid:2)

Distance preserving and time preserving are stronger features than order pre-
serving. That is, distance preserving and time preserving algorithms must be order
preserving. In addition, using the same example in the previous paragraph, for
distance preserving algorithms, the distance between x1 and x2 along trajectory T1
must be equal to the distance between x(cid:2)
2 along T2; for time preserving
algorithms, the time interval between the time stamps of x1 and x2 must be equal
to the time interval between the time stamps of x(cid:2)

1 and x(cid:2)

1 and x(cid:2)
2.

Continuous mapping requires all points in both trajectories are mapped, and
the mapping is order preserving. Most existing algorithms use continuous mapping
functions, except LCSS [19], which allows some points left unmapped.

Figure 2 shows some similarity algorithms’ features, where “Motion” and “Shape”
mean motion based and shape based similarity, respectively; “R/T Free” means
rotation and translation free; “Order”, “Time”, and “Distance” mean order pre-
serving, time preserving, and distance preserving, respectively; “Continuous” means
continuous mapping.

As shown in the ﬁgure, OWD is free of all restriction and focuses on shape
based similarity search and consequently can capture the most different similarities.
Algorithms extended from time series similarity search (DFT, DWT, and APCA) are
all order preserving, time preserving and continuous mapping. EDR and Chebyshev
are also order preserving, time preserving and continuous mapping. DTW removes
the time preserving restriction. LCSS removes the continuous mapping restriction.

Figure 3 shows features of some similarity search applications. Here “Bus”
represents the bus route schedule application described in Section 1. “Motion”
means motion analysis (e.g. players’ arms and legs movements in games). “Animal” is

122

Geoinformatica (2008) 12:117–142

Algorithms Motion

Shape R/T Free Order

Time Distance

Continuous

OWD
DTW
LCSS
EDR
DFT
DWT
APCA
Chebyshev

N
Y
Y
Y
Y
Y
Y
Y

Y
Y
N
N
N
N
N
N

N
Y
N
Y
N
N
N
N

N
Y
Y
Y
Y
Y
Y
Y

N
N
N
N
Y
Y
Y
Y

N
N
N
N
N
N
N
Y

N
Y
N
Y
Y
Y
Y
Y

Fig. 2 Features of some current similarity search algorithms

animal tracking. The bus route schedule application is a typical shape based similarity
search example and has no restrictions. For motion analysis, it is motion based and
is rotation and translation free, order preserving, time preserving, and continuous.
Animal tracking is also a motion based example, while it only requires the order
preserving restriction.

3.2 Linear representation

In order to deﬁne similarity measure between trajectories, we need to formulate the
notion of a trajectory. Our focus is on spatial shapes of trajectories. Therefore, there
is no time information in a trajectory.

Since completely continuous location information of a trajectory is not always
available and the computation cost of such continuous data is likely high, in many
applications the (piecewise) linear representation is employed to solve the problems.
A linear representation is to approximate a trajectory using a sequence of line
segments.

A line segment is represented by a pair of points ( p, q), the length of a line segment

( p, q) is deﬁned as the Euclidean distance between the points p, q.

Deﬁnition 1 A (piece wise) linear (or PWL) trajectory is a sequence of points
( p1, p2, ..., pn), where each adjacent pair of points ( pi, pi+1) (1 (cid:2) i (cid:2) n − 1) is a line
segment in the trajectory. The length of a trajectory T, denoted as |T|, is the sum of
lengths of the line segments in it.

For convenience, we assume that trajectories have lengths > 0.
The distance from a point p to a trajectory T is deﬁned as:

Dpoint( p, T) = minq∈T DEuclid( p, q)

where DEuclid( p, q) denotes the Euclidean distance between points p and q.

Applications Motion

Shape R/T Free Order

Time Distance

Continuous

Bus
Motion
Animal

N
Y
Y

Y
N
N

N
Y
N

N
Y
Y

N
Y
N

N
N
N

N
Y
N

Fig. 3 Features of some applications

Geoinformatica (2008) 12:117–142

123

We now deﬁne the one way distance from a trajectory to another trajectory based

on Dpoint( p, T).

Deﬁnition 2 The one way distance (or OWD) from a trajectory T1 to another
trajectory T2 is deﬁned as the integral of the distance from points of T1 to trajectory
T2 divided by the length of T1:

Dowd(T1, T2) =

Dpoint( p, T2) dp

(cid:2)(cid:3)

1
|T1|

p∈T1

(cid:4)

The distance between two trajectories T1 and T2 is the average of their one-way

distances:

D(T1, T2) = 1
2

(Dowd(T1, T2) + Dowd(T2, T1))

Clearly Dowd(T1, T2) is not symmetric but D(T1, T2) is. Note that Dowd(T1, T2)
is the integral of shortest distances from points in T1 to T2. If T1 is a sub-trajectory
of T2, Dowd(T1, T2) is 0; if T1 is very close to a sub-trajectory of T2, Dowd(T1, T2)
is close to 0. In both of these cases, the opposite distance Dowd(T2, T1) can be very
large. That is, Dowd(T, Q) can be understood as “how much trajectory T is similar
to the query trajectory Q?” (Smaller values means more similarity). It is easy to see
that Dowd(T1, T2) can be used in sub-trajectory search. Furthermore, the algorithms
developed in this paper can be used in both similarity search and sub-trajectory
search.

3.3 Grid representation

As we will show in our experiments, the computation cost of distances between
piecewise linear represented trajectories is still high. Therefore, we need to have
discrete deﬁnition to achieve better performance with acceptable precision. In
this paper we consider grid representation to describe discrete trajectories. In the
remainder of this paper, our discussions focus on grid representation.

In a grid representation, the entire workspace is divided into equal-size grid cells,
and each grid cell is labeled according to its position in x and y dimensions. For
instance, the left-bottom grid cell is labeled as (1, 1) and the right-top grid cell is
labeled as (m, n), where m and n are total numbers of columns and rows, respectively.
Obviously all labels are integer numbers. Given a grid cell g = (i, j), i is called the x-
label of g (i.e. g.x) and j is the y-label (i.e. g.y).

We deﬁne the distance between two grid cells g1, g2 as follows:
(cid:5)

Dgrid(g1, g2) =

(g1.x − g2.x)2 + (g1.y − g2.y)2.

Based on Dgrid(g1, g2), a trajectory in grid representation can now be deﬁned.

Deﬁnition 3 A grid trajectory is a sequence of grid cells, T g = (g1, g2, ..., gn) such
that for each 1 (cid:2) i < n, gi and gi+1 are adjacent, i.e., Dgrid(gi, gi+1) = 1. The number
n in the trajectory T g shown above is called the length of T g, and denoted as |T g| = n.

124

Geoinformatica (2008) 12:117–142

The distance from a grid cell g to a grid trajectory T g is deﬁned as the shortest

distance from g to T g.

Dg

point

(g, T g) = ming(cid:2)∈T g Dgrid(g, g(cid:2)).

Similar to Deﬁnition 2, the one-way grid distance and the distance between grid

trajectories can be deﬁned as follows.

Deﬁnition 4 The one way distance in grid representation from one trajectory T g
another trajectory T g
2 is deﬁned as the sum of the distance from grid cells of T g
that of T g

2 divided by the length of T1.

1 to
1 to

Dg

owd

(T g
1

, T g
2

) = 1
|T g
1

|

(cid:2)(cid:6)

(cid:4)

Dg

point

( p, T g
2

)

.

p∈T g
1

The distance between two grid trajectories T g
(T g
2

) and Dg

, T g
1

, T g
2

(T g
1

).

owd

owd

Dg

1 and T g

2 is deﬁned as the average of

Dg(T g
1

, T g
2

Dg

owd

(T g
1

, T g
2

) + Dg

owd

(T g
2

, T g
1

)

(cid:7)

) = 1
2

(cid:8)

One important feature of grid representation is its insensitivity to noises. And
coarser grid leads to less sensitivity to noises. It is also quite clear that coarser grid
representation means less computation cost and accuracy. Therefore, the trade-off
between computation cost, accuracy, and sensitivity to noises can be achieved by
varying grid cell size in grid representation.

3.4 Similarity search

Based on the deﬁnitions provided in Sections 3.1 and 3.2, we can now measure
similarity with distance between trajectories. Therefore, similarity search problem
can be described as follows.

Similarity search problem Given a set of trajectories S = {T1, T2, . . . , Tn}, a query
trajectory Q, and a positive integer k, ﬁnd the k trajectories in S which have the smallest
distances to Q.

4 Distance computation

The similarity search problem stated in Section 3 can be addressed in two steps.
The ﬁrst step is to ﬁnd a similarity comparison algorithm to compute the similarity
(distance) between two trajectories. The second step is to ﬁnd an indexing structure
to speed up the search computation through a large number of trajectories.

The similarity comparison algorithms based on one-way distance (OWD) for
both PWL and grid representations are given in Sections 4.1 and 4.2, respectively.
Theoretical analysis of both algorithms is also given. In the next section we will focus
on the indexing problem for trajectories.

Geoinformatica (2008) 12:117–142

125

4.1 Linear (PWL) representation

The basic idea of this algorithm is to compute the OWD distance piece by piece. Since
a trajectory in PWL representation is composed of a sequence of segments. Given
a linear trajectory T = { p1, p2, ..., pn}, let LS(T) = {linesegment( pi, pi+1) | 1 (cid:2) i (cid:2)
n − 1} represent all line segments in T. Then the one way distance from a trajectory
T1 to another trajectory T2

Dowd(T1, T2) = 1
|T1|

(cid:9)(cid:6)

(Dowd(s, T2) · |s|)

s∈LS(T1)

(cid:10)

where |s| is the length of a line segment s.

1

In order to compute Dowd(s, T2), we view s as a function of t where t is a new
variable. Speciﬁcally, a line segment s = ( p1, p2) ( p1 and p2 are the endpoints of s)
can be represented as a function s(t) = p1 + ( p2 − p1)t, where t is in the range [0, 1].
So the OWD distance Dowd(s, T2) from s to T2 can be represented by a function
(cid:11)
f (t) and Dowd(s, T2) =
0 f (t) dt. The function f (t) is called the global min function
from s to T2. To compute f (t), it is necessary to examine each segment s(cid:2) ∈ T2,
compute the OWD distance function from s to s(cid:2). Then, f (t) can be obtained as the
lowest envelope of all these functions using plane-sweeping algorithms [7] and the
algorithms computing the intersections of curves [15].

Figure 4 shows an example of computing f (t). In this example trajectory T2
consists of three line segments s1, s2, s3 (in this order). The OWD distance functions
f1, f2, f3 from a line segment s to s1, s2, s3 (respectively) can be computed as follows.

f1(t) = 1 + 2t
(cid:12)

2 − 2t
√

f2(t) =

8t2 − 12t + 5

√

f3(t) =

8t2 − 12t + 5

(0 (cid:2) t (cid:2) 1)
(0 (cid:2) t (cid:2) 0.5)
(0.5 < t (cid:2) 1)
(0 (cid:2) t (cid:2) 1)

Fig. 4 An example of global
min function computation

(2,3)

s

(2,2)

s3

(2,1.5)

(4,2)

(0,1)

s1
(0.5,0)

(0,0)

s2

(2,0)

126

Fig. 5 The f (t) computation
of the example in Fig. 4

OWD distance
3

Geoinformatica (2008) 12:117–142

f1(t)

f3(t)

f2(t)

2

1

0

0

0.25

0.5

t

1

Using these functions, f (t) can be computed as

⎧
⎨

⎩

1 + 2t
2 − 2t
√

f (t) =

8t2 − 12t + 5

(0 (cid:2) t (cid:2) 0.25)
(0.25 < t (cid:2) 0.5)
(0.5 < t (cid:2) 1)

Figure 5 shows the computation of f (t). It is easy to see that f (t) is the lowest

envelope of functions f1(t), f2(t), and f3(t) in the range of [0, 1].

The detailed algorithm is shown in Algorithm 1. The outer “for” loop goes through
all segments in T1, and Lines 3 to 8 compute Dowd(s, T2). Line 5 computes the OWD
distance from a line segment s to another line segment s(cid:2). The global min function
f (t) from s to T2 is computed in Line 7 using the algorithms in [7], [15]. Line 10 gets
Dowd(T1, T2).

Algorithm 1 OwdPwl(T1, T2)
1: C ← 0
2: for each segment s = ( p1, p2) in T1 do
Initialize an empty function set F
3:
for each segment s(cid:2) = (q1, q2) in T2 do
4:
5:
6:
7:

Find the parameterized (with t) OWD function from s to s(cid:2), put it into F

end for
Compare all functions in F and compute the global min function f (t) from s
to T2
C ← C +

(cid:11)
0 f (t) dt × |s|

1

8:
9: end for
10: Return C/|T1|

Geoinformatica (2008) 12:117–142

127

The plane sweep algorithm in Line 7 requires O(n log n) time complexity [7].
It follows that Algorithm 1 has O(n2 log n) complexity, where n is the numbers of
segments in a trajectory.

4.2 Grid representation

As discussed in Section 4.1, the computation cost of trajectory similarity comparison
in the PWL representation is at least quadratic in terms of the number of segments.
As we are going to show in this section, this complexity can be improved. A key idea
is to ﬁnd “local min points” of grid cells. It turns out that local min points of a grid cell
can be effectively inferred from its neighbor’s. Based on local min points, we develop
an algorithm of “semi-quadratic” O(mn) complexity for grid trajectories, where n is
the length of a trajectory T1 and m is the average number of local min points of grid
cell. In this section we focus on the details of this similarity comparison algorithm for
grid representation of trajectories.

Before introducing the algorithm, it is necessary to mention that in the algorithm
the most time consuming part is the distance computation for two grids, which
accounts for up to 80% of CPU time in our experiments. So the number of calls of
the grid distance computation is the major metric when we analyze the complexity
of algorithms for grid representation.

The naive algorithm for OWD in grid representation requires computing the dis-
tance for all pairs of grids on different trajectories and has a O(n2) complexity, where
n is the length of a grid trajectory as deﬁned in Section 3. But some computation of
the distance between grids are not necessary. In this section we will show that a lower
complexity O(mn) can be achieved, where m is the number of local min points.

Before presenting the details of our algorithm, we ﬁrst introduce the concept of

Local Min Point.

Deﬁnition 5 (Local Min Point) Given a grid cell g and a trajectories T, a grid cell
g(cid:2) ∈ T is a local min point to g if D(g(cid:2)(cid:2), g) > D(g(cid:2), g) for each grid cell g(cid:2)(cid:2) in T adjacent
to g(cid:2).

In other words, local min points of a grid cell g are those grids whose distances
to g are shorter than those of their neighbors. Figure 6 displays an example of local
min points. g is a single grid cell and the grid cells marked with bold lines represent
a trajectory. g has three local min points in the trajectory: g1, g2, and g3. And among
the three local min points, g3 is the one whose distance to g is the shortest distance
from g to the trajectory.

owd

According to the deﬁnition of local min points, it is clear that to compute
(g, T2), it is only required to compute D(g, g(cid:2)) for all local min points g(cid:2) ∈ T2
Dg
of g. A better news is that in grid representation local min points can be inferred
without using the time consuming grid distance function. Algorithm 2 shows how
to determine among two adjacent grid cells g1, g2, which one is closer to g. Before
we explain this algorithm, it is necessary to establish the following easily veriﬁed
fact ﬁrst.

Lemma 1 For each pair of two adjacent grid cells g1, g2 on a trajectory, either g1.y =
g2.y and |g1.x − g2.x| = 1 or g1.x = g2.x and |g1.x − g2.x| = 1.

128

Fig. 6 Examples of local
min point

Geoinformatica (2008) 12:117–142

g3

g1

g

g2

According to Deﬁnition 3, given any two adjacent grid cells g1, g2 on a trajectory,
Dg(g1, g2) = 1 means that (g1.x − g2.x)2 + (g1.y − g2.y)2 = 1. Since the coordinates
must be integers, either g1.y = g2.y and |g1.x − g2.x| = 1 or g1.x = g2.x and |g1.x −
g2.x| = 1.

Therefore, given two adjacent grid cells g1, g2, either g1.y = g2.y or g1.x = g2.x.
Therefore, we only need to consider these two situations in Algorithm 2. When
g1.y = g2.y (Lines 1 to 7), it is only required to compare the distances on x-
dimension; when g1.x = g2.x (Lines 8 to 13), only the comparison on y-dimension
is necessary. The distance computation function is invoked in neither case.

Algorithm 2 Closer(g, g1, g2)

if |g1.x − g.x| < |g2.x − g.x| then

else

end if

return g1

return g2

1: if g1.y = g2.y then
2:
3:
4:
5:
6:
7: end if
8: if g1.x = g2.x then
9:
10:
11:
12:
13:
14: end if

return g1

return g2

end if

else

if |g1.y − g.y| < |g2.y − g.y| then

Geoinformatica (2008) 12:117–142

129

Based on Algorithm 2, we can easily ﬁnd the local min points of a grid cell in a

trajectory.

But actually a further improvement can be achieved—in most cases even the
calling of Algorithm 2 is not necessary. The reason of this is that a grid cell’s local
min points can be inferred from its neighbors’ local min points. Before showing this
statement is true, we ﬁrst prove the following theorem:

Theorem 2 Let T, T (cid:2) be two trajectories and g1, g2 two adjacent grid cells in T.
Suppose further that g(cid:2) ∈ T (cid:2) is a local min point to g1. If g1.y = g2.y and g1.x (cid:6)= g(cid:2).x
or g1.x = g2.x and g1.y (cid:6)= g(cid:2).y, then g(cid:2) is also a local min point to g2.

Proof We ﬁrst prove the case when g1.y = g2.y ∧ g1.x (cid:6)= g(cid:2).x. According to Lemma 1
and Deﬁnition 5, for an adjacent grid cell g(cid:2)(cid:2) of g(cid:2), there are only two possibilities:

(1)
(2)

g(cid:2)(cid:2).x = g(cid:2).x and |g(cid:2)(cid:2).y − g(cid:2).y| = 1, and
g(cid:2)(cid:2).y = g(cid:2).y and |g(cid:2)(cid:2).x − g(cid:2).x| = 1.

For Case (1), it is obvious that D(g(cid:2)(cid:2), g2) > D(g(cid:2), g2) since D(g(cid:2)(cid:2), g1) > D(g(cid:2), g1)

and g1.y = g2.y. Thus g(cid:2) is a local min point to g2.

For Case (2), if g(cid:2)(cid:2).x = g(cid:2).x + 1, then

D(g(cid:2)(cid:2), g1) < D(g(cid:2), g1) ⇔ g1.x (cid:2) g(cid:2).x

Since g1.x (cid:6)= g(cid:2).x, so

g1.x < g(cid:2).x ⇔ g2.x (cid:2) g(cid:2).x ⇔ D(g(cid:2)(cid:2), g2) < D(g(cid:2), g2).

Similarly, we can also show that when g(cid:2)(cid:2).x = g(cid:2).x − 1, it is also true that D(g(cid:2)(cid:2), g2) <
D(g(cid:2), g2). We conclude that g(cid:2) is also a local min point to g2.

The case when g1.x = g2.x ∧ g1.y (cid:6)= g(cid:2).y can be addressed similarly.

(cid:9)(cid:10)

, g(cid:2)

, g(cid:2)

3, and g(cid:2)

2, and g(cid:2)

4. g(cid:2)
3 and g(cid:2)

, g(cid:2)
2
.x. Similarly, g(cid:2)

.x. Actually in this example g(cid:2)

Figure 7 illustrates the main idea of Theorem 2. In the ﬁgure g1 has 4 local min
1 is also a local min point of g2 because g1.y = g2.y ∧
4 are also local min points of g2. But g(cid:2)
2 may not be
2 is not. For the

points in T2: g(cid:2)
1
g1.x (cid:6)= g(cid:2)
1
a local min point of g2 since g1.x = g(cid:2)
2
same reason, g(cid:2)
1

3 are local min points of g3; but g(cid:2)
Based on Theorem 2, we proceed to construct the OWD algorithm for grid
representation. To compute the OWD distance from T1 to T2, the local min points of
the ﬁrst grid cell in T1 are computed. Then we gradually infer other grid cells’ local
min points based on their precedents’ local min points. The shortest distance from
a grid cell in T1 to T2 can be computed by comparing its distances to its local min
points. The OWD distance from T1 to T2 is the sum of all grid cells’ (in T1) shortest
distances to T2 divided by the length of T1.

4 is not.

The details of the algorithm is given in Algorithm 3. In the initialization (Lines
1 to 4), the local min points from the ﬁrst grid cell g1 of T1 to T2 are computed
by going through T2, and the shortest distance from g1 to T2 is computed as well.
The outer “for” loop (Lines 5 to 23) computes the shortest distances from grid cells
gi(2 (cid:2) i (cid:2) m) to T2, one after another. When computing the shortest distance of gi,
the local min points of gi−1 are utilized (Lines 7 to 19). For each local min point g p of
gi=1, if the conditions in Theorem 2 are met, it is also a local min point of gi (Lines 8

130

Fig. 7 An example of
Theorem 2

Geoinformatica (2008) 12:117–142

g3
g1

T1

g2

g′
4

g′
1

g′
2

T2

g′
3

A
B
C
D

and 9). Otherwise, Algorithm 2 is employed to check if there are local min points
of gi between g p−1 and g p+1 in T2 (Lines 11 to 17). According to Theorem 2, it is
only necessary to check the grid cells whose x-label (if gi−1.y = gi.y) or y-label (if
g(i − 1).x = gi.x) is equal to gi’s.

Fig. 8 Distance computation
of trajectories in grid
representation

10

9

8

7

6

5

4

3

2

1

  1

2 

3 

 4

 5

6 

  7

 8

9 

10

Geoinformatica (2008) 12:117–142

131

if (gi−1.y = gi.y ∧ g p.x (cid:6)= gi−1.x) ∨ (gi−1.x = gi.x ∧ g p.y (cid:6)= gi−1.y) then

if (gi−1.y = gi.y ∧ g(cid:2).x = gi.x) ∨ (gi−1.x = gi.x ∧ g(cid:2).y = gi.y) then
if g(cid:2) is a local min point of gi (using Algorithm 2 to check) then

Algorithm 3 OwdGrid(T1, T2)

else

S ← S + {g p}

for each grid cell g(cid:2) between g p−1 and g p+1 in T2 do

Initialize an empty local min point set S
for each local min point g p of gi−1 do

1: m = |T1|, n = |T2|
2: Find the local min points of the ﬁrst grid cell g1 of T1 in T2
3: Compute the shortest distance d1 from g1 to T2
4: C ← d1, L ← 1
5: for each grid cell gi(2 (cid:2) i (cid:2) m) in T1 do
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23: end for
24: Return C/L

end if
end for
Compute the shortest distance di from gi to T2 using S
C ← C + di
L ← L + 1

end if
end for

S ← S + {g p}

end if

Since the grid distance function is called only between grids of T1 and their local
min points in T2, the complexity of Algorithm 3 is O(mn), where n is the length of
T1 and m is the average number of local min points in T2 for each grid cell in T1.
Although m is not completely independent of n, as shown in Section 6, it grows
much slower than n. So compared to a quadratic complexity in DTW algorithm,
Algorithm 3 achieves a better complexity bound.

Figure 8 displays the grid representation of trajectories from Fig. 1. Here the road
network background is removed and the trajectories are kept. Based on Algorithm 3,
it is easy to compute the one way distance from trajectory A to B is 0, and the one
way distance from B to A is 4. So the distance between A and B is
(cid:8)
(cid:7)

Dg(Ag, Bg) = 1
2

Dg

owd

(Ag, Bg) + Dg

(Bg, Ag)

= 2.

owd

Similarly, the distance between A and D can be computed as follows.

Dg

owd

Dg

owd

(Ag, Dg) = 10 + 10
√

(Dg, Ag) = 7 + 9

√

10 + 2

13

√

√

√

2 + 2
√

5 +
√

2 + 2

5 + 2

13

Dg(Ag, Dg) = 1
2
= 1
2

(cid:7)

Dg

owd

(Ag, Bg) + Dg

(Bg, Ag)

√

√

owd
√

(cid:8)

√

(17 + 19

2 + 4

5 +

10 + 4

13)

132

Geoinformatica (2008) 12:117–142

It is obvious that B is more similar to A than D. It should be noticed that when
computing the one way distance from A to D, there are only two LMPs (5,6) and
(5,5). Grid cell (5,6) is the LMP for all grid cells from A on its left hand side, and grid
cell (5,5) is the LMP for all grid cells from A on its right hand side. So the number of
distance computation is almost linear to the length of A.

5 Similarity search

In Section 4, we present the OWD algorithms for comparing two PWL or grid
trajectories (respectively). When performing similarity search on a large collection
of trajectories, an index structure composed of multiple granularity levels can be
employed to improve the efﬁciency. The index structure introduced here is similar to
the index structure used in [16]. But we use a different deﬁnition of the lower bound
distance, which is designed for grid representation, and prove the lower bounding
feature of this distance deﬁnition.

The index structure is deﬁned as follows.

I = (cid:12)L1, L2, ..., LM(cid:13)
Li = (cid:12)si, T i
, ..., T i
1
N
si = h · si+1

, T i
2

(cid:13)

(1 (cid:2) i (cid:2) M)
(1 (cid:2) i (cid:2) M − 1)

where I is the index, M is the number of levels, Li’s (1 (cid:2) i (cid:2) M) are levels with
different granularity, N is the number of trajectories, si is the grid cell size at level i,
j’s (1 (cid:2) j (cid:2) N) are trajectories at level i, and h is some positive integer. In the index
T i
structure, level 1 is the coarsest with the largest grid cell size s1 = hM−1sM, while level
M is the ﬁnest level (smallest cell size).

Intuitively, the index is composed of several levels of grid representations of
trajectories, from coarsest to ﬁnest. The grid cell size of a level is h times of that of
its successive level. Figure 9 shows two levels of an index of trajectories. Two linear
trajectories (T1, T2) are shown, their grid representations consist of shaded grid cells.
Note that the grid cell size of the upper level (Fig. 9 [left]) is twice of that of the lower
level (Fig. 9 [right]).

The structure is similar to the index structure used in [16] for time series similarity.
Key differences are: (1) time series data are segmented along the time dimension
in [16] and thus their “grid” structure is one dimensional, while our index is based
on 2 dimensional grid structures. (2) similarity distance functions used in this paper
are very different from that in [16], and consequently, the search operations are
different (though both use sequential search). The detail of the distance functions
are presented later in this section.

Given a set of trajectories, an index should be built before processing similarity
search. Each level is built through sequential search of trajectories. As we can see in
the deﬁnition, different levels in an index are relatively independent. Insertion of a
trajectory into an index can be translated to a series insertions into each level, which
is straightforward. The building process is done in a similar fashion as in [16].

The process of a similarity search can be divided into two steps:

•

(Step 1) Search k-nearest neighbors in the coarsest level. Compute these k
candidates’ OWD distance to the query trajectory in PWL representation. Make
the largest one the threshold θ.

Geoinformatica (2008) 12:117–142

133

10

T1

T2

9

8

7

6

5

4

3

2

1

T1

T2

5

4

3

2

1

•

where

  1 

 2  

 3 

4   

5

  1 

 2   3   4     5 

 6    7  

 8   9   10

Fig. 9 Illustration of trajectory index

(Step 2) Gradually enhance the accuracy by searching from coarser to ﬁner
levels. At each level, use θ to ﬁlter out non-promising trajectories to reduce the
search space of the next level, and update the candidate list and θ accordingly.
After searching through all levels, the ﬁnal candidate list is the answer.

One problem is that the OWD distance in grid representation is not a lower
bound of the OWD distance in PWL representation. This will cause false dismissals.
Figure 10 demonstrates this problem. There are three trajectories in Fig. 10: T1, T2,
and T3. It is obvious that the OWD distance between T1 and T2 is smaller than that
between T2 and T3 in PWL representation. But in grid representation shown in the
ﬁgure, the OWD distance between T2 and T3 is 0 because their grid representations
are exactly the same. Hence T3 is closer to T2 than T1 in grid representation, which
is different from the PWL representation.

To address this problem, we introduce a lower bound distance (LBD) Dg

(g1, g2)

lbd

between two grid cells g1, g2 as follows.

(cid:5)

(cid:16)

Dg

lbd

(g1, g2) =

l2(g1.x, g2.x) + l2(g1.y, g2.y)

l(x1, x2) =

0
|x1 − x2| − 1

(x1 = x2)
(x1 (cid:6)= x2)

Basically, the lower bound distance treats the distance between adjacent grid cells
(whose x or y-label difference is at most 1) as 0. Lower bound distance is slightly
less accurate than grid distance with the same granularity, but it carries a nice lower
bound feature as shown in Lemma 3.

134

Fig. 10 The problem
of OWD distance

Geoinformatica (2008) 12:117–142

T1

T3

T2

Lemma 3 Let p1, p2 be two points and s, s(cid:2) two grid cell sizes such that s(cid:2) = hs for
some positive integer h > 1. Suppose further that points p1 and p2 are mapped to
g1 and g2 (respectively) in grid representation with grid cell size s, and to g(cid:2)
1 and g(cid:2)
(respectively) in grid representation with grid cell size s(cid:2). then
h · Dg

) (cid:2) Dg

(g1, g2)

2

(g(cid:2)
1

, g(cid:2)
2

lbd

lbd

.x, g(cid:2)
Proof We ﬁrst show that h · l(g(cid:2)
1
2
(cid:16)

h · l(g(cid:2)
1

.x, g(cid:2)
2

.x) =

.x) (cid:2) l(g1.x, g2.x). Note that
.x = g(cid:2)
2
.x (cid:6)= g(cid:2)
2

(g(cid:2)
1
(g(cid:2)
1

0
h · (|g(cid:2)
1

.x)
.x)

.x − g(cid:2)
.x| − 1)
2
.x, g(cid:2)
.x) = 0 (cid:2) l(g1.x, g2.x).
2
.x (cid:6)= g(cid:2)
if (g(cid:2)
2
1

If (g(cid:2)
.x), h · l(g(cid:2)
.x = g(cid:2)
1
1
2
On the other hand,

.x), then (g1.x (cid:6)= g2.x) must be true since
2 is greater than that of g1, g2. Hence h · l(g(cid:2)
.x) = h ·
.x − g(cid:2)
.x| − 1) (cid:2) |g1.x − g2.x| − 1 = l(g1.x, g2.x), noting that s(cid:2) = hs. Therefore,
2
.x, g(cid:2)
.x) (cid:2) l(g1.x, g2.x).
2

the cell size of g(cid:2)
1
(|g(cid:2)
1
h · l(g(cid:2)
1

.x, g(cid:2)
2

, g(cid:2)

1

Using a similar reasoning, we can show that h · l(g(cid:2)
1
Finally, we have

.y, g(cid:2)
2

.y) (cid:2) l(g1.y, g2.y).

(g(cid:2)
, g(cid:2)
)
2
1
h2 · l2(g(cid:2)
.x, g(cid:2)
1
2
l2(g1.x, g2.x) + l2(g1.y, g2.y)

.x) + h2 · l2(g1.y(cid:2), g2.y(cid:2))

h· Dg
(cid:17)
lbd
=

(cid:17)

(cid:2)
= Dg

(g1, g2)

lbd

This concludes the proof.

(cid:9)(cid:10)

From Lemma 3, it is easy to establish Theorem 4.

Geoinformatica (2008) 12:117–142

135

Theorem 4 Let T1, T2 be two trajectories and s, s(cid:2) be two grid cell sizes such that
s(cid:2) = h · s for some positive integer h > 1. If T g
2 are grid trajectories of T1, T2
1
(cid:2)g
(cid:2)g
(respectively) in grid representation with grid cell size s, and similarly, T
1 and T
2
are grid trajectories of T1, T2 (respectively) in grid representation with grid cell size s(cid:2),
then the following holds:

, T g

h · Dg

lbd

(T

(cid:2)g
1

, T

(cid:2)g
2

) (cid:2) Dg

lbd

(T g
1

, T g
2

)

Since continuous trajectories can be treated as trajectories represented with tiny

grid cells, we can easily establish Corollary 5.

Corollary 5 Given two PWL trajectories T1, T2 and a grid cell size s, if T g
grid trajectories of T1 and T2 in grid representation with grid cell size s, then

1 and T g

2 are

s · Dg

lbd

(T g
1

, T g
2

) (cid:2) Dowd(T1, T2)

Corollary 5 indicates that the OWD distance between trajectories in grid represen-

tation is always a lower bound of the OWD distance in continuous representation.

We now turn to the index structure. A key algorithm is to search for similar
trajectories. The basic idea is to utilize the property of Corollary 5 to reduce the
number of OWD distance computation. The tree is searched from coarser level
to ﬁner level. For each level, k nearest neighbors candidates are collected and the
threshold is computed based on them. Then all trajectories with distance greater than
the threshold are ﬁltered out. Upon the bottom of the tree, we will get the answers
to the query.

The detailed algorithm is given in Algorithm 4. Line 1 searches the k-nearest
neighbors of Q in the coarsest level (i.e. the highest level) of the index structure
I using Algorithm 1 to compare Q with each trajectory in this level and the results
are stored in C. A temporary set P is used to keep intermediate trajectories ﬁltered
from the previous level. The “for” loop from Lines 3 to 11 implements Step 2 of the
similarity search strategy. First, the threshold θ produced from the previous level is
computed (Line 4). Then each trajectory in P is examined against the new threshold
(Lines 5 and 6). Here Dgi
(T, Q) means the LBD distance between T and Q on
lbd
level i, and I.Li.si represents the grid cell size of level i. Promising candidates are
compared with candidate trajectories in C (Line 7), while unpromising trajectories
are ﬁltered out (Line 9).

Although the search algorithm has the same worst case complexity as sequential
search, it is expected that the index will reduce the complexity for real datasets.
Experimental results with synthetic datasets clearly support this claim.

We conclude this section with the following remarks. The similarity search
technique developed in this paper works ﬁne if the trajectory lengths are different.
This is the consequence of the distance model and thus not surprising. Secondly,
the technique remains effective if the similarity measure is to match a sub-part of a
trajectory.

136

Geoinformatica (2008) 12:117–142

Algorithm 4 Search(S, Q, k, I, M)
Input: S — a set of trajectories,
Q — the query trajectory,
k — number of nearest neighbors,
I — A set of grid representations of trajectories in S

with different levels,

M — number of levels in I

1: Find the k-nearest neighbors of Q in I.L1 and
put in C their identiﬁers and distances to Q.

θ ← maxx∈C Dowd(x, Q)
for each trajectory T in P do

(T, Q) (cid:2) θ then

if I.Li.si · Dgi
lbd

2: P ← S
3: for i from 1 to M do
4:
5:
6:
7:
8:
9:
10:
11:
12: end for
13: return C

end if
end for

P ← P − T

else

6 Experimental evaluation

C ← k closest trajectories (and their distances) in C ∪ {T}

In this section we evaluate the grid OWD algorithm (OWD in short in this section)
by comparing it with the well known dynamic time warping (DTW) algorithm and
the piecewise linear owd algorithm (PWL in short in this section).

The main ﬁndings from the experimental study are:

• OWD achieves better accuracy than DTW in spatial shape similarity search.
• OWD out-performs DTW in all settings and the gap between them increases

rapidly with length of trajectories.

• OWD can approximate PWL fast with high accuracy.

6.1 Experiments setup and parameter settings

In the experimental evaluation, we choose Network generator—a moving object
dataset generator developed by Brinkhoff [3]. Using this generator, we simulate two
dimensional trajectories of vehicles on the road network in the city of San Francisco.
The number of trajectories varies from 10,000, 20,000, 50,000, to 100,000. The
number of nearest neighbor (i.e., k) is 10, 20, 50, or 100. When evaluating per-
formance, we use CPU time as the standard because all dataset sizes are small
enough to ﬁt into memory. All experiments are run on a Linux PC with AMD
Athlon 900 MHz CPU, 256 MB memory, and 20 GB hard disk. A new parameter
granularity is introduced to measure the ﬁneness of grid representations, which is the
number of divisions on each dimension (we apply the same number of divisions on
both dimensions). So higher granularity means ﬁner grid representation. Granularity

Geoinformatica (2008) 12:117–142

100

90
80

70
60

50

40
30

20
10

0

n
o
i
s
i
c
e
r
P

100
90
80
70
60
50
40
30
20
10
0

n
o
i
s
i
c
e
r
P

DTW

OWD

PWL

137

DTW

OWD

PWL

10

20

40

80

10

20

50

100

Granularity

k

Fig. 11 Precision of DTW and OWD with different granularity and k

varies from 10, 20, 40, to 80. The typical setting of experiments, if not explicitly
mentioned, is 50,000 trajectories, 20 nearest neighbors, 80 granularity.

6.2 Precision

In this section we evaluate the precision of OWD and DTW by comparing them with
PWL. We deﬁne the precision of OWD and DTW using the following formula:

Precision =

|S ∩ Spwl|
|Spwl|

where S is the result set of OWD or DTW, and Spwl is the result set of PWL with the
same setting.

Figure 11 (left) shows the precision results deﬁned above with different granu-
larity. Clearly OWD achieves better precision than DTW in the same grid repre-
sentation. OWD’s precision grows to near 100% when the grid granularity becomes
ﬁner, while DTW stays at the level less than 80%. The reason is that DTW ignores
trajectories with similar spatial shape but different orientation, since DTW requires
mapping between trajectories to be continuous and monotonic.

Figure 11 (right) displays the precision results with different k. It also shows that
OWD achieves better precision than DTW. In this case, the parameter k has little
impact of the precision, although smaller k has slightly better precisions.

Fig. 12 Distance error
percentage of OWD to PWL

OWD

e
g
a
t
n
e
c
r
e
P

35

30

25

20

15

10

5

0

10

20

40

80

Granularity

138

Geoinformatica (2008) 12:117–142

Fig. 13 Performance of DTW
and OWD without indexing

DTW
OWD

10,000

20,000

50,000

100,000

Dataset Size

Figure 12 gives another view of precision of OWD. The error percentage of OWD
distance to PWL distance is displayed. In this ﬁgure we do not include DTW because
its distance is in a different measure from PWL. The error percentage Perror is deﬁned
as follows.

Perror =

|Dpwl − Dowd|
Dpwl

where Dpwl and Dowd are distance of PWL and OWD in the same setting,
respectively.

It is easy to see that the error percentage decreases rapidly when granularity
increases. When granularity equals 80, it is already very small. This also explains
why OWD can achieve high precision rapidly.

6.3 Scalability

In this set of experiments, we compare the comprehensive performance of OWD
and DTW, with and without indexing, using datasets with different number of
trajectories. The CPU time for one k-nearest neighbor query over the dataset is used
as the comparison standard.

Figure 13 shows the performance of DTW and OWD without indexing. It is shown
that OWD performs much better than DTW, especially when dataset size increases.
Figure 14 performs the comparison with indexing. We choose FTW [16] as the
index method for DTW, because FTW is the best known index [16] for DTW so far.

Fig. 14 Performance of FTW
and OWD with indexing

FTW
OWD

)
d
n
o
c
e
s
(
 
e
m
T
U
P
C

i

 

250

200

150

100

50

0

)
d
n
o
c
e
s
(
 
e
m
T
U
P
C

i

 

50
45
40
35
30
25
20
15
10
5
0

10,000

20,000

50,000

100,000

Dataset Size

Geoinformatica (2008) 12:117–142

Fig. 15 DTW and OWD with
different granularity

139

DTW

OWD

)
d
n
o
c
e
S
(
 
e
m
T
U
P
C

i

 

120

100

80

60

40

20

0

10

20

40

80

Granularity

OWD uses the indexing technique introduced in Section 5. In all dataset sizes, OWD
achieves much better performance than FTW. The difference of the performance
increases with the size of the dataset.

6.4 Performance with different granularity

This section shows the performance comparison between OWD, DTW, and PWL
with different granularity.

Figure 15 shows the comparison of OWD and DTW with different granularity. It
is clear that the computation cost of DTW is much higher than OWD in all settings.
The time consumed by DTW increases much faster than OWD when the granularity
grows. This is because DTW has a quadratic complexity while OWD’s complexity is
O(mn), where n is the length of trajectories and m is the number of local min points
(Section 4.2).

Figure 16 displays the performance comparison of PWL and OWD. In this ﬁgure,
the average CPU time for a pair of trajectories similarity comparison is measured.
The granularity of OWD is 80. It is shown that PWL is much slower than OWD in
all cases. When the number of segments of trajectories increase, the gap between
PWL and OWD grows as well. It is already shown in Section 6.2 that PWL can
be approximated by OWD with reasonable high granularity. So OWD is a good
substitute of PWL when performance is critical.

Fig. 16 Performance
comparison of PWL and
OWD with trajectories of
different length

PWL
OWD

)
d
n
o
c
e
s
i
l
l
i

m

i

(
 
e
m
T
U
P
C

 

7

6

5

4

3

2

1

0

5

10

15

20

25

30

35

40

Number of Segments

140

7 Conclusions

Geoinformatica (2008) 12:117–142

An interesting issue in moving object databases is to ﬁnd similar trajectories of
moving objects. The similarity can be time sensitive or insensitive. In this paper we
study the time independent similarity search problem of moving object trajectories.
We introduced a new distance function (OWD) for comparing spatial shapes of
trajectories, developed algorithms for computing OWD in both continuous (piece-
wise linear) and discrete (grid representation) cases, and an index structure which
guarantees no false dismissals to enhance search performance. The discrete OWD
algorithm achieves a better complexity than known quadratic algorithms by utilizing
local min points in grid representation. Different grid cell size can be chosen to
trade-off the accuracy, performance, and sensitivity to noises. Our comprehensive
experimental results show that OWD out-performs traditional dynamic time warping
(DTW) algorithm in terms of both precision and performance, with and without
indexing. Moreover, the continuous OWD distance can be approximated with the
discrete one efﬁciently with reasonable accuracy. Comparison of OWD and other
existing algorithms (e.g. [19]) are under investigation. One interesting problem is the
choice of granularity to further shorten the search process. It would be interesting to
develop theoretical models or heuristic guidelines for the trade-off between running
time of the algorithm and accuracy of results. It is also interesting to focus on more
ﬂexible representations and algorithms which can accommodate transformations
such as spatial shift, rotation, and scaling etc.

8 Comments of reviews

The related works mentioned in the review are incorporated in our related work. As
suggested by the reviewer, more comparisons will be considered as our future work.
There is no nn parameter. I assume the reviewer means the granularity parameter,
which is explained in Section 6.1. It applies to both OWD and DTW’s grid based
indexes.

Figure 16 shows the computational complexity difference between PWL and
OWD. It is representive because PWL’s complexity is based on the number of
segments while OWD’s complexity is based on the length of trajectories.

Abbreviations of algorithms in Section 3.1 are now explained in Section 2.
The example of comparing bus routes with individual routes are different from
comparing two individual routes. The point is to ﬁnd the bus route with the most
similarity to a bunch of individual routes. We are viewing this example in a bus route
scheduler’s view, instead of a passenger’s view.

f2 and f3 in Section 4.1 are not mixed up. They are OWD function from s to s2 and
s3, respectively. The way to “ﬁnd the parameterized OWD function” is displayed in
Fig. 6 and corresponding explanation.

It is true that trajectory is usually used with time dimension. But we still think it is
better than path, because the latter means a static geometry object and we focus on
tracks made by moving objects. The “critical point” suggestion is very helpful. We
will incorporate it in our future study.

Geoinformatica (2008) 12:117–142

141

Acknowledgements

Supported in part by NSF grants IIS-0101134 and IIS-0415195.

References

1. H. Alt, C. Knauer, and C. Wenk. “Matching polygonal curves with respect to the frechet dis-

tance,” in Proc. Int. Sym. on Theoretical Aspects of Computer Science, pp. 63–74, 2001.

2. S. Brakatsoulas, D. Pfoser, R. Salas, and C. Wenk. “On map-matching vehicle tracking data,”

in Proc. Int. Conf. on Very Large Data Bases, pp. 853–864, 2005.

3. T. Brinkhoff. “Generating trafﬁc data.” Bulletin of the Technical Committee on Data Engineering,

IEEE Computer Society, Vol. 26(2):19–25, 2003.

4. K. Chan and W. Fu. “Efﬁcient time series matching by wavelets,” in Proc. Int. Conf. on Data

5. L. Chen and R. Ng. “On the marriage of lp-norms and edit distance,” in Proc. Int. Conf. on Very

Engineering, pp. 126–133, 1999.

Large Data Bases, pp. 792–803, 2004.

6. L. Chen, M. T. Ozsu, and V. Oria. “Robust and fast similarity search for moving object trajecto-

ries,” in Proc. ACM SIGMOD Int. Conf. on Management of Data, pp. 491–502, 2005.

7. M. de Berg, M.V. Krevel, M. Overmars, and O. Schwarzkopf. Computational Geometry

Algorithms and Applications. Springer, 2000.

8. C. Faloutsos, M. Ranganathan, and Y. Manolopoulos. “Fast subsequence matching in time-series
databases,” in Proc. ACM SIGMOD Int. Conf. on Management of Data, pp. 419–429, 1994.
9. E. Keogh, K. Chakrabarti, M. Pazzani, and S. Mehrotra. “Locally adaptive dimensionality reduc-
tion for indexing large time series databases,” in Proc. ACM SIGMOD Int. Conf. on Management
of Data, pp. 151–162, 2001.

10. E. Keogh, T. Palpanas, V.B. Zordan, D. Gunopulos, and M. Cardle. “Indexing large human-

motion databases,” in Proc. Int. Conf. on Very Large Data Bases, pp. 780–791, 2004.

11. S.L. Lee, S.J. Chun, D.H. Kim, J.H. Lee, and C.W. Chung. “Similarity search for multidimen-

sional data sequences,” in Proc. Int. Conf. on Data Engineering, pp. 599–608, 2000.

12. J.L. Little and Z. Gu. “Video retrieval by spatial and temporal structure of trajectories,” in Proc.

of Symp. on Storage and Retrieval for Image and Video Databases, 2001.

13. N. Meratnia and R.A. de By. “Aggregation and comparison of trajectories,” in Proc. ACM Symp.

on Advances in Geographic Information Systems, pp. 49–54, 2002.

14. R. Ng and Y. Cai. “Indexing spatio-temporal trajectories with chebyshev polynomials,” in Proc.

ACM SIGMOD Int. Conf. on Management of Data, pp. 599–610, 2004.

15. V. Pan. “Complexity of computations with matrices and polynomials,” in SIAM Review, 1992.
16. Y. Sakurai, M. Yoshikawa, and C. Faloutsos. FTW: “Fast similarity search under the time
warping distance,” in Proc. ACM Symp. on Principles of Database Systems, pp. 326–337, 2005.
17. D. Sankoff and J.B. Kruskal. Time Warps, String Edits, and Macromolecules: The Theory and

Practice of Sequence Comparisons. Addison-Wesley, 1983.

18. M. Vlachos, D. Gunopulos, and G. Das. “Rotation invariant distance measures for trajecto-
ries,” in Proc. of SIGKDD International Conference on Knowledge Discovery and Data Mining,
pp. 707–712, 2004.

19. M. Vlachos, G. Kollios, and D. Gunopulos. “Discovering similar multidimensional trajectories,”

in Proc. Int. Conf. on Data Engineering, pp. 673–684, 2002.

20. Y. Yanagisawa, J. ichi Akahani, and T. Satoh. “Shape-based similarity query for trajectory of

mobile objects,” in Proc. Int. Conf. on Mobile Data Management, pp. 63–77, 2003.

142

Geoinformatica (2008) 12:117–142

Bin Lin received the B.S. and M.S. degrees in Computer Science from Beijing (Peking) University,
and the Ph.D. degree in Computer Science from the University of California, Santa Barbara in 2006.
He is currently working in NCR/Teradata.

Jianwen Su received the B.S. and M.S. degrees in Computer Science from Fudan University, and
the Ph.D. degree in Computer Science from the University of Southern California. He joined the
Department of Computer Science at the University of California at Santa Barbara in 1990. Dr. Su is
a member of the Association for Computing Machinery (ACM) and SIGMOD, and a senior member
of the IEEE and Computer Society. He served on program/organizational committees of several
database and web service conferences. He is currently serving on the program committees of VLDB
2006, DILSOS 2006, CEC/EEE 2006, ICWE 2006, DEECS 2006, ICWS 2006. SCContest 2006,
MobiDE 2006, WISE 2006, ICSOC 2006, and others. He also serves as the Conference Coordinator
for SIGMOD.

