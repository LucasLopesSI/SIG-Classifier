GeoInformatica 9:4, 297–319, 2005
# 2005 Springer Science + Business Media, Inc. Manufactured in The Netherlands.

Mobility Patterns

CE´ DRIC DU MOUZA
CEDRIC lab., CNAM, 292 Rue St Martin, F-75141 Paris Cedex 03, France
E-mail: dumouza@cnam.fr

PHILIPPE RIGAUX
LAMSADE lab., Univ. Paris-Dauphine, Place du Mare´chal de Lattre de Tassigny, F-75775 Paris cedex 16,
France
E-mail: rigaux@lri.fr

Received December 1, 2004; Revised February 18, 2005; Accepted April 6, 2005

Abstract

We present a data model for tracking mobile objects and reporting the result of queries. The model relies on a
discrete view of the spatio-temporal space, where the 2D space and the time axis are respectively partitioned in
a ﬁnite set of user-deﬁned areas and in constant-size intervals. We deﬁne a generic query language to retrieve
objects that match mobility patterns describing a sequence of moves. We also identify a subset of restrictions to
this language in order to express only deterministic queries for which we discuss evaluation techniques to
maintain incrementally the result of queries. The model is conceptually simple, efﬁcient, and constitutes a
practical and effective solution to the problem of continuously tracking moving objects with sequence queries.

Keywords: mobility patterns, online evaluation, spatio-temporal applications

1.

Introduction

In the database community, several data models have been proposed to enable novel
querying facilities over collections of moving objects. A common feature of most of
these models is the strong focus on the geometric properties of trajectories. Indeed, in
most cases, the data representation and the query language are considered as extensions
of some existing data model previously designed for (and limited to) 2D geometric data
handling. As a result, spatio-temporal data models rely usually on a set of data structures
providing support for geometric operations (e.g., geometric intersection).

An assumption commonly adopted is to consider a dense embedding space and to
model trajectories as continuous functions in this space. While this property allows
several suitable computations (for instance the position of an object can be obtained at
any instant), it is not well adapted to some analysis and classiﬁcation tasks. In the present
paper we investigate an alternative approach, namely the management of queries as a
process relying on events related to the moves of objects over a discrete representation of
the underlying space, called reference space. Intuitive examples of events are, for
instance, an object enters a zone, an object stays in a zone, and an object leaves a zone.
A query in such a setting is a sequence of primitive events which can be speciﬁed either

298

DU MOUZA AND RIGAUX

by explicitely referring to the zones of interest (BGive all the objects currently in a which
arrived 5 minutes ago, coming from b^), or by more generic patterns of mobility such as,
for instance, BGive the objects that moved from a to another zone and came back to a.^
We introduce mobility patterns as expressions describing such sequences of events. In

the present paper we examine speciﬁcally the following aspects of this framework:

Y comparison and aggregation of moving objects trajectories,
Y on-line classiﬁcation of trajectories continuously provided by GPS-like devices.

We ﬁrst consider historical data and the post-acquisition operators thatallow to analyse
the spatio-temporal behavior of objects belonging to a given population (e.g., taxis,
planes, etc.) and to perform clustering and similarity-based analysis and comparisons.
Analysis tools that allow to create spatio-temporal Bproﬁles^ of objects are certainly of
interest to many applications. In the domain of trafﬁc analysis for instance, this permits
to better predict and understand the load of a local road network during a typical day.
Public services can also be made more efﬁcient when they can be proposed in
accordance with the availability of users. The same holds for commercial marketing
analysis.

Next we consider the tracking of objects with continuous queries, i.e., queries whose
result must be maintained during a given (and possibly unbounded) period of time. When
asking, for instance, for all the objects that belong to a given rectangle R during the next
3 days, the initial result is subject to vary by considering the objects that leave of enter
R. Managing incrementally the evolutions of the result (i.e., without recomputing
periodically the entire result) is a hard task with a geometric-based query language
because the dense-space assumption of the data model often contradicts with the discrete
nature of the observation. A trajectory for instance is obtained through sample points
provided by the GPS system, and the continuous representation has to be inferred by
interpolation between two sample points, or by extrapolation from the last known posi-
tion [37]. Moreover, depending on the geometric operations required by the query, one
might have to consult the past trajectory to check whether or not the object belongs to the
result. Actually the few works that propose a solution to the problem deal with limited
classes of queries (e.g., window and k-NN queries in Mokbel et al. [30] and Iwerks et al.
[21]).

We propose in the current paper a data model for representing trajectories as
sequences of moves in a discrete spatio-temporal space, and study the languages to query
such sequences of events. Essentially, the languages that we consider rely on mobility
patterns to express search operations. We focus speciﬁcally on the family of patterns that
satisfy the following properties (i) we do not need the past moves of an object o to
determine whether o matches or not a given pattern and (ii) the amount of memory
required to maintain a query result is small. These properties are essential in the context
of continuous queries since they guarantee that a large amount of queries can be
evaluated efﬁciently with limited resources by just considering the last event associated
to an object. We deﬁne a class of queries which provides an appropriate balance between
expressiveness and the fulﬁllment of these requirements.

MOBILITY PATTERNS

299

In the rest of this paper we ﬁrst develop an informal presentation of our work (Section 2)
with examples of mobility patterns that illustrate the intuition behind the modeland its
practical interest from the user’s point of view. The data model is presented in Section 3.
Section 4 surveys related work. Finally Section 5 concludes the paper and discusses future
work.

2. Mobility patterns

In our model, the locations of objects are mapped to a set of zones which partition the
area of interest. Clearly the considered partition is closely related to a speciﬁc thematic
interpretation of space which resorts to the user’s choice and constitutes a quite classical
and common spatial analysis mechanism [26], [33]. Deﬁning which partitions are
relevant and which are not is beyond the scope of the present paper. Each zone is
uniquely identiﬁed by a label from a set P, and we characterize the trajectory of an
object o by the labels of the successive zones crossed by o.

Figure 1 shows a map partitioned in several zones, each one labelled with a symbol
(a, b, c, . . . ). Over this map we describe the trajectories of a set of mobile objects. We
assume in the following that the trajectory’s description has been obtained from a GPS
system which gives the sequence of locations, along with their timestamp.

Consider now an application that aims at classifying and analysing the trafﬁc by

issuing the following queries:

1. Give all the objects that traveled from a to f, stayed more than 10 minutes in f and

2. Give all the objects traveling from f to d or c through another, third, zone of the

then traveled from f to c.

map.

3. Give all the objects that left a given zone, went to c and came back to the ﬁrst zone.

Figure 1. Objects moving over a partitioned map.

300

DU MOUZA AND RIGAUX

The common feature of these examples is a speciﬁcation of the successive zones an
object belongs to during its travel, along with temporal constraints. We call mobility
pattern this speciﬁcation. The geometric-based approach used in most of the spatio-
temporal data models so far is not really adapted for expressing queries based on
mobility patterns, because it would require a lot of joins with the reference space.
Actually we do no longer need an interpolation or extrapolation mechanism to infer
the position of an object at each instant since the discrete succession of events provided
by the GPS server is naturally suitable to serve as a support for evaluating these
patterns.

Each GPS event provides the position of an object, and this sufﬁces to compute the
zone where the object resides when the event is received. It is therefore quite easy to
construct a discrete representation of the trajectory of an object as a sequence of the form
l1{T1}.l2{T2} . . . .ln{Tn} featuring the list l1, l2, . . . , ln of successive zone labels as well as
the time spent in each zone. For instance the trajectory of o1 in Figure 1, assuming that o1
spent 2 minutes in f, 4 minutes in a, 3 minutes in d and 6 minutes in c, will be
represented in our model as a sequence [f{2}&a{4}&d{3}&c{6}]. Note that each new event
either increments the time component of the last label if the object remains in the same
zone, or appends a new label to the trajectory’s representation.

2.1. Queries

Mobility patterns are used to query this database and retrieve the objects that match a
pattern. Basically, they consist of sequences of expressions built from a small set of
operators and featuring either labels from (cid:1) or variables from a set V. Variables can be
instantiated to any of the labels of the map, and allow to denote complex classes of
trajectories within a compact and expressive language. The presentation that follows is
mostly based on examples, intended to illustrate its main features.

As a ﬁrst example, assume that we want to retrieve all the objects that started from b,
moved to e, crossing one of the cities c, d, or f (see Figure 1), and ﬁnally went from e to a
via the same city. This is expressed as follows in our language:

start at b; follow @x; follow e repeat; follow @x:a

This mobility pattern is built with two operators: start_at and follow, the latter
being optionally qualiﬁed with repeat. Two other operators, now_at and roam will
be presented in further examples.

A zone is represented by its label (here a, b, e) or by a variable (here @x) if it is left
undetermined by the user. A variable is here necessary to represent the city where an
object moved after leaving b, and expressing that the object must come back to a via the
same city. Labels or variables can be concatenated (for instance @x.a in our example) to
describe a path, and labels (but not variables) can be grouped in sets (for instance
{a,b}) to describe a union of zones.

Users can specify start_at operator to indicate where a trajectory is supposed to
begin. Another operator, now_at, indicates where an object is required to be at the

MOBILITY PATTERNS

301

present moment. Without such statements, the mobility pattern is only required to match
any subpart of the trajectory.

A follow operator describes a move which can be repeated with the repeat
statement either for a ﬁxed number of times, or many times but at least one. In our
example the follow e repeat means that an object that matches the pattern moves to
e and stays there for an unbounded period of time before coming back to a.

Intuitively, an object o matches the pattern P above if the following conditions hold:

1. there exists a valuation of the variables in P such that the valued pattern is a substring

of the object’s trajectory;

2. if the pattern begins with start_at (resp. ends with now_at), the valued pattern is

a preﬁx (resp. a sufﬁx) of the trajectory;

3. the time spent in each zone complies with the temporal constraint expressed in the

pattern.

For instance an object whose trajectory is represented by the sequence of zone labels
[b.d.e.d.a.c.f ] (we omit the temporal information for simplicity) matches the pattern
above where the value of the variable @x is set to the label d. The string in boldface is a
valuation of P, preﬁx of the discrete trajectory representation.

More generally, mobility patterns denote classes of trajectories. An object o matches a
pattern P if a substring of its discrete trajectory representation belongs to the class
denoted by P. We shall provide in the following precise deﬁnitions of the syntax and
meaning of patterns. Let us ﬁrst give some other intuitive examples that will be used
throughout the rest ofthe paper to illustrate the model.

Q1. Give all the objects travelling from a to f and then from f to c in 10 minutes.

start at a; follow f; roam 10; follow c

If the trajectory of an object o matches the pattern, then: start_at a means that
o starts from a; follow f means that o leaves a for f; roam 10 denotes that the
object moves in any zones of the map during 10 minutes. The roam operator is
neutral and never restricts in any way the trajectory of an object: leaving f, it is
possible to wander in different zones before reaching c, yet being qualiﬁed to the
result of the query.

Q2. Give all the objects that stayed in a or b all the time except for one minute when

they were in another, third, zone.

start at a; bf

g; follow a; bf
follow @x; follow a; bf

g repeat;

g repeat;

@x !¼ a; @x !¼ b

This example requires a variable @x which expresses a move from a or b to any
other zone of the map. It is possible to express additional constraints on the possible

302

DU MOUZA AND RIGAUX

instantiations of a variable, using equalities or inequalities. The user requires in this
example the object to leave a or b for a third area.

Q3. Give all the objects that went through f to another zone then went to d or c, and

came back to f using the same zone.

follow f:@x; follow d; cf
@x !¼ f

g; follow @x:f;

Recall that a variable sticks to its value once instantiated.

This language brings new querying facilities which would be quite difﬁcult, if not
impossible, to express or compute with a geometric based spatio-temporal query language,
because of the many spatial joins necessary to determine the zone where an object resides
at a given instant, and more importantly because of the sequential aspect of the queries. We
provide now the grammar of the user language. First we deﬁne the following types:

! x; with x 2 (cid:1)
! x1; : : : ; xk
! v; with v 2 V

ZONE
ZONESET
VAR
ZONESTRING ! x1: : : xk; with k Q 1; and 8i; xi 2 (cid:1)
VARSTRING ! x1: : : xk; with k Q 1; and 8i; xi 2 (cid:1) [ V

g with; k Q 1; and 8i; xi 2 (cid:1)

f

A mobility pattern is built with the following grammar, where INT denotes a positive

integer token.

START BLOC ! start at ZONESET start at VAR
NOW BLOC
"j
BLOC

! now at ZONESET now at VAR
j
! follow ZONESET REPEAT BLOC BLOC

j

"j

j
j

follow VARSTRING REPEAT BLOC BLOC
roam INT

roam

"j

j

REPEAT BLOC ! repeat INT repeat

j

"j

QUERY

! START BLOC BLOC NOW BLOC

2.2. Continuous queries

The query language deﬁned above can be used to analyse and classify objects trajectories
stored in a database. It provides also a support for continuous queries. However the
peculiarity of such queries entails some restrictions. Indeed, an object can be added or
removed from the result set during the query lifetime, depending on its most recent
moves. Under our modeling perspective, this means that the mobility patterns relevant
for a continuous evaluation are those that end with now_at: only those objects whose
trajectory’s sufﬁx, at the current instant, match the pattern, are included in the result.

As a ﬁrst example, assume that we want to retrieve all the objects that went from a or
b, moved to e, crossing one of the zones c, d, or f (see Figure 1), and ﬁnally went back

MOBILITY PATTERNS

303

from e to a via the same zone where it actually lies. This query is expressed with our
language by:

follow a; bf

g; follow @x repeat;

follow e repeat; follow @x repeat; now at a;

@x !¼f

The continuous evaluation aims at matching the pattern with a sufﬁx of the objects’
trajectory. The sufﬁx represents here the most recent partof the continuous stream of
GPS events. Since the trajectory representation evolves as new events are received, the
matching must be evaluated periodicallyValmost continuously. Our goal is to perform
this evaluation with minimal space and time consumption. We consider two essential
criteria for measuring the easiness and efﬁciency of this evaluation:

1. Do we need to consider the past moves of an object to evaluate a query?
2. What is the amount of memory required to maintain a query result?

Consider ﬁrst the case of patterns without variables. Evaluating a pattern P is then a
standard operation which simply requires to build the Finite State Automaton (FA) that
recognizes the language (cid:1)*. LP [20], where LP is the regular language denoted by P and
(cid:1) is the set of labels of the map.

In the general case, the FA associated to a regular expression is non-deterministic.
Then an object o might be associated to several states at a given time instant, and we
must record the list of current states for o. This list can be represented as a mask of bits,
one bit for each state of the FA. The value 1 (resp. 0) for a bit means that o is (resp. is
not) in the associated state. This gives a rather compact structure: for a pattern with
8 symbols, a mask of 8 bits (one byte) must be recorded for each object. One can track a
database of one million objects with only one megabyte in main memory.

The pseudo-code of the procedure HandleEvent(q, id, x, y) summarizes how to update
the result of a query q when a GPS event is received, giving a new location (x, y) for the
object o. The reference map is a set of zones denoted by M.

HandleEvent (q, o, x, y)
begin

// Compute the current zone, z
z = PointInPolygon(M, x, y)
// Get the label of z
l = label(z)
// For each bit set to 1 in the status of o,
// compute the transition l
for each bit i with value 1 in statuso

Compute sj = (cid:1)(FAq, si, l)
Set the bit j to 1 and the bit i to 0 in statuso

end for

end

304

DU MOUZA AND RIGAUX

The result set of q can then be updated according to the new status of object o.
Essentially, if at least one of the new states is an accepting one, o will be in the result set,
else it will be out of this result set. In this simple case we obtain a direct answer to the
two questions above:

1. It is not required to maintain historical information on a trajectory, since, it sufﬁces to
know the current state(s) of the FA, reached by taking account of the events received
so far.

2. The space required to maintain a query result is, in the worst case, the set of all states
in the FA (which might be non-deterministic) and is therefore proportional to the size
of the query.

If we consider now patterns with variables, the language is much more expressive, but
some care is required for executing queries. Take for instance the example Q3 above.
Each time an object leaves the zone f for another one, a new label is bound to the
variable @x. One must then store this value in order to check for the consistency of any
further occurrence of @x.

The next section is devoted to the data model, and focuses on the evaluation of queries
with variables. We show that we can still avoid to rely on historical information on
trajectories, and study more speciﬁcally the memory requirements for several classes of
queries.

3. The model

We consider an embedding space partitioned in a ﬁnite set of zones, each zone being
uniquely labeled with a symbol from a ﬁnite alphabet (cid:1). The time axis is divided in
constant size units. For concreteness we still assume in the following that the time unit is
1 minute. We also assume a set V of variables with PP \ V ¼ ; and denote as G the
union PP [ V. In the following, letters a, b, c, . . . will denote symbols from (cid:1), and @x,
@y, @z, . . . variables. We assume the reader familiar with the basic notions of regular
expressions and regular languages, as found in Hopcroft and Ullman [20].

3.1. Data representation and query language

We adopt a standard extended relational framework for the database, with O denoting
the relation of moving objects, and o.traj the trajectory of an object o. The representation
of trajectories is then deﬁned as follows:

(Representation of trajectories). A trajectory is represented by an

Deﬁnition 1:
expression of the form

s1 T1f g: s2 T2f g: (cid:1) (cid:1) (cid:1) : sn Tnf g

MOBILITY PATTERNS

305

where si, i = 1, . . . , n are symbols from (cid:1) and Ti represents the number of time units
spent in the zone si.

Hereafter, we shall use the term Btrajectory^ to mean its representation. For con-
venience, we shall often omit the temporal components and use a simpliﬁed representation
of a trajectory as a word [s1.s2. . . . .sn] in (cid:1)*.

A natural choice is to build mobility patterns as regular expressions on (cid:2) ¼ PP [ V, and
to search for the substring of trajectories that match the expression for some value of the
variables. Consider for example the regular expression E = a.@x+.b+.@x. The trajectory
t = f.d.a.c.b.c.b matches E because we can ﬁnd a word w = a.@x.b.@x in the language
denoted by E (w is called a witness in the following) and a valuation (cid:2) : {@x 2 c} such that
(cid:2)(w) is a substring of t. However this approach raises some ambiguities regarding the role
of variables. Consider the following examples:

1. Let E be the regular expression b.(aj@x)+.c. Then the trajectory b.a.c has two
witnesses in the regular language denoted by E: b.@x.c and b.a.c. In the ﬁrst case
@x must be valued to a, but in the second case any value of @x is acceptable.

2. Let E be the regular expression a.(@xj@y).b.(@xj@y). The variables @x and @y can

be used interchangeably, which makes the role of variables ambiguous.

As shown by the previous examples, if we build mobility patterns withunrestricte-
dregular expressions over G, the assignment of variables is non deterministic, and
sometimes meaningless. For safety reasons, when reading a word w and checking
whether w matches a mobility pattern P, we require each variable in P to be explicitely
bound to one of the symbols in w. We thus adopt a more rigorous deﬁnition of the
language by considering only unambiguous regular expressions on G such that each
variable always plays a role in the evaluation of the query. We need ﬁrst to introduce
marked regular expressions.

Deﬁnition 2:
(Marked expressions [2]). Let E be a regular expression over the alphabet
G. We deﬁne the marking of E as the regular expression E0 where each symbol of G is
marked by a subscript over N, representing the position of the symbol in the expression.

The marking of the regular expression a*.@x.((b.a)j(c.b)).c.@x*.a is for instance
the expression a1*.x2.((b3.a4)j(c5.b6)).c7.@x8.a9. We can now deﬁne mobility
patterns as the class of regular expressions that satisfy the following property:

Deﬁnition 3:
such that each variable of P 0 appears in each word of the language L P 0

(Mobility patterns). A mobility pattern is a regular expression P over G

Þ.

ð

This property ensures that each variable in any pattern is always assigned to a relevant
label during query evaluation. The expression P = (ajb)+.@x.(ajb)+ is for instance a
mobility pattern because @x appears in all the words of the language L Pð Þ. Any

306

DU MOUZA AND RIGAUX

successful matching of P with a trajectory t results therefore in an assignment of @x to
one of the symbols of t. It can be tested whether a regular expression matches the
required condition, and thus can be used as a mobility pattern.

Proposition 1: There exists an algorithm to check whether a regular expression is a
mobility pattern.

Proof (sketch): Let E be a regular expression. Then L Eð Þ and L E0ð
Þ are regular
languages. We deﬁne the language Lm ¼ (cid:2)*:@x1:(cid:2)*:@x2: (cid:1) (cid:1) (cid:1) :@xk:(cid:2)*
g, where G stands
for (cid:1) [ V, and @x1, . . . , @xk are the variables of E0.Lm is regular by construction, and
so are Lm and L E0ð
Þ \ Lm empty is decidable.
And if L E0ð
Þ \ Lm ¼ ;, then all the marked variables appear in all the words of
Ì
L E0ð
Þ.

Þ \ Lm . Therefore the fact that L E0ð

f

Example 1: The following regular expressions represent the mobility patterns of the
sample queries Q1, Q2 and Q3 given in Section 2.

The user query language proposed in Section 2.1 allows to construct expression that

can be transformed in mobility patterns via the following interpretation function [.]:

1. P1 = a.f{2,}.c
2. P2 = (ajb)þ.@x.(ajb)þ
3. P3 = f.@xþ.(cjd)þ.@xþ.f

1: x½ (cid:2) ¼ x; x 2 PP
v½ (cid:2) ¼ v; v 2 V
x1::: xk
½
x1; ::: ; xk
½
f

(cid:2) ¼ x1:: : xk; xi 2 PP [ V
(cid:2) ¼ x1 :: :
ð
j

jxk

g

Þ

2. Interpretation of a query:

3. Interpretation of the START_BLOCK:

start at ZONESET
½
start at VAR
½
"½ (cid:2) ¼ (cid:1)*

(cid:2) ¼ VAR
½

(cid:2)

(cid:2) ¼ ZONESET

½

(cid:2)

4. Interpretation of the NOW_BLOCK:

now at ZONESET
½
now at VAR
½
"½ (cid:2) ¼ (cid:1)*

(cid:2) ¼ VAR½

(cid:2)

(cid:2) ¼ ZONESET
(cid:2)

½

½

START BLOCK BLOCK END BLOCK

(cid:2) ¼ START BLOCK

½

(cid:2): BLOCK

½

(cid:2): END BLOCK

½

(cid:2)

MOBILITY PATTERNS

307

5. Interpretation of the BLOCK:

½
½
½
½
½
½
½
½

½

follow ZONESET repeat INT BLOCK
follow ZONESET repeat BLOCK
½
follow VARSTRING repeat INT BLOCK
follow VARSTRING repeat BLOCK
½
follow ZONESET BLOCK
½
follow VARSTRING BLOCK
(cid:2) ¼ PP INT½
roamINT
roam

(cid:2) ¼ ZONESET
½

½
(cid:2) ¼ VARSTRING

(cid:2) ¼ PP *

(cid:2)

(cid:2) ¼ ZONESET

(cid:2) INT½

(cid:2) ¼ ZONESET

(cid:2): BLOCK
½
(cid:2)þ: BLOCK
(cid:2)
½
(cid:2) INT½
(cid:2) ¼ VARSTRING

(cid:2)

½
(cid:2) ¼ VARSTRING

(cid:2): BLOCK
½
(cid:2)
(cid:2)þ: BLOCK
(cid:2)

½

(cid:2): BLOCK

(cid:2)
(cid:2): BLOCK
(cid:2)

½

The interpretation of a query is a mobility pattern. However the user query language
does not capture all the mobility patterns, as illustrated by the following example. Let
E = b.(ajc+).@x. E is a mobility patterns since the variable @x appears in all the words
of L Eð Þ: However our language does not allow to use the + operator in a or expression.
The pattern @x.a.b.c.@x denotes the family of regular languages (cid:1)* that consists of
words in (cid:1) with exactly 5 letters, the ﬁrst one being equal to the last one, separated by
a.b.c. A mobility pattern P denotes a regular language L Pð Þ (cid:3) (cid:2)*. More generally a
mobility pattern P with k variables is equivalent to the union of j(cid:1)jk regular expressions
enumerating the j(cid:1)j k possible combinations of variables values. Variables give an expo-
nentially concise way of expressing such languages.

In the following we shall denote as var(P) the set of variables in a pattern P. The query

language and its semantics are now deﬁned as follows.

(Syntax of queries). A query is a pair P; C
Deﬁnition 4:
and C is a set of constraints of the form s1 m s2, with s1, s2 2 (cid:1) ? var(P).

Þ where P is a mobility pattern

ð

Let q be a query of the form (P, LC ) where LC is a list of constraints {C1, . . . Cl}. The

result of q, denoted q Oð

Þ, is a subset of O deﬁned as follows:

Deﬁnition 5:
mapping (cid:2) : V ! (cid:1), called a valuation, withthe following properties:

(Semantics of queries). An object o belongs to qðOÞ if there exists a

1. V satisﬁes all the constraints C, OC 2 LC.
2. o:traj 2 (cid:2) L Pð Þ

Þ:

ð

The constraints in a query can be used to forbid explicitely a variable to take a value
(e.g., @x m a). The domain of a variable @x for a given query q, denoted domq(@x),
represents the set of possible values for @x given the constraints of q.

Example 2: The following queries correspond to the examples given in Section 2.

1. q1 = ({a.f{2,}.c}, ;)
2. q2 = ({(ajb)+.@x.(ajb+)}, {@x m a, @x m b})
3. q3 = ({f.@x+.(cjd)+.@x+.f}, {@x m f})

308

DU MOUZA AND RIGAUX

3.2. Query evaluation

We describe now an algorithm for evaluating a query q. First we show how to obtain an
automaton which, given a mobility pattern P, accepts the trajectories that match P. This
automaton also provides the valuation of variables in P. In a second step we explain how
the automaton can be used at runtime, and discuss the size of the memory used to store
the relevant information. For simplicity, we consider the automata that accept the
language L Pð Þ: their extension to automata that accept PP*:L Pð Þ is trivial and can be
found in any specialized textbook.

Since a mobility pattern P is a regular expression over the alphabet G, we can build a
non-deterministic ﬁnite state automaton (NFA) N(cid:2) that accepts the language of G*
denoted by P. Starting from N(cid:2) we can build a new automaton, N(cid:1) , which checks
whether a trajectory t of (cid:1)* belongs to (cid:2) L Pð Þ

Þ, and delivers the valuation (cid:2).

ð

Essentially, N(cid:1) is N(cid:2) with a management of variable bindings based on the following
extensions: (i) a transition labeled with a variable @x on a symbol a sets the value of @x
to a if @x was not yet bound and (ii) with each state one maintains the bindings of the
variables met so far. Transitions from si to sj, labeled with a variable @x, are then
interpreted as follows:

1. If @x is bound to a in si, and the current symbol of the input word is a, then sj can be

reached and the binding of sj is identical to the binding of si.

2. If @x is not bound in si, and the current symbol of the input word is a, then sj can be

reached and the binding of sj is the binding of si augmented with @x @ a.

The deﬁnition of N(cid:1) is given below.
Y The set of states of N(cid:1) , states N(cid:1)ð

j, i.e., all the possible
Þ , is states N(cid:2)ð
associations of a state of N(cid:2) with a valuation (cid:2) of the variables in P. A state of N(cid:1) is
denoted bS, vÀ.

Þ (cid:4) PP var Pð Þ
j

Y The set of accepting states of N(cid:1), accept N(cid:1)ð
Y The transition function of N(cid:1) , (cid:1)(cid:1) , is drawn from the transition function of N(cid:2), (cid:1)(cid:2) , as

Þ is accept N(cid:2)ð

Þ (cid:4) PP var Pð Þ
j:
j

follows:

(cid:5) if (cid:1)(cid:2) Si;ð

aÞ ¼ Sj is a transition of N(cid:2) with a 2 P, then (cid:1)(cid:1) Si; (cid:2)

h

ð

i;

(cid:1)
aÞ ¼ Sj; (cid:2)

(cid:2): In

other words the transition has no effect on variable bindings.
aÞ ¼

Þ ¼ Sj is a transition of N(cid:1) , then (cid:1)(cid:1) Si; (cid:2)

(cid:5) if (cid:1)(cid:2) Si; @x
ð

i;

h

ð

(cid:1)

(cid:1)

8
>><
>>:

Sj; (cid:2) þ @x :¼ a

(cid:2) if (cid:2) @xð
Þis determined and the binding
of @x with a is allowed by the constraints:
Þ ¼ a:

(cid:2)

if (cid:2) tf ¼ }TYP (cid:6) MT}@x

Sj; (cid:2)
ð
is undefined otherwise:
undeﬁned

Whenever an accepting state bS, (cid:2)À of N(cid:1) is reached, the input trajectory is accepted
and the valuation n deﬁnes the valuations of all the variables (recall that, by deﬁnition,
any word in a language deﬁned by a mobility pattern contains all the variables).

MOBILITY PATTERNS

309

3.3. Evaluation of continuous queries

In order to check at run time whether an object o matches a mobility pattern, we do not
need to fully construct the automaton described above. Instead, we start with a minimal
representation, and build in a progressive way, according to the symbols appended to the
trajectory of o, the valuation of the variables which potentiallyleads to an accepting state.
The initial representation of N(cid:1) consists only of the set of states of N(cid:2), each associated
with the empty valuation. By keeping all the current states of N(cid:1) associated with o, the
following operations can be performed whenever a new move m is appended to o.traj to
test whether o enters, stays or quits the query result:

1. If the transitions labeled with m lead o to at least one accepting state, then o becomes

part of the result of the query.

2. If the transitions labeled with m are such that o is no longer in at least one accepting

state, then it must be removed from the result of the query.

This yields a ﬁrst, convenient, property for the evaluation of continuous queries: the
last move sufﬁces to deliver the information needed to maintain a query result. Here is an
example that illustrates the process (more details can be found in the long version).

Example 3: Consider the mobility pattern P = (ajb)+.@x.(ajb)+. Figure 2 shows an
NFA automaton N(cid:2) which recognizes the words of L Pð Þ, S0 being the initial state and S4,
S5 the ﬁnal states.

Assume that one receives successively the following events for an object o: a, a, b, b,
c and a. Each row in the table of the Figure 3 shows the states of the NFA N(cid:1) after
reading a symbol, as well as the possible valuations of variable @x. The accepting states
are in bold font and mean that the trajectory belongs to the query result set.

Example 3 shows that we might have to maintain, during the analysis of an input
trajectory, several valuations associated to a same state. In the worst case one might have

Figure 2. An automaton for the mobility pattern (a|b)+.@x.(a|b)+.

310

DU MOUZA AND RIGAUX

Figure 3. Evaluation of a query.

@xþ:@yþ:@zþ

Þj (cid:4) j(cid:1)kj simultaneous states to maintain, representing all
jstates N(cid:2)ð
valuations of variables that lead to an accepting state. Consider the following pattern:

the possible

It is not difﬁcult to ﬁnd a word such that @x, @y and @z take all their possible valuations.
Depending on the application, the size of the database and the number of queries,
maintaining a large amount of informations to continuously evaluate a query might
become costly. In some cases we might therefore want to restrict the expressive power of
the language to obtain low memory needs. Consider for instance a web server providing a
subscribe/publish mechanism over a (possibly large) set of moving objects. In such a
system, web users can register queries, waiting for notiﬁcation of the results. The
performance of the system, and in particular its ability to serve a lot of queries under an
intensive incoming of events, depends on the efﬁciency of the query result maintenance,
and therefore on the size of the data required to perform this maintenance. We deﬁne below
a fragment of the query language which meets the requirement of this kind of application.

3.4. Deterministic queries

The class of deterministic queries is such that, at any instant, there is only one possible
valuation for each variable of the mobility patterns. Deterministic queries are deﬁned by
the following property:

(Deterministic queries). A query q P; C
Þ*, 8@x 2 V, u:@x:v 2 L Pð Þ ) =9 a 2 domq @xð

ð

Þ is deterministic iff 8u; v 2
Þ, =9w 2 PP [ V
Þ*, u:a:w 2

ð

Deﬁnition 6:
PP [ V
ð
L Pð Þ.

MOBILITY PATTERNS

311

The intuition is that when it becomes possible to instantiate a variable during the
analysis of a trajectory, then this transition is the only possible choice. This makes the
binding of variables deterministic, and ensures that, for a given word, there is only one
(if any) possibility to instantiate a variable.

Example 4: The following examples illustrate deterministic queries.

Y The query q(f.@x.(cjd).@x.f, ;) is deterministic. Whenever a f symbol has been read,

the only possible choice is to bind @x to the symbol that follows immediately f.

Y The query q((ajb)+.@x.(ajb)+, ;) is non-deterministic since the words a.@x.a.b and
a.b.@x.b both belong to L Pð Þ: However q0((ajb)+.@x.(ajb)+, {@x m a, @x m b}) is
deterministic.

Proposition 2: There exists an algorithm to check whether a query is deterministic.

Proof (sketch): Let q be a query, P be a mobility pattern in q and N(cid:2) a deterministic
automaton which recognizes L Pð Þ: Since N(cid:2) is deterministic, for any input string we
reach at most one state s of N(cid:2): If one can ﬁnd a state s with two transitions: d(s, @x) = s0
and d(s, a) = s00, with a 2 domq(@x), then it sufﬁces to check whether there exists two
words @x.u and a.v which both permit to reach a ﬁnal state from s. If this is the case,
Ì
then q is not deterministic.

Proposition 3: Let q P; C
there is at most one witness of w in L Pð Þ .

ð

Þ be a deterministic query. Then, for each word w of (cid:1)*,

Consider again the queries of Example 4. In the ﬁrst example an accepted word can
only have one single witness, either f.@x.d.@x.f or f.@x.c.@x.f. In the second example,
with constraints {@x m a, @x m b}, any witness consists of two words of {a,b}+, separated
by a symbol distinct from a or b.

ð

It follows that if q P; C

Þ is a deterministic query, the memory space required to check
whether a word matches q is jPj + jvar(P)j, where jPj represents the number of symbols
in P. Essentially, we need one FA for q, plus a storage for each variable, and we can
build a FA with a number of states equal to the number of symbols in the expression.

When evaluating a continuous query, we need to maintain for each object o the set of
its current states, as well as the binding of variables and this sufﬁces to determine, at
each GPS event, whether o enters, stays or quits the query result.

The proofs of the properties for mobility patterns relyon the Glushkov automaton of
introduce the

regular expressions [2], [4]. Given a regular expression E, we ﬁrst
following deﬁnitions:

Y ﬁrst(E) = {a j there is a word w such that a:w 2 L Eð Þ}
Y last(E) = {a jthere is a word w such that w: a 2 L Eð Þ}
Y follow(E, w) = {a) = {a jthere are words v and w such that v:w: a:w 2 L Eð Þ} for each

symbol w.

312

DU MOUZA AND RIGAUX

Basically, a Glushkov automaton possesses as many states as marked symbols of the
expression it stands for. Each incoming transition to a state si is labelled by the unmarked
symbol s. The deﬁnition presented by Book et al. [2] is the following:

Deﬁnition 7: The Glushkov automaton of a regular expression E is the automaton GE =
(Q0, (cid:1), d 0, qI, F 0) with:

1. qI is the initial state
2. Q 0 = sym(E0) ? {qI}
3. For a 2 G, d0(qI, a) = {xjx 2 ﬁrst(E0), xX = a}
4. For si 2 sym(E0) and a 2 G, d0(si, a) = {xjx 2 follow(E0, x) and xX = a}
5. F 0 = last(E0)

The Glushkov automaton GE recognizes the langage denoted by E [2]. The number of

states in GE is equal to the number of symbols in E.

Example 5: Figure 4 shows the Glushkov automaton GE for the regular expression E =
a((xa)j(bx)) *b, whose marking is a1((x2a3)j(b4x5)) *b6.

The following can now be obtained from the deﬁnition of the Glushkov automaton.

Proposition 4: Let P be a mobility pattern. Then for any two words w1, w2 of L Pð Þ, the
marked variables appear in the same order in w1 and w2.

Proof (sketch): Assume there exists two accepted words w1 and w2 such that w1 =
p1.@x1.q1.@x2.r1 and w2 = p2.@x2.q2.@x1.r2 and @x1 and @x2 do not appear in p1 and
p2. If @x1 does not appear in r1, since r1 is a path from the state @x2 of the Glushkov
automaton to a ﬁnal state, then p2.@x2.r1 is an accepted word. This raises a contradiction
because this word does not contain @x1. A similar reasoning shows that we obtain the
Ì
same contradition by assuming that @x1 appears in r1.

It follows that, if P is a mobility pattern in a deterministic query, for any input string in
P*, there is only one possible valuation for each variable of P. The memory space

Figure 4. Glushkov automaton of a((xa)|(bx))*b.

MOBILITY PATTERNS

313

required to check whether a word matches P is therefore states N(cid:2)ð
N(cid:2) is the Glushkov automaton of P.

j

Þ

j þ var Pð Þ

j

j , where

The N(cid:2) automaton is non-deterministic, so in the worst case all the states of the
automaton can be reached simultaneously. In addition we need to store the instanciation
of variables. Since variables are instanciated in a known order, a list of jvar(P)j memory
units is sufﬁcient.

The following example illustrates this property. Indeed, it shows that for a given
input, only one state can be reached, and that we just have to store the unique valuation
of x.

Example 6: Let us consider again the query q P; C
C ¼ @x 6¼ a; @y 6¼ b
uation on input a.a.b.b.c.a is now given in Table 1.

Þ, with P = (ajb)+.@x.(ajb)+ and
g: The automaton remains identical (see Figure 3) but the eval-

f

ð

The properties of deterministic queries ensure that the required amount of memory is
independent from the size of P, and thus of the underlying partition of space used to
describe the trajectories of moving objects. This property might be quite convenient if
the space of interest is very large, or if the number of queries to maintain is such that the
memory usage becomes a problem.

Expressions of deterministic queries are simple and can therefore easily be introduced
in a SQL-based query language such as SQL, extended with a matches boolean operator,
as illustrated by the following examples.

Q1. Give all the objects that traveled from a to f, stayed at least 2 minutes in f and then

traveled from f to c.

SELECT *
FROM Mob
WHERE traj matches a:f 2;f g:c

ð

Þ

The matches function checks whether a sufﬁx of the spatio-temporal attribute traj
matches the mobility pattern a.f.c. An additional temporal constraint states that the
object must spend at least 2 time units (e.g., 2 minutes) in f.

Table 1. Evaluation of a deterministic query.

Reached states in N(cid:1)

Transitions not allowed

Input

a
a[2]
a[2].b
a[2].b[2]
a[2].b[2].c
a[2].b[2].c.a

<S1, @x = ±>
<S1, @x = ±>
<S2, @x = ±>
<S2, @x = ±>
<S3, @x = c>
<S4, @x = c>

<S3, @x = a> since a u dom(@x)
<S3, @x = b> since b u dom(@x)
<S3, @x = b> since b u dom(@x)

314

DU MOUZA AND RIGAUX

Q2. Give all the objects that stayin a or b all the time except for one minute when they

were in another, third, zone.

SELECT *
FROM
WHERE traj matches _ a bjð
AND

@x !¼ 0a0 AND @x !¼ 0b0

Mob

ð

Þ þ :@x: a bjð

Þ þ 0

Þ

This example requires a variable @x which expresses a move not assigned to a speciﬁc
label but instantiated to the choice of a moving object when it leaves a or b. It is possible
to express additional constraints on the instantiations allowed for a variable, using
equalities or inequalities. The user requires in this example the object to leave a or b for
a third, distinct, area.
Q3. Give all the objects that went through f to another zone then went to d or c, and

came back to f using the same zone.

SELECT *
FROM
WHERE traj matches 0f:@x þ :ðd cj Þ þ :@x þ :f0
ð
AND

@x !¼ 0f 0

Mob

Þ

4. Related work

The modeling of moving objects has been strongly inﬂuenced by the existing spatial
models. Representative examples are Sistla et al. [37], Gu¨ting et al. [18], Forlizzi et al.
[13], Grumbach et al. [15], Su et al. [39], Vazirgiannis and Wolfson [43], Gu¨ting et al.
[19], Gupta et al. [16], Ding and Gu¨ting [9] and Sun et al. [40]. The fundamental work of
Forlizzi et al. [13] and Gu¨ting et al. [18] is based on spatiotemporal abstract types and
extends SQL to query spatiotemporal data at an abstract level. The model is powerful to
represent and query the past and present position of an object. The MOST model [37],
[44] supplies a query language named FTL that enables the speciﬁcation of queries that
refer to future states of the database. Other works [7], [15] use the constraint databases
framework and are convenient for representing and manipulating trajectories as inﬁnite sets
of positions. Some relevant models [9], [16] have also been proposed to manage the peculiar
problem of moving objects on a constraint network. For instance Gupta et al. [16] describes
an evaluation technique based on hypercube graphs to compute the shortest paths. Sun et al.
[40] presents approximation techniques for query processing to interrogate the past, the
present and the future of objects trajectories. The authors propose a multi-dimensional
time, histories for queries
histogram incrementally updated for queries at present
concerning the past, and a predictive technique for queries pertaining to future positions.

Expressing sequences of moves as proposed in the present paper is close in spirit to the
area of sequence databases [29], [34], [36], [38]. The SQL-TS language of Sadri et al.
[34] and [35] allows to express sequences of conditions. The paper describes an efﬁcient

MOBILITY PATTERNS

315

algorithm for query evaluation. The idea of representing temporal sequences as strings,
relying on pattern-matching algorithms for query evaluation, is also present in Dumas et
al. [11] and Djafri et al. [10]. The system explores the consecutive snapshots contained in
the spatio-historical database, creates an evolution string and looks for a matching of this
string with the histories of the objects. In Ramakrishnan et al. [32] sequences are
considered as sorted relations, and each tuple gets a number that represents its position in
the sequence. A shift operator using this number is deﬁned in order to join tuples of the
same sequence. Aggregation operators on sequences for a given range of sequencing
numbers is also presented. Some other works [5], [14], [17], [24], [27] present algorithms
for querying and mining similar subsequences, as well as event detection from time
series data (i.e., sequences of real numbers). Law et al. [27] for instance describes the
necessary restrictions of the SQL language when dealing with streams, focusing on the
problem of the aggregation. After deﬁning the Bnonblocking^ queries, the paper deﬁnes
aggregates (UDA) that can be applied on stream data. Nonetheless all these approaches
are signiﬁcantly different from ours. In particular there is nothing similar to the concept
of mobility pattern, featuring variables, proposed in our data model.

The notion of continuous queries, described as queries that are issued once and run
continuously, is ﬁrst proposed in Terry et al. [42]. The approach considers append-only
databases and relies on an incremental evaluation on delta relations. Availability of
massive amounts of data on the Internet has considerably increased the interest in
systems providing event notiﬁcation across the network. Some representative works are
the Active Views system [1], the NiagaraCQ system [6], and the prototypes described in
Liu et al. [28] and Fabret et al. [12]. In the area of spatio-temporal databases, the
problem is explicitely addressed in several works [3], [21]Y[23], [30], [31], [41], [45].
Brinkhoff and Weitka¨mper [3] for instance describes a web-based architecture for
reducing the volume and frequency of data transmissions between the client and the
server. Kalashnikov et al. [23] presents a system that indexes queries in order to
recompute periodically the whole result of each query. This is in contrast with the
incremental computation advocated in the current paper. Iwerks et al. [21] describes an
evaluation method to maintain the result of a kNN-query by retrieving all the objects
within a given range that may affect in a close future the result of the query. Mokbel
et al. [30], [31] and Xiong et al. [45] discuss algorithms to incrementally evaluate a set
of continuous queries that consist of three steps: (i) join with the cache for new incoming
tuples (positive updates), (ii) invalidate some results (negative updates)after a timeout,
(iii) join with the stored data (positive and negative updates). Jensen et al. [22] presents
an index based on the B+-tree, called the Bx-tree, that allows an efﬁcient evaluation of
continuous, range and k-NN queries. They reconsider the concept of conservative
approximation by taking account of the enlargement of the queries’ regions.

5. Conclusion and further work

We described in this paper a new approach for querying and tracking a moving object
database by means of mobility patterns. Our proposal is based on a data model which

316

DU MOUZA AND RIGAUX

allows to retrieve objects whose trajectory matches a parameterized sequence of moves
expressed with respect to a set of labeled zones. We investigated the applicability of the
model to continuous query evaluation, showed how to maintain incrementally the result
of a query, and identify a fragment of the query language such that the amount of space
required to maintain this result is very low.

A simpliﬁed version of the language can easily be introduced as complement of a
geometric-based extension of SQL, as shown by the query samples proposed in Section 3.
The properties of the language make it a convenient candidate for mobile object tracking
based on sequences patterns, and its simplicity leads to an easy implementation.

A prototype is being developed in order to assess the relevancy of this approach in a
web-based context where a lot of clients can register queries, receive an initial result set,
and wait for notiﬁcation of updates to this result set. In particular we are currently
working on optimization techniques for patterns expressed as words in G*. We believe
that standard pattern matching techniques [8], [25] can be extended to such parame-
terized strings, thereby allowing an evaluation by a simple scan of the input trajectory,
without additional memory requirements.

This framework raises several interesting research issues that we plan to investigate in a
near future: approximate similarities between trajectories represented as strings, extension
of the query language to express temporal and topological constraints on the zones of a
pattern, and ﬁnally multi-resolution sequences. Indeed, introducing multi-scale patterns is
likely to raise the power of the classiﬁcation and analysis aspects of our model.

We are very grateful to D. Vodislav and D. Gross-Amblard for early discussions on this
model.

Acknowledgments

References

1. S. Abiteboul, B. Amann, S. Cluet, A. Eyal, L. Mignet, and T. Milo. BActive views for electronic

commerce,^ in Proc. Intl. Conf. on Very Large Data Bases (VLDB), 1999.

2. R. Book, S. Even, S. Greibach, and G. Ott. BAmbiguity in graphs and expressions,’’ IEEE Transactions on

Computers, Vol. 20(2):149Y153, 1971.

3. T. Brinkhoff and J. Weitka¨mper. BContinuous queries within an architecture for querying XML-represented

moving objects,^ in Proc. Intl. Conf. on Large Spatial Databases (SSD), 2001.
4. A. Bruggemann-Klein and D. Wood. BOne-unambiguous regular languages,^ 1998.
5. L. Chen and R.T. Ng. BOn the marriage of Lp-norms and edit distance,^ in Proc. Intl. Conf. on Very Large

Data Bases (VLDB), 792Y803, 2004.

6. J. Chen, D. DeWitt, F. Tian, and Y. Wang. BNiagaraCQ: A scalable continuous query system for internet

databases,^ in Proc. ACM SIGMOD Symp. on the Management of Data, 2000.

7. J. Chomicki and P.Z. Revesz. BConstraint-based interoperability of spatiotemporal databases,^ in Proc. Intl.
Conf. on Large Spatial Databases (SSD), Vol. 1262 of Lecture Notes in Computer Science, 142Y161,
Springer, 1997.

8. M. Crochemore and W. Rytter. Text Algorithms. Oxford University Press, New York, 1994.

MOBILITY PATTERNS

317

9. Z. Ding and R.H. Gu¨ting. BManaging moving objects on dynamic transportation networks,^ in Proc. Intl.

Conf. on Scientiﬁc and Statistical Databases (SSDBM), 287Y296, 2004.

10. N. Djafri, A. Fernandes, N.W. Paton, and T. Grifﬁths. FSpatio-temporal evolution: Querying patterns of
change in spatio-temporal databases,^ in Proc. Intl. Symp. on Geographic Information Systems, 35Y41,
2002.

11. M. Dumas, M.-C. Fauvet, and P.-C. Scholl. BHandling temporal groupingand pattern-matching queries in
a temporal object model,^ in Proc. Intl. Conf. on Information and Knowledge Management, 424Y431,
1998.

12. F. Fabret, H. Jacobsen, F. Llirba, K. Ross, and D. Shasha. BFiltering algorithms and implementations
for very fast publish/subscrib systems,^ in Proc. ACM SIGMOD Symp. on the Management of Data,
2001.

13. L. Forlizzi, R. Gu¨ting, E. Nardelli, and M. Schneider. BA data model and data structures for moving objects

databases,^ in Proc. ACM SIGMOD Symp. on the Management of Data, 2000.

14. D.Q. Goldin and P.C. Kanellakis. BOn similarity queries for time-series data: Constraint speciﬁcation and
implementation,^ in Proceedings of the 1st International Conference on Principles and Practice of
Constraint Programming (CP’95), 1995.

15. S. Grumbach, P. Rigaux, and L. Segouﬁn. BManipulating interpolated data is easier than you thought,^ in

Proc. Intl. Conf. on Very Large Data Bases (VLDB), 2000.

16. S. Gupta, S. Kopparty, and C.V. Ravishankar. BRoads, codes and spatiotemporal queries,^ in Proc. ACM

Symp. on Principles of Database Systems, 115Y124, 2004.

17. V. Guralnik and J. Srivastava. BEvent detection from time series data,^ in Proceedings of the Fifth ACM

SIGKDD International Conference on Knowledge Discovery and Data Mining, 33Y42, 1999.

18. R.H. Gu¨ting, M.H. Bo¨hlen, M. Erwig, C.S. Jensen, N.A. Lorentzos, M. Schneider, and M. Vazirgiannis.
BA foundation for representing and quering moving objects,’’ ACM Transactions on Database Systems,
Vol. 25(1):1Y42, 2000.

19. R.H. Gu¨ting, M.H. Bo¨hlen, M. Erwig, C.S. Jensen, N.A. Lorentzos, E. Nardelli, M. Schneider, J.R.R.
Viqueira (Eds.). Spatio-Temporal Models and Languages: An Approach Based on Data Types. Spatio-
Temporal Databases. The CHOROCHRONOS Approach, 2003.

20. J. Hopcroft and J. Ullman. Introduction to Automata Theory, Languages, and Computation. Addison-

Wesley, Boston, 1979.

21. G.S. Iwerks, H. Samet, and K. Smith. BMaintenance of spatial semijoin queries on moving points,^ in Proc.

Intl. Conf. on Very Large Data Bases (VLDB), 828Y839, 2004.

22. C.S. Jensen, D. Lin, and B.C. Ooi. BQuery and update efﬁcient B+-tree based indexing of moving objects,^

in Proc. Intl. Conf. on Very Large Data Bases (VLDB), 768Y779, 2004.

23. D. Kalashnikov, S. Prabhakar, W. Aref, and S. Hambrusch. BEfﬁcient evaluation of continuous range
queries on moving objects,^ in Proc. Intl. Conf. on Databases and Expert System Applications (DEXA),
731Y740, 2002.

24. S.-W. Kim, J. Yoon, S. Park, and T.-H. Kim. BShape-based retrieval of similar subsequences in time-series
databases,^ in Proceedings of the 17th Symposium on Proceedings of the 2002 ACM Symposium on Applied
Computing, 438Y445, 2002.

25. D. Knuth, J. Morris, and V. Pratt. BFast pattern matching in strings,’’ SIAM Journal on Computing,

26. R. Laurini and D. Thompson. Fundamentals of Spatial Information Systems, No. 37 in The A.P.I.C. Series,

Vol. 6(2):323Y350, 1977.

Academic Press, New York, 1992.

27. Y.-N. Law, H. Wang, and C. Zaniolo. BQuery languages and data models for database sequences and data

streams,^ in Proc. Intl. Conf. on Very Large Data Bases (VLDB), 492Y503, 2004.

28. L. Liu, C. Pu, and W. Tang. BContinual queries for internet scale event-driven information delivery,’’ IEEE

Transactions on Knowledge and Data Engineering, Vol. 11(4):610Y628, 1999.

29. G. Mecca and A.J. Bonner. BFinite query languages for sequence databases,^ in Proc. Intl. Workshop on

Database Programming Languages, 1995.

30. M.F. Mokbel, X. Xiong, and W.G. Aref. BSINA: Scalable incremental processing of continuous queries in

spatio-temporal databases,^ in Proc. ACM SIGMOD Symp. on the Management of Data, 2004.

318

DU MOUZA AND RIGAUX

31. M.F. Mokbel, X. Xiong, W.G. Aref, S.E. Hambrusch, S. Prabhakar, and M.A. Hammad. BPLACE: A query
processor for handling real-time spatiotemporal data streams,^ in Proc. Intl. Conf. on Very Large Data
Bases (VLDB), 1377Y1380, 2004b.

32. R. Ramakrishnan, D. Donjerkovic, A. Ranganathan, K.S. Beyer, and M. Krishnaprasad. BSRQL: Sorted
relational query language,^ in Proc. Intl. Conf. on Scientiﬁc and Statistical Databases (SSDBM), 84Y95,
1998.

33. P. Rigaux, M. Scholl, and A. Voisard. Spatial Databases. Morgan Kaufmann, San Francisco, 2001.
34. R. Sadri, C. Zaniolo, A.M. Zarkesh, and J. Adibi. BOptimization of sequence queries in database systems,^

in Proc. ACM Symp. on Principles of Database Systems, 2001.

35. R. Sadri, C. Zaniolo, A.M. Zarkesh, and J. Adibi. BA sequential pattern query language for supporting

instant data mining for e-services,^ in Proc. Intl. Conf. on Very Large Data Bases (VLDB), 2001.

36. P. Seshadri, M. Livny, and R. Ramakrishnan. BSEQ: A model for sequence databases,^ in Proc. IEEE Intl.

Conf. on Data Engineering (ICDE), 232Y 239, 1995.

37. A. Sistla, O. Wolfson, S. Chamberlain, and S. Dao. BModeling and querying moving objects,^ in Proc.

IEEE Intl. Conf. on Data Engineering (ICDE), 422Y433, 1997.

38. A.P. Sistla, T. Hu, and V. Chowdhry. BSimilarity based retrieval from sequence databases using automata

as queries,^ in Proc. Intl. Conf. on Information and Knowledge Management, 237Y244, 2002.

39. J. Su, H. Xu, and O. Ibarra. BMoving objects: Logical relationships and queries,^ in Proc. Intl. Conf. on

Large Spatial Databases (SSD), 3Y19, 2001.

40. J. Sun, D. Papadias, Y. Tao, and B. Liu. BQuerying about the past, the present, and the future in spatio-

temporal,^ in Proc. IEEE Intl. Conf. on Data Engineering (ICDE), 202Y213, 2004.

41. Y. Tao, D. Papadias, and Q. Shen. BContinuous nearest neighbor search,^ in Proc. Intl. Conf. on Very Large

Data Bases (VLDB), 287Y298, 2002.

42. D. Terry, D. Goldberg, D. Nichols, and B. Oki. BContinuous queries over append-only databases,^ in Proc.

ACM SIGMOD Symp. on the Management of Data, 1992.

43. M. Vazirgiannis and O. Wolfson. BA spatiotemporal model and language for moving objects on road
networks,^ in Proc. Intl. Conf. on Large Spatial Databases (SSD), vol. 2121 of LNCS, 20Y35, 2001.
44. O. Wolfson, A.P. Sistla, B. Xu, J. Zhou, and S. Chamberlain. BDOMINO: Databases for moving objects
tracking,^ in Proc. ACM SIGMOD Symp. on the Management of Data, 547Y549, 1999 (Demo sessions).
45. X. Xiong, M.F. Mokbel, W.G. Aref, S.E. Hambrusch, and S. Prabhakar. BScalable spatio-temporal
continuous query processing for location-aware services,^ in Proc. Intl. Conf. on Scientiﬁc and Statistical
Databases (SSDBM), 317Y326, 2004.

Ce´dric du Mouza has received a M.Sc. in computer science from the University Pierre et Marie Curie - Paris
VI (France) in 2000 and a M.Sc. in advanced computer science from the University of Manchester (United-
Kingdom) in 1999. He also holds an engineering diploma from the Institut d’Informatique d’Enterprise (IIE).
He is actually currently a Ph.D. student in the database group of the Conservatoire National des Arts et Me´tiers
(CNAM) in Paris, supervised by P. Rigaux. His work focuses on the representation and querying of moving
objects.

MOBILITY PATTERNS

319

Philippe Rigaux has worked as a computer professional in the area of databases and software applications
between 1986 and 1992. He graduated with a Ph.D. in Computer Science from the CNAM Institute in 1995. He
is currently a professor in Laboratoire d’Analyse et Mode´lisation de Syste`mes pour l’Aide la De´cision
(LAMSADE) database group at Universite´ Paris-Dauphine. His research interests include the design of query
languages and query evaluation techniques. He authored more than 30 papers in international conferences and
journals, and a book on Spatial Databases (with A. Viosard and M. Scholl), published by Morgan Kaufmann
in 2001.

