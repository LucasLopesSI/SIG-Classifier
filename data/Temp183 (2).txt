Geoinformatica (2008) 12:497–528
DOI 10.1007/s10707-007-0037-9

Reporting Leaders and Followers among Trajectories
of Moving Point Objects

Mattias Andersson · Joachim Gudmundsson ·
Patrick Laube · Thomas Wolle

Received: 7 January 2007 / Revised: 10 August 2007 /
Accepted: 5 September 2007 / Published online: 26 October 2007
© Springer Science + Business Media, LLC 2007

Abstract Widespread availability of location aware devices (such as GPS receivers)
promotes capture of detailed movement trajectories of people, animals, vehicles
and other moving objects, opening new options for a better understanding of the
processes involved. In this paper we investigate spatio-temporal movement patterns
in large tracking data sets. We present a natural deﬁnition of the pattern ‘one object is
leading others’, which is based on behavioural patterns discussed in the behavioural
ecology literature. Such leadership patterns can be characterised by a minimum time
length for which they have to exist and by a minimum number of entities involved
in the pattern. Furthermore, we distinguish two models (discrete and continuous) of
the time axis for which patterns can start and end. For all variants of these leadership
patterns, we describe algorithms for their detection, given the trajectories of a group
of moving entities. A theoretical analysis as well as experiments show that these
algorithms efﬁciently report leadership patterns.

M. Andersson
Department of Computer Science, Lund University,
Lund, Sweden
e-mail: mattias@cs.lth.se

J. Gudmundsson · T. Wolle (B)

NICTA Sydney, Locked Bag 9013,
Alexandria NSW 1435, Australia
e-mail: thomas.wolle@nicta.com.au

J. Gudmundsson
e-mail: joachim.gudmundsson@nicta.com.au

P. Laube
Department of Geomatics, The University of Melbourne,
Victoria 3010, Australia
e-mail: plaube@unimelb.edu.au

498

Geoinformatica (2008) 12:497–528

Keywords moving point objects · trajectories · movement patterns · leadership ·
spatio-temporal data structures · computational geometry

1 Introduction

Movement is the spatio-temporal process par excellence. Technological advances
of location-aware devices, surveillance systems and electronic transaction networks
produce more and more opportunities to trace moving individuals. Consequently, an
eclectic set of disciplines including geography [17], data base research [23], animal
behaviour research [26], surveillance and security analysis [46], [48], [58], transport
analysis [30], [34], and market research [49] shows an increasing interest in movement
patterns of various entities moving in various spaces over various times scales.

At the same time traditional geographic analysis suffers from the legacy of
cartography’s static perception of the world and is thus generally not suited for
the analysis of individual movement trajectories [8], [51], sometimes referred to
as geospatial lifelines especially in a GIScience context [43]. Many authors have
therefore recently proposed to use geographical (and thus) spatio-temporal data
mining as a promising alternative to overcome this methodological shortcoming
[14], [44].

As can be seen from the pattern terminology, the present paper is largely inspired
by movement patterns observed in gregarious animals, such as ﬂocking sheep or
schooling ﬁsh. It follows a strategy to link the proposed patterns as close as possible
to observable patterns. The proposed pattern deﬁnitions are based on behavioural
patterns discussed in the behavioural ecology literature and used for the modelling
of realistic movement patterns of agent-based virtual life forms [27], [35].

This paper addresses the movement pattern of one object leading others. The pa-
per therefore deﬁnes the movement pattern ‘leadership’ and subsequently presents
algorithms to detect such patterns. Leadership, as deﬁned in this paper, bases on the
geometrical relation of one individual moving in front of its followers. The algorithms
presented for an efﬁcient detection of ‘leadership’ make use of a set of auxiliary
data structures, speciﬁcally developed for capturing those spatio-temporal relations
amongst moving objects that constitute leadership.

Even though the leadership pattern in this paper is motivated and investigated
with respect to animal behaviour research, its deﬁnition is held generic and is thus
applicable to arbitrary types of entities moving in a 2D-space. In general the input is
a set of n moving point objects e1, ..., en whose locations are known at τ consecutive
time-steps t1, ..., tτ , that is, the trajectory of each object is a polygonal line that can
self-intersect. For brevity, we will call moving point objects entities from now on. We
assume that the movement of an entity from its position at a time-step t j to its position
at the next time-step t j+1 is described by the straight-line segment between the two
coordinates, and that the entity moves along the segment with constant velocity.

The paper is organised as follows. Section 2 links previous research on movement
patterns similar to our leadership with the latest related research. Section 3 deﬁnes
our notion of leadership and features deﬁnitions and preliminaries. In Section 4
and 5, we present algorithms for the detection of leadership. Then, in Section 6 we

Geoinformatica (2008) 12:497–528

499

present experimental results and discuss their implications in Section 7. We conclude
the paper with ﬁnal remarks and an outlook on future work in Section 8.

2 Related work

2.1 Inspiring animals

Animals interact socially to gain from coordination of their behaviour [9], [33]. Rands
et al. [50] illustrated the spontaneous emergence of leaders and followers using a
simulation model reproducing the decision process of a pair of foraging animals,
balancing their energetic states. The idea and the term of leadership have been used
in several different contexts in the ﬁeld of animal behaviour research, see Dumont
et al. [12] for an overview. In general, one can distinguish two different readings:

1.

2.

‘The event or process of one entity initiating a group movement (e.g. [7], [12],
[40], [47])’ Leading in this sense is an active behaviour, referring to individuals
that consistently initiate displacement of the group they belong to. For example,
Dumont et al. [12] found that in a group of 15 grazing heifers the same individual
was reported to lead the group to new feeding places in 48% of all group
movements. Similar leadership behaviour has also been studied in gray wolves
(Canis lupus) [47].
‘The event or process of one entity in front, leading a group movement (e.g. [7],
[22])’ Leading in this sense involves the notion of a leader moving in front of
followers. Gueron and Levin model the spatial constellation ‘in front of’ as a
function of the relative position of a potential leader with respect to the averaged
position of its neighbours within a given range. Even though it has been found
for grazing animals that leaders may guide a group being in front or chasing from
behind, animals in front are considered to be more relevant to determine where
the group will graze [12].

The use of the geometrical arrangement of moving entities has furthermore a
long tradition for realistically modelling group behaviour, be it in animal behaviour
science [22] or in the animation industry [52]. Most prominent is the ﬂocking model
implemented in NetLogo [59], [62], which mimics the ﬂocking of birds [61]. The
moving agents dynamically coordinate their movement based on rules on alignment
(turning in order to adopt direction of nearby agents), separation (turning to avoid
getting too close to nearby agents) and cohesion (move towards other nearby agents).
This model explicitly excludes the idea of an individual leading the others, but
involves identical agents, each following the same set of rules. The basic model
includes a maximal distance of vision r and 360◦ ﬁeld of view. However, it is also
possible in NetLogo to specify a cone of vision, a most interesting concept with
respect to the investigation of further structure in ﬂocking entities that can, for
example, be seen in V-shaped ﬂocks as with migrating geese. Such front priority is
also often used for agent-based models of schooling ﬁsh, where only individuals in
front are candidates as interacting neighbours [27]. Inada’s and Kawachi’s model
uses a wide-angled cone of perception, directed in movement direction and thus

500

Geoinformatica (2008) 12:497–528

omitting a blind region behind the ﬁsh (Fig. 1 and 2 in [27]). Jadbabaie et al. give
a theoretical explanation for the spontaneous coordination of agents despite the
absence of a centralised coordination and just following a simple nearest neighbour
rule [29]. However, in an extension they also investigate the inﬂuence of a leader in
their system.

(cid:2) All such research integrating biology with information science and computer
science points out the potential of a systematic investigation of geometric relations of
moving animals for analysing, modelling and simulating movement processes. Above
all, animal movement provides a set of very convincing metaphors for more generic
movement patterns, as shall be exploited with the pattern ‘leadership’ in this paper.

2.2 Limiting databases

There is ample research on moving object databases (MOD) [25], [56], [63], [64].
Whereas most database research on MOD focuses on data structures, indexing and
efﬁcient querying techniques for moving objects [1], [16], [23], [24], only recently the
potential of data mining for movement patterns has been acknowledged [31], [32],
[53]. For example, Du Mouza and Rigaux propose mobility patterns that describe
sequences of moves in a discrete 2D-space [11].

In a GIScience context, activity related movement patterns have been researched,
often with respect to improving location-based services (LBS). Dykes and Moun-
tain search episodes expressing distinctive characteristics of movement, including
absolute speed, direction, sinuosity and measurements of their variations [13]. Smyth
presents a data mining algorithm that assigns predeﬁned activities to segments of
trajectories by analysing some measurable motion descriptors, such as speed, heading
and acceleration [57].

A common approach in database research is to take an existing spatial query type
and then study its generalisations to spatio-temporal data. An example of this is
the recent work on continuous k-nearest neighbour querying over mobile data [45],
[65]. The focus within data mining research is to design techniques to discover new
patterns in large repositories of spatio-temporal data. For example, Mamoulis et
al. [42] mine periodic patterns between moving objects and Ishikawa et al. [28]
mine spatio-temporal patterns in the form of Markov transition probabilities. More
recently Verhein and Chawla [60] used association rule mining for patterns such as,
sinks, sources, stationary regions and thoroughfares.

Spatio-temporal proximity of entities is a reasonable ﬁrst premise for many
situations that assume interactions between individuals. One obvious analytical
toolset to uncover proximity patterns in individual trajectories is clustering. Even
though the spatio-temporal nature of movement data adds additional complexity
to clustering procedures, there have been some successful approaches for clustering
trajectories [10], [41], [55]. However, spatio-temporal co-presence does not explicitly
include the idea of interactions within individuals. Relations such as ‘leading’,
‘following’ or ‘setting a trend’ cannot be investigated by pure clustering alone.

(cid:2) In essence, conventional spatial and spatio-temporal querying and clustering
are inherently static and thus limited in their ability to cope with dynamic move-
ment. Hence complementing techniques have to be explored in order to cope with
the emerging new generation of movement data. Shirabe [54] illustrates such an

Geoinformatica (2008) 12:497–528

501

alternative and uses correlation analysis in order to discover leader and follower
relationships amongst moving individuals.

2.3 Promising patterns

Precursory to this research Laube and colleagues proposed the relative motion
framework (REMO) which deﬁnes similar behaviour in groups of entities [36]–
[38]. They deﬁned a collection of movement patterns based on similar movement
properties such as speed, acceleration or movement direction. Laube et al. [39]
extended the framework by not only including movement properties, but also loca-
tion itself. They deﬁned several movement patterns, including ﬂock (co-ordinately
moving close together), trend-setter (anticipating a move of others), leadership
(spatially leading a move of others), convergence (converging towards a spot) and
encounter (meeting at a spot) and gave algorithms to compute them efﬁciently. Later
Gudmundsson et al. [21] considered the same problems and extended the algorithmic
results by primarily focusing on approximation algorithms—‘Any exact values of m
and r hardly have a special signiﬁcance—20 caribou meeting in a circle with radius
50 meters form as interesting a pattern as 19 caribou meeting in a circle with radius
51 meters.’ Benkert et al. [5] and Gudmundsson and van Kreveld [20] only recently
revisited the ﬂock pattern and gave a more generic deﬁnition that bases purely on
the geometric arrangement of the moving entities and thus excludes the need of an
analytical space as with the initial deﬁnition of the patterns [36], [39].

The model used in the REMO framework considers each time-step separately,
that is, given m ∈ N and r > 0 a ﬂock is deﬁned by at least m entities within a circular
region of radius r and moving in the same direction at some point in time. Benkert
et al. [5] argued that this is not enough for many practical applications, e.g. a group
of animals may need to stay together for days or even weeks before it is deﬁned as a
ﬂock. They proposed the following deﬁnition of a ﬂock:

Deﬁnition 1 (m, k, r)-ﬂock - Let m, k ∈ N and r > 0 be given constants. Given a set
of n trajectories, where each trajectory consists of τ line segments, a ﬂock in a time
interval I = [ti, t j], where j − i + 1 ≥ k, consists of at least m entities, such that for
every point in time within I there is a disk of radius r that contains all the m entities.

We will use a similar model when deﬁning the leadership patterns, see Section 3.
Using this model, Gudmundsson and van Kreveld [20] recently showed that comput-
ing the longest duration ﬂock and the largest subset ﬂock is NP-hard to approximate
within a factor of τ 1−ε and n1−ε, respectively, for any constant ε > 0. In the same
model, Benkert et al. [5] described an efﬁcient approximation algorithm for reporting
and detecting ﬂocks, where they let the size of the region deviate slightly from
what is speciﬁed. Approximating the size of the circular region with a factor of
(cid:4) > 1 means that a disk with radius between r and (cid:4)r that contains at least m
objects may or may not be reported as a ﬂock while a region with a radius of
at most r that contains at least m entities will always be reported. Their main
approach is a (2 + ε)-approximation (for any constant ε > 0) with running time
T(n) = O(kn(2k log n + k2/ε2k−1)). Note that even though the dependency on the
number of entities (namely n) is small, the dependency on the duration of the

502

Geoinformatica (2008) 12:497–528

ﬂock pattern (namely k) is exponential. Al-Naymat et al. [2] handle the problem of
considering many entities and long-duration patterns by using a preprocessing step
where the number of dimensions (i.e. time-steps) is reduced by random projection.
(cid:2) A series of articles exploring simple ﬂocking illustrated the potential of patterns
based on the geometric arrangement of moving entities. The present paper shall
achieve a similar deﬁnition for the more complex pattern leadership as well as
efﬁcient algorithms for its detection.

3 Leadership

We consider n entities moving in the two dimensional plane during the time interval
[t1, tτ ], see Fig. 1a for an example. The inﬁnite set T p of time-points is deﬁned as
T p = {t | t ∈ [t1, tτ ]}, and the set Ts of time-steps is the set of discrete time-points
given as input, i.e. Ts = {t1, ..., tτ }. We specify open and closed time intervals by
(tx, ty) and [tx, ty], respectively. A unit-time-interval is an open interval I between
two consecutive time-steps, i.e. I = (tx−1, tx), for a time-step tx with x > 1.

3.1 Deﬁning leadership patterns

For describing our leadership patterns, we need a couple of parameters specifying
these patterns. More speciﬁcally, we assume that we are given numbers m (specifying
the size of a pattern, i.e. the minimum number of entities involved in a pattern),
k (the minimum temporal length of a pattern), a radius r (inﬂuencing the spatial
size of a pattern), an angle α (also inﬂuencing the spatial size of a pattern) and
an angle β (determining spatial characteristics of a pattern). We consider them as

1

e4

2

a

6

e2

1

1

1

e3

e1

2

2

2

3

3

3

5

4

4

3

4

4

5

5

b

s1

s2

s

e

d

5

c

6

6

e2
6

7

7

7

7

8

e1
8

e4

8

8

e3

IntervalsNotFwg(t):

e1

3

5

2

4
1
8
0 1 2 0 1 2 3 0

6

7

1

2

3

4

5

6

7

8

e2 0 0 0 0 0 1 0 0

e3

3

2

4
5
1
8
0 0 0 0 0 0 0 0

6

7

3

2

4
1
5
8
0 1 2 3 4 5 6 7

6

7

e4

IntervalsFwg(e’,t):

e2 0 1 2 3 4 0 0 0
e3 0 1 2 3 0 0 0 0
e4 0 0 0 0 0 0 0 0

e1 0 0 0 0 0 0 0 0
e3 0 0 0 0 0 0 0 0
e4 0 0 0 0 0 0 0 0

e1 0 0 0 0 0 0 0 0
e2 0 0 0 1 0 0 0 0
e4 0 0 0 0 0 0 0 0

e1 0 0 0 1 0 0 0 1
e2 0 0 0 0 0 0 1 2
e3 0 0 0 0 1 2 3 4

IntervalsFwdm(t):
(m=1)

e1 0 1 2 3 4 0 0 0

e2 0 0 0 0 0 0 0 0

e3 0 0 0 1 0 0 0 0

e4 0 0 0 1 2 3 4 5

numFws(t):

e1 0 2 2 2 1 0 0 0

e2 0 0 0 0 0 0 0 0

e3 0 0 0 1 0 0 0 0

e4 0 0 0 1 1 1 2 3

Fig. 1 a A set of 4 entities moving from left to right over 7 unit-time-intervals, i.e. over 8 time-steps.
b Illustrating the deﬁnition of the front-region as the disc-segment within bold lines. c The follow-
arrays of the four entities, where we use the front-region as depicted in b and α = β

Geoinformatica (2008) 12:497–528

503

constants during the rest of the paper, i.e. we will not carry them along as parameters
of functions or other notations.

At time-point tx, an entity e j is located at a position with coordinates xpos(e j, tx)
and ypos(e j, tx). As we do not have spatial information of an entity between two
time-steps we make the following assumption for the remainder of this paper.

Assumption 1 We assume that all entities move between two consecutive time-steps
with constant direction and constant velocity.

The same assumption has been used in earlier work [5]. It enables us to interpolate
the positions of entities between time-steps. Even though we have no bound on the
accuracy of this interpolation compared to the real positions of the entities, it appears
to be a reasonable approach when tackling our leadership problems, as long as the
sampling of points on the trajectories is sufﬁciently dense.

Suppose we are given an entity e j at time-point t with tx−1 < t < tx for tx ∈ Ts. We
say e j is heading into direction d where d is an angle in [0, 2π ) that is speciﬁed by
the line segment e j is moving along between time-steps tx−1 and tx. (If e j does not
move between tx−1 and tx then we deﬁne d to be the direction of the line segment e j
is moving along between the time-steps tx−2 and tx−1. If no such time-steps exist, then
we deﬁne d := 0.) The difference between two directions d1 and d2 is denoted by
||d1 − d2||, and it is an absolute value, i.e. it is an angle in [0, π ]. We declare the
direction of an entity at a time-step tx to be undeﬁned, because at time-steps an
entity might change its direction. However, the direction of an entity ei at a time-
step tx with respect to (tx−1, tx) is the direction ei is heading to at any time-point
in (tx−1, tx). Therefore, when considering time intervals with certain properties of
entities depending on direction, we implicitly exclude time-steps from those intervals
in the remainder of this paper.

Given an entity e and a time-point t (cid:5)∈ Ts, we deﬁne the front-region of e at time t in
the following way. Consider the disk C with radius r centred at (xpos(e, t), ypos(e, t)).
Furthermore, consider three line segments s1, s2 and s of length r, all having one end
point at (xpos(e, t), ypos(e, t)). Segment s points in the direction d that e is heading
to at time t, and segments s1 and s2 are the well deﬁned segments forming angles of α
2
and − α
2 with s, respectively. The part of the disk C that contains s and is bounded by
the segments s1 and s2 is the front-region, see Fig. 1b and 2. We denote this wedge-
shaped region by f ront(e) at time t. An entity e j is said to be in front of an entity ei at
time t (cid:5)∈ Ts if and only if e j ∈ f ront(ei) at time t.

Deﬁnition 2 Let di and d j be the directions of the entities ei and e j at time t (cid:5)∈ Ts,
respectively. Entity ei is said to follow entity e j at time t, iff e j ∈ f ront(ei) at time t
and ||di − d j|| ≤ β.

An entity e j is said to follow entity ei at time [tx, ty] for time-points tx, ty, if and

only if ei follows e j at time t for all time-points t ∈ [tx, ty] \ Ts.

Deﬁnition 3 An entity ei is said to be a leader at time [tx, ty] for time-points tx, ty, if
and only if ei does not follow anyone at time [tx, ty], and ei is followed by sufﬁciently
many entities at time [tx, ty]. If there is an entity that is a leader of at least m entities
for at least k time units, we have a leadership pattern.

504

Geoinformatica (2008) 12:497–528

Fig. 2 The front regions of ei and e j as wedges of edge length r and apex angle α. Entity e j is in
front of ei. The entities are heading into directions di and d j, respectively. If ||di − d j|| ≤ β then ei
follows e j

See Fig. 2 for an example of some notations.

Example 1 Consider the entities in Fig. 1a where we use a front-region as depicted
in Fig. 1b. We see that e2 is following e1 at time (t1, t5), e1 is not following any other
entity at time (t1, t3) and (t4, t7) and hence e1 is a leader of e2 at time (t1, t3) and (t4, t5).

In the remainder of this section, we consider two entities ei and e j and two
consecutive time-steps tx−1 and tx. The next lemma tells us that if we want to check
whether an entity is following any other entity during the entire interval (tx−1, tx), we
only have to check this at the two end points with respect to (tx−1, tx). The lemma is
rather intuitive and can be proven with very much the same ideas as in the proof of
Lemma 2 in Benkert et al. [5].

Lemma 1 Let ei and e j be two entities, and let tx−1 and tx be two consecutive time-steps.
If ei follows e j at time-points ty and tz with tx−1 < ty ≤ tz < tx then under Assumption 1,
ei follows e j at any time-point t ∈ [ty, tz].

Note that the lemma is also true for tx−1 = ty and tz = tx, however, the directions
of the entities at these time-points are with respect to (tx−1, tx). Therefore, the time
that an entity ei follows another entity e j between two consecutive time-steps tx−1
and tx is a single subinterval of [tx−1, tx], and such an interval can be computed in a
straightforward manner.

Lemma 2 Given two entities ei and e j and two time-steps tx−1 and tx, we can compute
in constant time the subinterval of [tx−1, tx] for which ei ∈ f ront(e j) and for which e j
follows ei, under Assumption 1.

3.2 Problem statement

A leadership pattern exists if there is an entity that is a leader of sufﬁciently many
entities over a long enough series of time-steps or time-points. Such a pattern is
characterised by two values m which is the size of the set of followers, and k
which is the length of a pattern. As mentioned in related work [5], [21] specifying
exactly which of the patterns should be reported is often a subject for discussion. For
instance, a leadership pattern of length exactly k + 1 (starting at time-step tx) implies
the existence of two leadership patterns of length exactly k (albeit ‘overlapping’, one
starting at time-step tx and the other starting at time-step tx+1). However, the pattern
of length k + 1 might be more interesting to report from a practical point of view.

Geoinformatica (2008) 12:497–528

505

Therefore, we consider the following problems where we assume that m and k are
constants.
• LP-report-all: For each entity e, report all time intervals where e is a leader of at

least m entities for at least k time units.

• LP-max-length: Compute the length of a longest leadership pattern of size at
least m, i.e. compute the largest value kmax such that there is an entity e that is a
leader of at least m entities for kmax time units.

• LP-max-size: Compute the size of a largest leadership pattern of length at least
k, i.e. compute the largest value mmax such that there is an entity e that is a leader
of mmax entities for at least k time units.

All these problems come in four different ﬂavours which are combinations of the
modelling of the time axis (discrete vs. continuous) and the consistency of the set of
followers (varying vs. non-varying).

More speciﬁcally, we consider each of the problems in a discrete case, where
patterns (and follow behaviour) can only start and end at the discrete time-steps. In
this discrete model, we can ensure that patterns exist, since we have the coordinates
of the entities for all time-steps. Unlike this, patterns can start and end at any time-
points in the continuous case. As discussed above, the data for the continuous case
relies on Assumption 1. Recall that we do not have any guarantee on the accuracy
of the linear interpolation between time-steps. This possible inaccuracy carries
over to a possible inaccuracy of the reported leadership patterns in the continuous
model. However, the continuous model is likely to become more important in the
future, when huge data sets over many time-steps are available, which might need
to be simpliﬁed in order to reduce storage space and processing time. Simpliﬁed
trajectories are likely to be non-synchronous, yet they can approximate the original
trajectory within a ﬁxed speciﬁed error bound (see e.g. Cao et al. [6]; Gudmundsson
et al. [19]).

The other variation concerns the set of followers. If there is a subset S of entities
such that for each time-point of the duration of the pattern all entities in S follow
the leader (there may be additional followers as well at some time-points), then we
call this a non-varying (subset) leadership pattern. In contrast to this, if we allow
the subset of followers to change from one unit-time-interval to the next during the
duration of the pattern (some entities may drop out, others may join in), then we
call such a pattern a varying (subset) leadership pattern, as long as always at least
m entities are following at each unit-time interval of the pattern. Depending on the
application a non-varying or a varying set of followers might be desirable.

4 Algorithms for the discrete case

In the discrete case, patterns can only start and end at time-steps. We ﬁrst describe
arrays storing information about the follow behaviour of the entities with respect to
a ﬁxed entity ei. Later, these arrays will be used to solve our leadership problems.

4.1 Getting ready—computing follow-arrays for an entity ei

For an entity ei to determine whether it is a leader at the time (tx, ty), we need to know
whether ei is not following any other entity and whether ei is followed by sufﬁciently

506

Geoinformatica (2008) 12:497–528

many entities at (tx, ty). We consider ei at this time as a potential leader, and we
compute a couple of follow-arrays called ‘IntervalsNotFwg(tx)’, ‘IntervalsFwg(tx, e j)’,
‘IntervalsFwdm(tx)’ and ‘NumFws(tx)’. The ﬁrst three arrays store the number of
consecutive unit-time-intervals that there is a certain follow-behaviour. In contrast
to this, the fourth array stores the number of entities with a certain follow-behaviour.
IntervalsNotFwg: (short for ‘the number of unit-time-intervals ei is not following
at tx’) The array IntervalsNotFwg(tx) is a one dimensional array storing nonnegative
integers. Such an integer for time-step tx speciﬁes for how many past consecutive
unit-time-intervals (the last one ending at tx) ei is not following any other entity.
That is, if IntervalsNotFwg(tx) = y, then ei is not following any other entity during
the time interval (tx−y, tx). To compute the values of the IntervalsNotFwg-array, we
use two nested loops. The outer loop runs from tx = t2, ..., tτ (we start at tx = 2 and
set IntervalsNotFwg(t1) := 0). The inner loop ranges over e j = e1, ..., en and e j (cid:5)= ei.
After each round of the inner loop we update IntervalsNotFwg(tx) according to
whether we found an entity e j such that ei follows e j at time (tx−1, tx). According
to Lemma 2 each such single test can be done in constant time.

IntervalsFwg: (short for ‘the number of unit-time-intervals ei is followed by e j at
tx’) The array IntervalsFwg(tx, e j) is a (τ × n − 1) matrix storing nonnegative integers
specifying for how many past consecutive unit-time-intervals (the last one ending
at tx) e j is following ei (with e j (cid:5)= ei). Filling the IntervalsFwg-array with the right
values can also be done with two nested loops, one outer loop for tx = t2, ..., tτ and
one inner loop for e j = e1, ..., en and e j (cid:5)= ei. Initially set IntervalsFwg(t1, e j) := 0.
We test whether e j follows ei at the unit-time-interval (tx−1, tx), and if so, we update
IntervalsFwg(tx, e j).

IntervalsFwdm: (short for ‘the number of unit-time-intervals ei has at least m
followers at tx’) The array IntervalsFwdm(tx) is a one-dimensional array storing
integers specifying for how many consecutive past unit-time-intervals (the last one
ending at tx) there are at least m entities following entity ei. These m entities can
be varying over time. Given the array IntervalsFwg, computing the IntervalsFwdm-
array can be done by looping over the IntervalsFwg array. We start at tx = 2 and
set IntervalsFwdm(t1) := 0. Now, we count in each column of IntervalsFwg (if we
imagine the array IntervalsFwg to be arranged to have τ columns and n − 1 rows)
the number of entities following ei at the current time-step. If this number is smaller
than m, we set IntervalsFwdm(tx) := 0, and if this number is at least m, we set
IntervalsFwdm(tx) := IntervalsFwdm(tx−1) + 1.

NumFws: (short for ‘the number of followers of ei at tx’) Another array is
NumFws(tx) which is a one-dimensional array storing integers specifying how many
entities are following entity ei at time (tx−1, tx). Again, counting in each row of
IntervalsFwg the number of entities following ei at the current time-step yields the
corresponding value of the NumFws array.

From the above discussion on the corresponding arrays, we conclude with the

following lemma.

Lemma 3 The IntervalsNotFwg, IntervalsFwg, IntervalsFwdm and NumFws-arrays
for an entity ei can be computed in O(nτ ) time and space.

Example 2 Consider the entities in Fig. 1a where we use a front-region as depicted
in Fig. 1b. Figure 1c shows four columns (one for each entity) of follow-arrays. To ﬁll

Geoinformatica (2008) 12:497–528

507

the arrays IntervalsNotFwg and IntervalsFwg, we need the trajectories and the front-
regions. Once that is done, the arrays IntervalsFwdm and NumFws can be computed
according to their deﬁnition.

4.2 Solving LP problems with a non-varying subset of followers

4.2.1 LP-report-all

In the discrete leadership version we assume that patterns can only start and end
at time-steps Ts = {t1, ..., tτ }. We use the arrays IntervalsNotFwg and IntervalsFwg,
and we combine their information to determine whether ei
is a leader of a
non-varying-subset of followers. To this end, we look for time-steps tx such
that IntervalsNotFwg(tx) ≥ k. For each such time-step tx, we inspect the array
IntervalsFwg(tx, e j) for j = 1, ..., n and j (cid:5)= i, and we count the number of times that
IntervalsFwg(tx, e j) ≥ k. Let m(k) denote this number. Now we can report ei as a
leader for every time-step tx for which m(k) ≥ m. As we only need to traverse our
arrays at most once, this can be done in O(nτ ) time.

Example 3 Let k = 1 and m = 2. Looking at the follow-arrays of entity e1 in Fig. 3,
we see (shaded region) that e1 is not following anyone, but is followed by 2 entities,
and this happens for at least k = 1 unit-time-intervals at the time-steps 2 and 3.
Hence, we would report two leadership-patterns with e1 as leader.

So far, we have seen that we can compute in O(nτ ) time and space at which time-
steps an entity ei is a leader. To ﬁnd all leadership patterns amongst a set of entities
we test any entity individually. As we only have to store one instance of each array
at a time we can conclude with the following lemma.

Lemma 4 Reporting all non-varying-subset leadership patterns of size at least m and
length at least k, amongst n trajectories over τ time-steps can be done in O(n2τ ) time
and O(nτ ) space.

4.2.2 LP-max-length

To compute the length of a longest pattern, where ei is the leader, we utilise a variable
kmax. Initially we set kmax := 0; we then loop once over all time-steps and at each
time-step we may modify kmax, and at the end kmax will be equal to the length of a
longest leadership pattern (for a speciﬁc m). Now, for each tx = t1, ..., tτ we check
whether IntervalsNotFwg(tx) > kmax and if so, we do the following. We inspect the
column of the array IntervalsFwg corresponding to tx. We traverse that column (i.e.

IntervalsNotFwg(t):

e1

2

3

4
5
1
8
0 1 2 0 1 2 3 0

7

6

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

e2 0 0 0 0 0 1 0 0

e3 0 0 0 0 0 0 0 0

e4 0 1 2 3 4 5 6 7

IntervalsFwg(e’,t):

e2 0 1 2 3 4 0 0 0
e3 0 1 2 3 0 0 0 0
e4 0 0 0 0 0 0 0 0

e1 0 0 0 0 0 0 0 0
e3 0 0 0 0 0 0 0 0
e4 0 0 0 0 0 0 0 0

e1 0 0 0 0 0 0 0 0
e2 0 0 0 1 0 0 0 0
e4 0 0 0 0 0 0 0 0

e1 0 0 0 1 0 0 0 1
e2 0 0 0 0 0 0 1 2
e3 0 0 0 0 1 2 3 4

Fig. 3 Follow-arrays with highlighted entries to mark patterns with a non-varying subset of followers

508

Geoinformatica (2008) 12:497–528

we loop for j = 1, ..., n,
j (cid:5)= i), and we count the number of entities e j for which
holds that IntervalsFwg(tx, e j) > kmax. Let this number be denoted by m(kmax). If
m(kmax) ≥ m, then we have at least m entities following ei for more than kmax unit-
time-intervals, and ei is not following anyone during that time. Hence, we increase
kmax by one and proceed with the next time-step tx+1. Note that we only increase
kmax by one as tx is the ﬁrst time-step for which m(kmax) ≥ m. As we only traverse
the entire arrays once, it takes O(nτ ) time to compute the longest pattern, where ei
is the leader.

The following concluding lemma might surprise, as the longest duration ﬂock
pattern is NP-hard to compute and cannot even be approximated within a factor
of τ 1−ε [20].

Lemma 5 The longest duration leadership pattern for a non-varying-subset of follow-
ers of size at least m can be computed in O(n2τ ) time and O(nτ ) space.

Example 4 Consider again Fig. 3. For m = 1, the above described method would ﬁnd
entity e4 to be the leader (of one entity, namely e3) for four consecutive unit-time-
intervals, which is the length of a longest pattern (for m = 1).

4.2.3 LP-max-size

It is also possible to compute the size of a largest non-varying-subset of follow-
ers that follows a leader for at least k unit-time-intervals. We utilise the arrays
IntervalsNotFwg and IntervalsFwg and a variable mmax, initially set to 0. We update
this variable whenever we ﬁnd a larger set of followers. That is, for tx := t1, ..., tτ , we
test if both IntervalsNotFwg(tx) ≥ k and m(k) > mmax, and if so, we set mmax := m(k),
where m(k) is deﬁned in the same way as m(kmax) in the section above. Hence, we
obtain the following lemma.

Lemma 6 The size of a largest non-varying-subset of entities that follow a leader for
at least k time-steps can be computed in O(n2τ ) time and O(nτ ) space.

Example 5 Consider again Fig. 3, and let k = 1. The algorithm above computes
mmax = 3 as entity e4 is a leader of 3 entities for k = 1 unit-time-interval at time-step 8.

4.3 Solving LP problems with a varying subset of followers

The variants of the problem of ﬁnding leadership patterns where the set of followers
can change during the leadership pattern can be solved in a similar way as proposed
in Section 4.2. To determine if an entity ei is a leader of a varying-subset of followers,
we use the follow-arrays IntervalsNotFwg(tx), IntervalsFwdm(tx) and NumFws(tx) as
described in Section 4.1.

4.3.1 LP-report-all

In the same ﬂavour as described above, we can ﬁnd out if ei is a leader. We look for
and report time-steps tx, such that IntervalsNotFwg(tx) ≥ k and IntervalsFwdm(tx) ≥
k. It is easy to see that reporting when ei is a leader can be done in O(nτ ) time.

Geoinformatica (2008) 12:497–528

509

Example 6 Let m = 1 and k = 2. Consider e1’s follow-arrays in the upper half of
Fig. 4. Above method reports one time-steps (namely time-step 3) where e1 is a
leader of at least m = 1 entities for at least k = 2 unit-time-intervals.

The complexity of ﬁnding all leadership patterns for n entities is summarised as

follows.

Lemma 7 Reporting all varying-subset leadership patterns amongst n trajectories over
τ time-steps can be done in O(n2τ ) time and O(nτ ) space.

4.3.2 LP-max-length

For computing the longest duration leadership pattern, we use the arrays
IntervalsNotFwg and IntervalsFwdm, and we search for the largest kmax (initially
kmax := 0) such that there is a time-step tx for which IntervalsNotFwg(tx) ≥ kmax and
IntervalsFwdm(tx) ≥ kmax. This can be done as follows. For tx = t1, ..., tτ , we check if
min{IntervalsNotFwg(tx), IntervalsFwdm(tx)} > kmax, and if so, we perform an update
kmax := min{IntervalsNotFwg(tx), IntervalsFwdm(tx)} and proceed with the next time-
step tx+1.

Lemma 8 The longest duration leadership pattern for a varying-subset of followers of
size at least m can be computed in O(n2τ ) time and O(nτ ) space.

Example 7 Looking at the follow-arrays in the upper half of Fig. 4, we see that e4 is a
leader of at least m = 1 entity for kmax = 5 unit-time-intervals (starting at time-step
3 and ending at time-step 8).

4.3.3 LP-max-size

If we would like to compute the size of a largest varying set of followers that follow ei
for at least k time-steps, we cannot use the array IntervalsFwdm directly as this array
contains information only for one speciﬁc m. However, an easy way is to use binary
search on m and recompute the IntervalsFwdm array for each value of m. This adds
an additional log n factor to the running time.

We propose a slightly different approach. By spending linear preprocessing time,
we can compute the minima of any substring of a sequence of numbers in O(1) time.
For more information on this range minimum query (RMQ), see e.g. [4]. Now, we use
the array NumFws and we look for at least k consecutive unit-time-intervals such that

IntervalsNotFwg(t):

e1

3

2

4
5
1
8
0 1 2 0 1 2 3 0

6

7

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

e2 0 0 0 0 0 1 0 0

e3 0 0 0 0 0 0 0 0

e4 0 1 2 3 4 5 6 7

IntervalsFwdm(t):
(m=1)

e1 0 1 2 3 4 0 0 0

e2 0 0 0 0 0 0 0 0

e3 0 0 0 1 0 0 0 0

e4 0 0 0 1 2 3 4 5

IntervalsNotFwg(t):

e1

0 1 2 0 1 2 3 0

e2 0 0 0 0 0 1 0 0

e3 0 0 0 0 0 0 0 0

e4 0 1 2 3 4 5 6 7

numFws(t):

e1 0 2 2 2 1 0 0 0

e2 0 0 0 0 0 0 0 0

e3 0 0 0 1 0 0 0 0

e4 0 0 0 1 1 1 2 3

Fig. 4 Follow-arrays with highlighted entries to mark patterns with a varying subset of followers

510

Geoinformatica (2008) 12:497–528

the minimum number of followers in the array NumFws during that time is as large
as possible and ei can be a leader. That is, we are looking for k consecutive unit-time-
intervals such that ei does not follow any other entity and for the largest minimum
(to be referred to as mmax) over all numbers of followers corresponding to those k
consecutive unit-time-intervals. All minima can be computed in O(τ ) time [4], hence,
mmax can be computed in linear time.

Lemma 9 The size of a largest varying-subset of entities that follow a leader for at least
k time-steps can be computed in O(n2τ ) time and O(nτ ) space.

Example 8 Consider the lower half of Fig. 4 and let k = 2. The above algorithm
computes mmax = 2 at time-step 3 for entity e1 and at time-steps 8 for entity e4.

5 Algorithms for the continuous case

In contrast to the discrete version of the leadership pattern, where a pattern can only
start or end at the given discrete time-steps, in the continuous version of the problem
a pattern can start and end at any point in time. As we do not have spatial information
of the entities between two consecutive time-steps we use Assumption 1 to tackle the
continuous version in this section. The main ideas are similar to the discrete case, but
instead of using arrays storing single numbers to represent follow-behaviour we will
use sets of time intervals. First, we describe how to compute them for a ﬁxed entity
ei and then we deﬁne two operations on (sets of) intervals. Later, these intervals and
operations are used to solve our leadership problems.

5.1 Getting ready—follow-intervals for an entity ei

, tya

) ∈ SetNotFwg with txa

Computing follow-intervals: A ﬁrst step is to compute a set SetNotFwg of
notfollowing-intervals representing when a ﬁxed entity ei is not following any other
entity e j. An interval I = (txa
≤ tya means that entity ei is
not following any other entity during the whole time interval I. Because entities
move on a straight line between two consecutive time-steps, cf. Assumption 1, ei can
be involved in at most two events that change its follow-behaviour (i.e. the events of
beginning or ending to follow) for each entity between two consecutive time-steps.
That is why the set SetNotFwg contains O(nτ ) intervals. We can compute this set
with two nested loops one over all time-steps, another over all entities. By Lemma 2,
this can be done in O(nτ ) time in total.

We also need information about which entities follow ei. This information is again
stored in a set SetFwd of intervals. An interval I = (txa
< tya
means that ei is followed by an entity, say e j, during the whole time interval I. Also
this set contains at most O(nτ ) intervals, as an entity can change its follow behaviour
with respect to ei at most twice between two consecutive time-steps. We can compute
this set with two nested loops one over all time-steps, another over all entities. By
Lemma 2, this can be done in O(nτ ) time in total.

) ∈ SetFwd with txa

, tya

Both sets of intervals can be computed in O(nτ ) time. For the subsequent meth-
ods, however, we need the start- and end points of the intervals in non-decreasing

Geoinformatica (2008) 12:497–528

511

order and that the intervals are maximal. Obtaining the sets such that the start-
and end points are sorted can be done in O(nτ log n) time in the following way. For
each set we use two nested loops. The outer loop ﬁxes an entity and the inner loop
ranges over the time-steps. In that way it is easy to compute the intervals as maximal
intervals. Whenever we compute start- or end points of an interval we can put them
into τ − 1 buckets, namely one for each unit-time-interval, i.e. pair of consecutive
time-steps. As we can have at most O(n) start- or end points in each bucket, we can
sort all of them in all buckets in O(nτ log n) time. Combining the sorted sequences of
each bucket results in a sorted sequence of all start- and end points.

Lemma 10 In O(nτ log n) time and O(nτ ) space, the sets SetNotFwg and SetFwd for
an entity ei can be computed such that all the start- and end points of the intervals in
each set are output in non-decreasing order.

Next, we deﬁne operations that take and return a set of intervals as input and
output. We also brieﬂy describe how to compute these operations, if the set of
intervals is given along with the start- and end points in sorted order.

Combining intervals: We call the ﬁrst operation under consideration interval-
combination denoted as icx(S), where S is a set of intervals of R. The operation
outputs a set of non-intersecting intervals. Every point in R that is contained in at
least x intervals of the input-set S will be in an interval of the output-set. Also, for
every point that is contained in an interval of the output-set, there are at least x
intervals in the input-set that all contain that point, see Fig. 5. Note that ic1(S) is the
union of all intervals in S and ic|S|(S) is the intersection of all intervals in S. Let S
be a set of intervals where the start- and end points are given in sorted order. The
operation icx(S) can be computed by a parallel scan over the sorted start- and end
points and keeping track of how many intervals are currently ‘active’.

Lemma 11 Suppose S is a set of intervals. If the start- and end points of the intervals
in S are given in non-decreasing order, then we can compute icx(S) in O(|S|) time.

Clipping intervals: We also deﬁne another operation, which modiﬁes single inter-
vals. For an interval I = {txa
}, we cut or clip a part of length k at the beginning
of I. If the resulting interval I(cid:7) is non-empty, then that interval I(cid:7) is the result of the
operation.

, txb

This operation can also be applied to all intervals of an entire set (cf. Fig. 6), such

that the order of the start- and end points of the intervals remains stable.

set S of intervals:

ic1(S):
ic2(S):
ic3(S):

Fig. 5 The set S of intervals on the real line and the results after applying the icx operation for
x ∈ {1, 2, 3}. Note that icx(S) = ∅ for all x ≥ 4 as the intersection of any 4 intervals in S is empty

512

Geoinformatica (2008) 12:497–528

set S of intervals:

clipk

(S):

(         )

Fig. 6 The set S of intervals on the real line and the results after applying the clipk operation. For
the clipk operation, the length of the interval in parentheses determines k

Lemma 12 Let be given a set S of intervals, where the start- and end points of the
intervals in S are given in non-decreasing order. We can compute S(cid:7) := {I(cid:7) | I(cid:7) =
(I), I ∈ S} and output the start- and end points of all intervals in S(cid:7) in non-
clipk
decreasing order in O(|S|) time.

5.2 Solving LP problems with a non-varying subset of followers

5.2.1 LP-report-all

We ﬁrst look at the non-varying-subset version. In the previous section we have seen
that we can compute the interval-set SetFwd in O(nτ log n) time, where an interval in
this set means that an entity follows ei for the time of the interval. Now, we are going
to modify the intervals in the set SetFwd. For each interval I = {txa
} ∈ SetFwd,
we apply the operation clipk to obtain a set SetFwdclipped := {I(cid:7) | I(cid:7) = clipk
(I), I ∈
SetFwd}. Note that SetFwdclipped (see Fig. 7) only contains intervals whose originals
had length at least k. The meaning of an interval I(cid:7) ∈ SetFwdclipped is that there is
an entity such that at each time-point t ∈ I(cid:7) this entity has already followed ei for at
least k time units (which is not necessarily the same as k unit-time intervals). The
set SetFwdclipped can be computed in linear time with respect to the size of SetFwd,
and this can be implemented such that the order of the (start- and end points of the)
intervals remains stable.

, txb

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

e2

e1
e3
e4

e3

e1
e2
e4

e4

e1
e2
e3

setNotFwg:

setFwgclipped:

e1

e2
e3
e4

ic1(setFwgclipped):
ic2(setFwgclipped):
ic3(setFwgclipped):

results for m=1:
results for m=2:
results for m=3:

Fig. 7 Illustration of clipping and combining the intervals, where the intervals represent the follow-
behaviour of the entities in Fig. 1. The result-intervals are shown for different values of m

Geoinformatica (2008) 12:497–528

513

We also clip the intervals of the set SetNotFwg to obtain a set SetNotFwgclipped :=
{I(cid:7) | I(cid:7) = clipk
(I), I ∈ SetNotFwg} (see Fig. 7). For each time-point in an interval
in SetNotFwgclipped, we have that ei is not following any other entity for at least k
time units.

The next step is to compute yet another set S of intervals as an interim result
using one of the operations introduced in Section 5.1, S := icm(SetFwdclipped). For
any time-point in an interval in S there are at least m entities following ei, where
each of those entities already followed ei for at least k time units. Finally, we combine
the information represented by S and SetNotFwgclipped. What we need is similar to a
logical ‘and’ between intervals of those two sets, and this can be done by applying the
icx again to obtain a set of result-intervals, result := ic2(S ∪ SetNotFwgclipped). Note
that the start- and end points of the set S ∪ SetNotFwgclipped can be sorted in linear
time if the start- and end points of S and SetNotFwgclipped are sorted. The set result
contains all intervals for which ei is a leader of at least m entities for at least k time
units. If we would like to report the leadership patterns of all entities, we apply the
above method to each entity. Hence, we can conclude with the following lemma.

Lemma 13 Let be given n trajectories over τ time-steps. Reporting all time intervals
where there is an entity a leader of a non-varying subset of at least m entities for at least
k time units, can be done in O(n2τ log n) time and O(nτ ) space.

5.2.2 LP-max-size

We can use the sets SetNotFwgclipped and SetFwdclipped, where the intervals are given
in non-decreasing order, to ﬁnd the maximum mmax for which ei is a leader of a non-
varying set of mmax entities for at least k time units. To that end, we do not collapse
the set SetFwdclipped into a set S as described above, but we utilise a parallel scan over
the intervals in SetNotFwgclipped and SetFwdclipped.

By a parallel scan we mean moving an imaginary vertical line over the horizontally
arranged intervals, stopping at certain points and performing certain actions. In our
case the points where we stop are the start- and end points of the intervals. For any
position of the scan-line we say an interval I is active, if the scan-line (cid:8) intersects
interval I.

During the parallel scan, we keep track of the number of active intervals in
SetFwdclipped, where the intervals in SetNotFwgclipped are used as a mask (see Fig. 8).
All this can be done in O(nτ ) time.

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

setNotFwg:

:
setFwgclipped

e1

e2
e3
e4

e2

e1
e3
e4

e3

e1
e2
e4

e4

e1
e2
e3

2

0

0

1 2 3

Fig. 8 Illustrating the parallel scan approach. The shaded region indicates how the SetNotFwg
intervals are used as a mask. The numbers indicate the number of active SetFwd intervals

514

Geoinformatica (2008) 12:497–528

Lemma 14 Let be given n trajectories over τ time-steps. Computing the maximum size
of a non-varying subset of followers which follow a leader for at least k time units, can
be done in O(n2τ log n) time and O(nτ ) space.

5.2.3 LP-max-length

A method similar to the one presented above cannot be used directly, as the sets
of intervals are computed for speciﬁed values of k. We could use binary search on
k, however, this would add another log τ factor to the running time. The method
described in this section also builds upon the sets SetNotFwg and SetFwd of intervals,
introduced in Section 5.1. It ﬁnds the largest kmax, such that there is a non-varying
subset of at least m entities following entity ei for kmax time-units. However, it can
also be used to report patterns where ei is a leader of at least m non-varying followers
for at least k time-steps. We do this by performing a parallel scan over the sets of
intervals, assuming they are given such that the start- and end points of the intervals
are in non-decreasing order.

During the parallel scan we keep track of the active intervals in SetNotFwg. Note
that only one interval I ∈ SetNotFwg can be active at a time. By keeping a pointer p1
to I, we know for every time-point t, whether ei is following any other entity. If ei is
following any other entity, then there is no interval in SetNotFwg active at time t (and
p1 becomes a null-pointer). On the other hand, if there is an interval I ∈ SetNotFwg
active at t, then we can compute for how long ei is not following any other entity.

We also keep track of how many entities follow ei and for how long. To this end, let
t be a time-point during the parallel scan. Let A ⊆ SetFwd be the set of all intervals
in SetFwd that are active at time t. We will not maintain A, but only a variable m(cid:7)
with m(cid:7) = |A| (initially m(cid:7) := 0). Furthermore, we will maintain a pointer p2 to the
interval in A with the m-th largest end point. If A contains less than m intervals, then
p2 points to some interval. (As we will not use pointer p2 if A contains less than m
intervals it is not important where p2 points to in that case.)

Before the parallel scan, we initialise kmax := 0, and after the parallel scan kmax
will be the length of the longest leadership pattern with ei as leader of a non-varying
set of at least m entities. We also introduce an artiﬁcial interval which starts and ends
before any other interval starts and we initialise p2 to point to that interval. This
interval is introduced merely to have pointer p2 well initialised. The parallel scan
does not take this interval into consideration. As mentioned above the points where
we stop with the scan-line are the start- and end points of the intervals, and if two
such points have the same time, we process them one after the other, as if one was
inﬁnitesimally later than the other. By maintaining all invariants it is easy to see that
for every position of the scan-line with corresponding time t, we can check if there
are at least m entities following ei, i.e. if m(cid:7) ≥ m. In the case that there are at least m
followers of ei, we also can determine for how long in the future all these entities will
follow ei, by using the pointer p2. Furthermore, we can check if ei is following any
other entity (by using p1), and if not for how long in the future ei will not follow any
other entity. Therefore, we can determine whether there is a leadership pattern, with
ei as leader of a non-varying set of at least m entities, and if there is such a pattern, we
can also determine its length k(cid:7). If k(cid:7) > kmax then we perform an update kmax := k(cid:7).
By doing this parallel scan approach for each entity, we can compute the overall

longest duration leadership pattern.

Geoinformatica (2008) 12:497–528

515

Lemma 15 Let be given n trajectories over τ time-steps. Computing the maximum
length of a leadership pattern with a non-varying subset of followers of size at least m,
can be done in O(n2τ log n) time and O(nτ ) space.

5.3 Solving LP problems with a varying subset of followers

5.3.1 LP-report-all

After considering the case for the non-varying subset in Section 5.2.1, the case for
a varying subset is rather easy. Here, we do not require that all entities follow
ei for k time-units. Hence, with the terminology as used before we compute a
set S := icm(SetFwd). For any time-point in an interval in S there are at least m
entities following ei. As ei still has to be followed for at least k time-units, we clip
all intervals in S to obtain S(cid:7) := {I(cid:7) | I(cid:7) = clipk
(I), I ∈ S}. As before, our last step
is to combine S(cid:7) and SetNotFwgclipped to obtain the set of result-intervals, result :=
ic2(S(cid:7) ∪ SetNotFwgclipped).

Lemma 16 Let be given n trajectories over τ time-steps. Reporting all time intervals
where there is an entity a leader of a varying subset of at least m entities for at least k
time units, can be done in O(n2τ log n) time and O(nτ ) space.

5.3.2 LP-max-size

In this case, we can use the approach mentioned in Section 4.3.3, where we spend
additional time for binary search on m to ﬁnd mmax.

Lemma 17 Let be given n trajectories over τ time-steps. Computing the maximum size
of a varying subset of followers which follow a leader for at least k time units, can be
done O(n2τ log n) time and O(nτ ) space.

5.3.3 LP-max-length

To ﬁnd the length of a longest duration leadership pattern of a varying set of at least
m entities, we can use a similar approach as in Section 5.3.1. We also compute a set
S := icm(SetFwd), such that for each time-point in an interval I ∈ S, we know that
there are at least m followers of ei. To combine this with the information when ei
is not following any other entity, we apply the operation icx once again to obtain
result := ic2(S ∪ SetNotFwg). Now, for any interval in result it holds that ei is not
following any other entity, and also that ei is followed by at least m entities. Searching
for the length of the longest interval in result solves the problem at hand for entity ei.

Lemma 18 Let be given n trajectories over τ time-steps. Computing the maximum
length of a leadership pattern with a varying subset of followers of size at least m, can
be done O(n2τ log n) time and O(nτ ) space.

516

Geoinformatica (2008) 12:497–528

5.4 Hardness in the continuous case

It is likely that every algorithm for the continuous version of the leadership problem
that detects leadership patterns between two consecutive time-steps in a set of
n trajectories requires (cid:9)(n2) time in the worst case. This can be shown by a
transformation from the problem Point-on-3-lines, which was proven to be 3-sum-
hard [18]. There is no subquadratic time algorithm known for those problems. For a
weak model of computation a lower bound of (cid:9)(n2) for those problems exists [15].
We can conclude with the following lemma (see Andersson et al. [3] for more details).

Lemma 19 Finding continuous leadership patterns between two consecutive time-steps
in a set of trajectories is 3-sum-hard.

6 Experimental evaluation

This section is devoted to reporting the experimental results. The algorithms were
implemented in Java1 and all experiments were performed on a Linux operated PC
with an Intel 3.6 GHz processor and 2 GB of main memory.

6.1 Input data

All input ﬁles were generated artiﬁcially with NetLogo [62]. More speciﬁcally, we
modiﬁed NetLogo’s Flocking Model [61] such that entities do not wrap around the
world-borders, but will be repulsed smoothly from walls, see Fig. 9. Furthermore, we
added some code for moderate random changes in an entity’s direction and saving
the coordinates into a ﬁle. There are many parameters to modify the behaviour of
the entities and thus also to modify how many ﬂocks and leadership-patterns are
created. However, we have no direct control over the exact number or length or size
of patterns.

We generated ﬁles with variable number of entities (128–4096), two different sizes
of the underlying universe U (i.e. coordinate space 512 × 512 and 1024 × 1024) and
two different characteristics CH (i.e. CH = u and CH = c) of the entity distribution.
CH = u means that the parameters of the Flocking Model were chosen such that the
entities are more uniformly distributed, i.e. only small clusters emerge. Flocks (and
thus leadership patterns) still exist but their size and length are likely to be smaller
than those of the other characteristic. CH = c means that the parameters of the
Flocking Model were chosen such that the entities form few but rather large clusters,
and hence, the ﬂocks tend to contain more entities and have a longer duration. The
number of time-steps is τ = 1000.

6.2 Methods

We performed experiments with two variants of our algorithms for the discrete
case. The ﬁrst one is a straight forward implementation of the method described

1Java was chosen because this increases the platform independence and it makes it easier to integrate
the code into an existing larger framework.

Geoinformatica (2008) 12:497–528

517

Fig. 9 This screenshot of
NetLogo’s modiﬁed Flocking
model shows the trajectories of
32 entities in a universe with
side lengths 128 × 128, run for
100 time-steps

in Section 4. This method contains (among others) two nested loops ranging over
all entities. The disadvantage from a practical point of view is that when looking
for entities that might be in a front-region, then also entities that are too far away
will be considered. Therefore, our second method tries to overcome this drawback
by dividing the underlying plane into buckets (squares of side length r). Now when
looking for entities that might be in a front-region, only those entities will be
considered that are in the nine neighbouring buckets (including the bucket at the
centre). Note that for each of our leadership problems, all methods always compute
all arrays from scratch. Especially the arrays IntervalsNotFwg and IntervalsFwg could
be used three times after computing them once. For an easier comparison however,
we refrained from doing so.

6.3 Results

Tables 1 and 2 show the results of our algorithms for m = 10, k = 20, r = 20, α = π
and β = π
2 . From our point of view the running times and their asymptotic behaviour
are much more interesting than for example the exact number of patterns found as
we deal with artiﬁcial data. Nevertheless, in Table 1 we can see how many entities
have been leaders (leaders), the number of leadership patterns found (report-all),
the length of a longest duration pattern (max-length) and the number of entities in
a pattern with most followers (max-size). Note that patterns with length > k will be
reported multiple times as patterns of length k.

We observed that the vast majority of the running time is spent on computing the
arrays IntervalsNotFwg and IntervalsFwg (which can be done in O(n2τ ) time). Once
these two arrays are computed, computing more arrays and/or extracting information
to solve the leadership problem is very efﬁcient (linear time). Therefore, our methods

518

Geoinformatica (2008) 12:497–528

3
2

1
7

8
3
2

8
0
2

9
1
4

9
5
9

4

8

6
2

3
8
1

4
2
2

4
2
3

4

7

3
1

1
2

5
2

7
3

3

5

7

0
1

7
1

4
2

e
z
i
s
-
x
a
m

h
t
g
n
e
l
-
x
a
m

l
l
a
-
t
r
o
p
e
r

e
z
i
s
-
x
a
m

h
t
g
n
e
l
-
x
a
m

l
l
a
-
t
r
o
p
e
r

s
r
e
d
a
e
l

1
4

1
7

8
6

6
6

2
7

8
7

0

2

0
6

3
7

0

8
7

3
1

1
4

2
3

0
4

4
3

0

0

0

0
2

0
4

2
4

1
0
1

1
6
1

9
8
3

0
2
5

2
4
1
1

2
2
0
1

1
4
5
1

0

0

3
4
6

1
9
5
1

3
3
8
2

9
9
2
4

0

0

4
5

3
7

7
8
1

9
0
1

0

0

0

2

2
5
1

9
7
2

g
n
i
y
r
a
v

s
r
e
d
a
e
l

2

2
1

3
1

1
3

6
3

0
5

0

0

7
2

7
4

7
9

0

0

6

9

0

0

0

1

9
2

9
1

0
2

9
4

7
1
1

3
2

6
6

0
0
2

7
9
1

4
8
3

2
1
8

4

8

6
2

6
6
1

9
1
2

7
5
2

3

7

0
1

3
1

5
1

4
1

3

5

7

0
1

1
1

4
2

7
3

6
5

4
4

6
4

7
5

5
5

0

2

6
4

3
5

7
4

9
5

0

9

5
2

4
2

4
3

9
2

0

0

0

0
2

5
2

2
4

9
8

1
1
2

9
2
3

6
7
6

9
8
6

6
6
9

0

0

0
6
3

4
5
9

6
3
5
1

1
2
5
2

0

0

7

5
1

0
4

6
3

0

0

0

1

6
2

7
8

2

0
1

1
1

7
2

3
3

4
4

0

0

9
1

6
3

0
8

8
9

0

0

1

5

8

6

0

0

0

1

6

6
1

c

c

c

c

c

c

c

c

c

c

c

c

u

u

u

u

u

u

u

u

u

u

u

u

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

g
n
i
y
r
a
v
-
n
o
n

H
C

U

n

s
d
o
h
t
e
m

r
u
o
f
o
s
e
u
l
a
v

g
n
i
t
l
u
s
e
R

1

e
l
b
a
T

Geoinformatica (2008) 12:497–528

519

g
n
i
y
r
a
v

6
8
.
2

9
6
.
4
1

5
1
.
9
1
1

7
4
.
1
2
2

9
1
.
9
9
0
1

9
5
.
1
5
6
5

4
2
.
1

3
6
.
3

1
0
.
5
1

7
2
.
9
2
1

7
5
.
5
7
3

0
0
.
5
0
7
1

2
5
.
1

7
6
.
4

1
9
.
5
1

2
5
.
4
5

4
7
.
4
3
2

9
3
.
7
3
0
1

4
0
.
1

1
0
.
3

0
8
.
8

6
9
.
7
2

4
2
.
5
9

2
8
.
1
8
3

s
t
e
k
c
u
b
h
t
i

w

g
n
i
y
r
a
v
-
n
o
n

s
t
e
k
c
u
b
t
u
o
h
t
i

w

g
n
i
y
r
a
v
-
n
o
n

H
C

.

m
e
l
b
o
r
p

l
l
a
-
t
r
o
p
e
r

e
h
t

r
o
f

s
d
o
h
t
e
m

r
u
o
f
o
s
e
m

i
t

g
n
i
n
n
u
R

2

e
l
b
a
T

5
3
.
2

8
5
.
2
1

4
7
.
2
0
1

5
8
.
1
9
1

4
3
.
2
7
9

3
5
.
0
5
2
5

1
9
.
0

3
8
.
2

0
0
.
2
1

6
0
.
0
1
1

3
4
.
4
2
3

0
7
.
7
7
4
1

3
3
.
1

4
7
.
3

8
8
.
2
1

4
5
.
7
4

9
9
.
1
2
2

2
2
.
4
2
0
1

7
8
.
0

8
2
.
2

7
4
.
7

7
6
.
4
2

0
0
.
9
8

0
2
.
0
5
3

g
n
i
y
r
a
v

6
5
.
9

9
8
.
1
4

8
8
.
2
1
2

3
8
.
3
8
6

6
2
.
7
5
4
3

9
6
.
6
4
0
5
1

7
4
.
8

2
8
.
3
3

3
1
.
9
3
1

9
2
.
2
2
6

7
0
.
5
7
8
2

8
1
.
0
0
3
1
1

8
0
.
8

6
9
.
2
3

6
5
.
0
3
1

2
1
.
3
2
5

4
6
.
8
7
1
2

1
7
.
8
7
9
0
1

6
8
.
7

9
7
.
2
3

1
2
.
8
2
1

1
9
.
5
1
5

6
0
.
1
5
2
2

4
0
.
5
9
2
1
1

4
4
.
9

1
9
.
0
4

3
5
.
3
0
2

1
0
.
4
6
6

7
1
.
3
9
3
3

1
8
.
3
0
9
4
1

9
1
.
8

9
7
.
2
3

7
9
.
2
3
1

4
2
.
5
9
5

2
1
.
9
0
8
2

8
2
.
3
4
1
1
1

7
3
.
8

3
7
.
2
3

6
1
.
9
2
1

9
7
.
9
2
5

2
4
.
4
8
1
2

2
4
.
6
2
1
1
1

5
8
.
7

5
4
.
1
3

2
9
.
7
2
1

9
5
.
2
1
5

7
7
.
8
6
2
2

3
6
.
1
0
2
1
1

c

c

c

c

c

c

c

c

c

c

c

c

u

u

u

u

u

u

u

u

u

u

u

u

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
2
1
5

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

2
4
2
0
1

U

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

8
2
1

6
5
2

2
1
5

4
2
0
1

8
4
0
2

6
9
0
4

n

s
d
n
o
c
e
s
n
i
e
r
a

s
e
m

i
t
d
e
t
r
o
p
e
R

520

Geoinformatica (2008) 12:497–528

for the three different leadership problems result almost always in the same running
times (they differ on average less than three percent), as they compute all arrays
from scratch. Hence, Table 2 depicts the running times of our methods only for the
report-all leadership problem.

6.4 Observations

6.4.1 Non-varying vs. varying

As we could expect running times for the patterns with a varying subset of followers
are often higher, as one more array is computed for the ‘varying’ problems. However,
this increase is very marginal compared to other inﬂuencing factors. We can also
observe that the values for the ‘varying’ patterns are at least as big (sometimes
slightly larger) as for the ‘non-varying’ patterns. This is because a non-varying pattern
is also a varying pattern by deﬁnition.

6.4.2 Without buckets vs. with buckets

The approach to subdivide the space into buckets does not inﬂuence the reported
values of our methods, however, it can have an impressive impact on the running
times (see Figs. 10 and 11). Depending on the input characteristics, we can observe
speed-up factors between 2 and 32. The running time of the methods without
‘buckets’ is clearly quadratic in the number of entities. An asymptotic behaviour of

CH=c, without buckets
CH=c, with buckets
CH=u, without buckets
CH=u, with buckets

16000

 14000

 12000

 10000

 8000

 6000

 4000

 2000

 0

 0

 512

 1024

 1536

 2048

 2560

 3072

 3584

 4096

Fig. 10 Running times depending on input size for non-varying report-all patterns for U = 5122

Geoinformatica (2008) 12:497–528

521

U=512, without buckets
U=512, with buckets
U=1024, without buckets
U=1024, with buckets

12000

 10000

 8000

 6000

 4000

 2000

 0

 0

 512

 1024

 1536

 2048

 2560

 3072

 3584

 4096

Fig. 11 Running times depending on input size for non-varying report-all patterns for CH = u

the methods with ‘buckets’ is more difﬁcult to identify, but note that also this method
has a quadratic worst case running time.

6.4.3 CH = u vs. CH = c

Almost always the input ﬁles with characteristic CH = c contain more patterns,
longer patterns and larger patterns, which was expected as those ﬁles are much more
likely to contain more and larger ﬂocks. Hence, the input ﬁles with CH = u result
in smaller running times (see also Fig. 10). Interestingly these characteristics also
indicate that the ‘bucket’ approach for speeding-up the computations has its limi-
tations, because the speed-up factor of the ‘buckets’ method is strongly inﬂuenced
by the characteristics. For CH = u, we observe speed-up factors around between
5 and 11 for the instances with U = 5122, and between 7 and 32 for the instances
with U = 10242. On the other hand, for CH = c, the speed-up factors are between 2
and 4 for the instances with U = 5122, and between 5 and 11 for the instances with
U = 10242. This can be explained by noting that the ﬁles with characteristic CH = c
contain more and bigger ﬂocks, and hence it is more likely that our algorithms
encounter neighbouring buckets that are ﬁlled with more entities.

6.4.4 U = 5122 vs. U = 10242

The difference between the universe with U = 5122 and U = 10242 is that the former
is much denser when ﬁlled with the same number of entities. As a result, in the
larger universe (U = 10242) less and smaller patterns exist. Also the running times

522

Geoinformatica (2008) 12:497–528

are affected (see Fig. 11). The methods with buckets run faster on instances with a
larger universe, because we have more buckets and therefore, buckets are likely to
contain less entities on average.

7 Discussion

The analysis of the interrelations of moving individuals has in the last 5 years
attracted increasing attention, as a general reaction to the striking need for more
powerful methods for surveillance and geospatial intelligence. Geographical infor-
mation scientists are commissioned to develop methods that detect the expected
and discover the unexpected from massive streams of disparate data, potentially
originating from various sources [58]. Such methods need to be scalable, ﬂexible and
reliable. This section discusses our leadership approach with respect to these three
properties and discusses the found algorithm running times.

Balancing the matching of formalised movement patterns (such as the presented
leadership) with the inferring of unexpected space-time behaviours from visualised
space-time paths, we argue that the former copes much better with increasing data
sets. Whereas inferring form visualisation might be adequate for the analysis of
individual events of interest [30], keeping track of hundreds of individuals cruising
in the space-time aquarium is literally impossible [34]. By contrast, when detecting
movement patterns such as ﬂock or leadership, the number of entities n is just a
performance factor but not an obfuscation factor.

Approaches detecting leader and follower relationships using pair-wise cross-
correlation of trajectories suffer from their intrinsic limitation to very small numbers
of involved entities. Thus, lead-follow events in Shirabe [54], for example, can only be
detected for pairs of individuals at a time. Our leadership pattern, in contrast, allows
individuals to lead groups of followers. Since they operate on local-instantaneous
events they can be detected in trajectories of variable lengths, as long as there
is certain temporal overlap. Furthermore the approach in Shirabe [54] has rather
demanding constraints with respect to the analysed data set. It requires trajectories
of equal length and strongly synchronous sampling. Even though we assume the
input data to have the same characteristics, our algorithms for the continuous case
can be easily applied to data without a synchronised sampling. The running times
for sorting the sets of intervals for an entity would slightly increase, however, from
O(nτ log n) to O(nτ log nτ ). We argue that our leadership algorithms are thus ﬂexible
and applicable to diverse data from various sources.

Movement patterns that are deﬁned from the geometric arrangement of the
involved entities (e.g. leadership), are more reliable than movement patterns that
base on the intermediate step of an analysis matrix, as do the REMO patterns depend
on an analysis matrix in Laube et al. [37]. The deterministic discretisation of the
movement descriptors in eight cardinal direction classes introduces edge effects. An
example shall illustrate such edge effects. Let 22.5◦ be one threshold of the discrete
movement azimuth class ‘North’. Let furthermore the pattern under study be a ﬂock
pattern of four entities moving in the same direction at any time t. Why should a set
of entities S1 with azimuths [21◦, 22◦, 22◦, 21◦] be a ﬂock when another set S2 with
azimuths [22◦, 23◦, 23◦, 22◦] is not? A deﬁnition requiring the entities to have a mean
azimuth and some variance (e.g. ±22.5◦) is a much more natural and thus reliable

Geoinformatica (2008) 12:497–528

523

deﬁnition of ﬂock. The deﬁnition of leadership in this paper follows for exactly the
same reasons the road of using a geometrical arrangement instead of scanning a
discretised matrix.

When comparing the running times in this article with those reported in Benkert
et al. [5], we observe that the running times in the present work are much higher. This
is because the used methods are different. The methods in Benkert et al. [5] are faster
but only report patterns of a speciﬁed length with a speciﬁed start- and end-time. The
methods in this paper, however, are more ﬂexible. Once the arrays IntervalsNotFwg
and IntervalsFwg are computed we can very efﬁciently use them to report patterns
of different lengths, and with different start- and end-times. We also developed and
implemented an approximation algorithm and performed initial experiments. They
show a better asymptotic behaviour of the approximation algorithm. However, the
constant factors seem to be too large for practical purposes, because for our test-
ﬁles the exact algorithms always outperformed the approximation algorithm. More
details on this algorithm can be found in Andersson et al. [3].

8 Conclusions and outlook

Movement patterns detect structure in large tracking data sets and are thus key to
a better understanding of the interactions amongst moving agents. We provide a
formal description of the pattern ‘leadership’ and subsequently algorithms for its
efﬁcient detection. ‘Leadership’ describes the event or process of one individual
in front leading the movement of a group. Our approach is inspired by movement
patterns documented in the animal behaviour and behavioural ecology literature.

Our experiments give indications which input-size can be processed within a
reasonable amount of time, and they have shown that we are able to efﬁciently
report leadership patterns. The resulting running times match the theoretical bounds,
however for improved methods (with buckets) the running times strongly depend on
the characteristics of the instance.

In this article we assumed that all the trajectories ﬁt into main memory. If this
is not the case then we would have to develop I/O-efﬁcient algorithms or use
spatio-temporal index structures. Both these techniques would probably improve
performance if the input does not ﬁt into main memory. However, this is an extension
that would require much more future research.

One drawback of the given deﬁnition of leadership is that a leader has to be
in the front region of all followers. For instance, for a very big ﬂock of gnus this
deﬁnition might not be applicable, as some gnus at the end of the ﬂock are too far
away from the front-line to be able to see leading animals. Hence, one direction for
future research could be the deﬁnition and analysis of cascading leaders or followers,
where a cascading follower is a follower of a leader or a follower of another cascading
follower.

For the many ﬁelds interested in movement, the overall challenge lies in relating
movement patterns with the surrounding environment, in order to understand
where, when and ultimately why the agents move the way they do. Conceptualising
detectable movement patterns and the development of algorithms for their detection
is a ﬁrst important step towards this ambitious long-term goal. With its traditional
spatial awareness, computational geometry can make immense contributions to the

524

Geoinformatica (2008) 12:497–528

theoretical framework underlying movement analysis in geographical information
science, behavioural ecology or surveillance and security analysis.

Acknowledgements Patrick Laube was partially supported by ARC Discovery grant
DPDP0662906. National ICT Australia is funded through the Australian Government’s Backing
Australia’s Ability initiative, in part through the Australian Research Council. The authors wish
to thank Karin Schütz, AgResearch Ruakura, Hamilton, New Zealand for valuable comments on
animal movement patterns, Bojan Djordjevic for implementing the algorithms and the anonymous
reviewers of this and earlier versions of this article.

References

1. P.K. Agarwal, L. Arge, and J. Erickson. “Indexing moving points,” Journal of Computer and

System Sciences, Vol. 66(1):207–243, 2003.

2. G. Al-Naymat, S. Chawla, and J. Gudmundsson. “Dimensionality reduction for long duration
and complex spatio-temporal queries,” in Proc. of the 22nd ACM Symposium on Applied
Computing, pp. 393–397, ACM, 2007.

3. M. Andersson, J. Gudmundsson, P. Laube, and T. Wolle. Reporting leaders and followers
among trajectories of moving point objects. Technical Report PA006075, National ICT Australia,
2006. http://www.nicta.com.au, Extended abstract in Proceedings of the 22nd ACM Symposium
on Applied Computing, pp. 3–7, ACM, 2007.

4. M.A. Bender and M. Farach-Colton. “The LCA problem revisited,” in LATIN ’00: Proc. of the
4th Latin American Symposium on Theoretical Informatics, volume 1776 of Lecture Notes In
Computer Science, London, UK, pp. 88–94, Springer-Verlag, 2000.

5. M. Benkert, J. Gudmundsson, F. Hübner, and T. Wolle. “Reporting ﬂock patterns,” in Proc.
of the 14th European Symposium on Algorithms (ESA 2006), volume 4168 of Lecture Notes in
Computer Science, pp. 660–671, Springer, 2006.

6. H. Cao, O. Wolfson, and G. Trajcevski. “Spatio-temporal data reduction with deterministic error

bounds,” The VLDB Journal, Vol. 15(3):211–228, 2006.

7. S.M.C. Cavalcanti and F.F. Knowlton. “Evaluation of physical and behavioral traits of llamas
associated with aggressiveness toward sheep-threatening canids,” Applied Animal Behaviour
Science, Vol. 61(2):143–158, 1998.

8. N.R. Chrisman. “Beyond the snapshot: Changing the approach to change, error, and process,”
in M.J. Egenhofer and R.G. Golledge (Eds.), Spatial and Temporal Reasoning in Geographic
Information Systems, 85–93, Oxford University Press: Oxford, UK, 1998.

9. L. Conradt and T.J. Roper. “Group decision-making in animals,” Nature, Vol. 421(6919):

155–158, 2003.

10. M. D’Auria, M. Nanni, and D. Pedreschi. “Time-focused density-based clustering of trajectories
of moving objects,” in Proc. of the Workshop on Mining Spatio-temporal Data (MSTD-2005),
Porto, 2005.

11. C. Du Mouza and P. Rigaux. “Mobility patterns,” Geoinformatica, Vol. 9(4):297–319, 2005.
12. B. Dumont, A. Boissy, C. Achard, A.M. Sibbald, and H.W. Erhard. “Consistency of animal order
in spontaneous group movements allows the measurement of leadership in a group of grazing
heifers,” Applied Animal Behaviour Science, Vol. 95(1–2):55–66, 2005.

13. J.A. Dykes and D.M. Mountain. “Seeking structure in records of spatio-temporal behav-
iour: Visualization issues, efforts and application,” Computational Statistics and Data Analysis,
Vol. 43(4):581–603, 2003.

14. N. Eagle and A. Pentland. “Reality mining: Sensing complex social systems,” Personal and

Ubiquitous Computing, Vol. 10(4):255–268, 2006.

15. J. Erickson and R. Seidel. “Better lower bounds on detecting afﬁne and spherical degeneracies,”

Discrete & Computational Geometry, Vol. 13:41–57, 1995.

16. M. Erwig and R.H. Güting. “Spatio-temporal data types: An approach to modeling and querying

moving objects in databases,” Geoinformatica, Vol. 3(3):269–296, 1999.

17. A.U. Frank. “Socio-economic units: Their life and motion,” in A.U. Frank, J. Raper, and J.P.
Cheylan (Eds.), Life and Motion of Socio-economic Units, volume 8 of GISDATA, pp. 21–34,
Taylor & Francis: London, 2001.

Geoinformatica (2008) 12:497–528

525

18. A. Gajentaan and M.H. Overmars. n2-Hard Problems in Computational Geometry. Techni-
cal Report 1993-15, Department of Coumputer Science, Utrecht University, The Netherlands,
1993.

19. J. Gudmundsson, J. Katajainen, D. Merrick, C. Ong, and T. Wolle. “Compressing spatio-
temporal trajectories,” in Proc. of the 18th International Symposium on Algorithms and
Computation, 2007.

20. J. Gudmundsson and M. van Kreveld. “Computing longest duration ﬂocks in trajectory data,”

in Proc. of the 14th ACM Symposium on Advances in GIS, pp. 35–42, 2006.

21. J. Gudmundsson, M. van Kreveld, and B. Speckmann. “Efﬁcient detection of motion patterns in

spatio-temporal sets,” Geoinformatica, Vol. 11(2):195–215, 2007.

22. S. Gueron and S.A. Levin. “Self-organization of front patterns in large wildebeest herds,” Journal

of Theoretical Biology, Vol. 165(4):541–552, 1993.

23. R. Güting, M.H. Boehlen, M. Erwig, C.S. Jensen, N. Lorentzos, E. Nardelli, M. Schneider, and
M. Vazirgiannis. “A foundation for representing and querying moving objects,” ACM Transac-
tions on Database Systems (TODS), Vol. 2520(1):1–42, 2000.

24. R. Güting, M.H. Boehlen, M. Erwig, C.S. Jensen, N. Lorentzos, E. Nardelli, M. Schneider, and
J.R.R. Viqueira. “Spatio-temporal models and languages: An approach based on data types,”
in M. Koubarakis, T. Sellis, A.U. Frank, S. Grumbach, R.H. Güting, C.S. Jensen, N. Lorentzos,
Y. Manolopoulos, E. Nardelli, B. Pernici, H.J. Schek, M. Scholl, B. Theodoulidis, and N. Tryfona
(Eds.), Spatio-Temporal Databases: The CHOROCHRONOS Approach, volume 2520 of Lecture
Notes in Computer Science, 117–176, Springer: Berlin, 2003.

25. R.H. Güting and M. Schneider. Moving Objects Databases. Morgan Kaufmann Publishers, 2005.
26. I.A.R. Hulbert. “GPS and its use in animal telemetry: The next ﬁve years,” in A.M. Sibbald and
I.J. Gordon (Eds.), Proc. of the Conference on Tracking Animals with GPS, pp. 51–60, Macaulay
Insitute: Aberdeen, UK, 2001.

27. Y. Inada and K. Kawachi. “Order and ﬂexibility in the motion of ﬁsh schools,” Journal of

Theoretical Biology, Vol. 214(3):371–387, 2002.

28. Y. Ishikawa, Y. Tsukamoto, and H. Kitagawa. “Extracting mobility statistics from indexed spa-
tiotemporal datasets,” in Proc. of the 2nd Workshop on Spatio-Temporal Database Management
(STDBM), pp. 9–16, 2004.

29. A. Jadbabaie, J. Lin, and A.S. Morse. “Coordination of groups of mobile autonomous agents
using nearest neighbor rules,” IEEE Transactions on Automatic Control, Vol. 48(6):988–1001,
2003.

30. T. Kapler, R. Harper, and W. Wright. “Correlating events with tracked movement in time
and space: A geotime case study,” Presented at the 2005 Intelligence Analysis Conference,
Washington, DC, 2005.

31. G. Kollios, S. Sclaroff, and M. Betke. “Motion mining: Discovering spatio-temporal patterns in
databases of human motion,” in Proc. of the ACM SIGMOD Workshop on Research Issues in
Data Mining and Knowledge Discovery, 2001.

32. M. Koubarakis, Y. Theodoridis, and T. Sellis. “Spatio-temporal databases in the years ahead,” in
M. Koubarakis, T. Sellis, A.U. Frank, S. Grumbach, R.H. Güting, C.S. Jensen, N. Lorentzos,
Y. Manolopoulos, E. Nardelli, B. Pernici, H.J. Schek, M. Scholl, B. Theodoulidis, and N.
Tryfona (Eds.), Spatio-Temporal Databases: The CHOROCHRONOS Approach, volume 2520
of Lecture Notes in Computer Science, pp. 345–347. Springer: Berlin, 2003.

33. J. Krause and G.D. Ruxton. Living in Groups. Oxford Series in Ecology and Evolution. Oxford

University Press: New York, NY, 2002.

34. M.P. Kwan. “Interactive geovisualization of activity-travel patterns using three dimensional
geographical information systems: A methodological exploration with a large data set,” Trans-
portation Research Part C, Vol. 8(1–6):185–203, 2000.

35. R.F. Lachlan, L. Crooks, and K.N. Laland. “Who follows whom? Shoaling preferences and social
learning of foraging information in guppies,” Animal Behaviour, Vol. 56(1):181–190, 1998.
36. P. Laube and S. Imfeld. “Analyzing relative motion within groups of trackable moving point
objects,” in M.J. Egenhofer and D.M. Mark (Eds.), Geographic Information Science 2002,
volume 2478 of Lecture Notes in Computer Science, pp. 132–144, Springer: Berlin, 2002.

37. P. Laube, S. Imfeld, and R. Weibel. “Discovering relative motion patterns in groups of moving
point objects,” International Journal of Geographical Information Science, Vol. 19(6):639–668,
2005.

38. P. Laube and R.S. Purves. “An approach to evaluating motion pattern detection techniques in
spatiotemporal data,” Computers, Environment and Urban Systems, Vol. 30(3):347–374, 2006.

526

Geoinformatica (2008) 12:497–528

39. P. Laube, M. van Kreveld, and S. Imfeld. “Finding REMO – detecting relative motion patterns
in geospatial lifelines,” in P.F. Fisher (Ed.), Developments in Spatial Data Handling: Proc. of the
11th International Symposium on Spatial Data Handling, pp. 201–214, Springer: Berlin, 2004.
40. J.B. Leca, N. Gunst, B. Thierry, and O. Petit. “Distributed leadership in semifree-ranging white-

faced capuchin monkeys,” Animal Behaviour, Vol. 66:1045–1052, 2003.

41. Y. Li, J. Han, and J. Yang. “Clustering moving objects,” in Proc. of the Tenth ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining, ACM Press: Seattle, WA,
2004.

42. N. Mamoulis, H. Cao, G. Kollios, M. Hadjieleftheriou, Y. Tao, and D. Cheung. “Mining,
indexing, and querying historical spatiotemporal data,” in Proc. of the 10th ACM SIGKDD
International Conference On Knowledge Discovery and Data Mining, pp. 236–245, ACM, 2004.

43. D.M. Mark. “Geospatial lifelines,” in Integrating Spatial and Temporal Databases, volume 98471,

Dagstuhl Seminars, 1998.

44. H.J. Miller and J. Han. “Geographic data mining and knowledge discovery: An overview,”
in H.J. Miller and J. Han (Eds.), Geographic Data Mining and Knowledge Discovery, pp. 3–32.
Taylor & Francis, London, 2001.

45. K. Mouratidis, D. Papadias, and M. Hadjieleftheriou. “Conceptual partitioning: An efﬁcient
method for continuous nearest neighbor monitoring,” in Proc. of the 2005 ACM SIGMOD
Conference on Management of Data, pp. 634–645, 2005.

46. R.T. Ng. “Detecting outliers from large datasets,” in H.J. Miller and J. Han (Eds.), Geographic

Data Mining and Knowledge Discovery, pp. 218–235, Taylor & Francis: London, 2001.

47. R.O. Peterson, A.K. Jacobs, T.D. Drummer, L.D. Mech, and D.W. Smith. “Leadership behavior
in relation to dominande and reproductive status in gray wolves, canis lupus,” Canadian Journal
of Zoology, Vol. 80(8):1405–1412, 2002.

48. F. Porikli. “Trajectory distance metric using hidden Markov model based representation,”
in Proceedings of the 6th IEEE European Conference on Computer Vision, Workshop on PETS,
Prague, 2004.

49. Y. Qu, C. Wang, and X.S. Wang. “Supporting fast search in time series for movement patterns
in multiple scales,” in Seventh International Conference on Information and Knowledge Manage-
ment, pp. 251–258, ACM Press: Bethesda, MD, 1998.

50. S.A. Rands, G. Cowlishaw, R.A. Pettifor, J.M. Rowcliffe, and R.A. Johnstone. “Spontaneous
emergence of leaders and followers in foraging pairs,” Nature, Vol. 423(6938):432–434, 2003.

51. J. Raper. The Dimensions of GIScience, 2002. Keynote speech of GIScience 2002.
52. C.W. Reynolds. “Flocks, herds and schools: A distributed behavioral model,” in Proc. of the 14th
annual conference on Computer graphics and interactive techniques, volume 21, pp. 25–34, ACM
Press, 1987.

53. J.F. Roddick, K. Hornsby, and M. Spiliopoulou. “An updated bibliography of temporal, spatial,
and spatio-temporal data mining research,” in J.F. Roddick and K. Hornsby (Eds.), Temporal,
spatial and spatio-temporal data mining, TSDM 2000, volume 2007 of Lecture Notes in Artiﬁcial
Intelligence, pp. 147–163, Springer: Berlin, 2001.

54. T. Shirabe. “Correlation analysis of discrete motions,” in Proc. of the Fourth International
Conference on Geographic Information Science, GIScience 2006, volume 4197 of Lecture Notes
In Computer Science, pp. 370–382, Springer-Verlag, Berlin, 2006.

55. G. Sinha and D.M. Mark. “Measuring similarity between geospatial lifelines in studies of envi-

ronmental health,” Journal of Geographical Systems, Vol. 7(1):115–136, 2005.

56. A.P. Sistla, O. Wolfson, S. Chamberlain, and S. Dao. “Modeling and querying moving objects,”

in 13th International Conference on Data Engineering (ICDE13), 1997.

57. C.S. Smyth. “Mining mobile trajectories,” in H.J. Miller and J. Han (Eds.), Geographic Data

Mining and Knowledge Discovery, pp. 337–361. Taylor & Francis, London, 2001.

58. J.J. Thomas and K.A. Cook. “A visual analytics agenda,” IEEE Computer Graphics and Appli-

cations, Vol. 26(1):10–13, 2006.

59. S. Tisue and U. Wilensky. “NetLogo: A simple environment for modeling complexity,”

in International Conference on Complex Systems, Boston, 2004.

60. F. Verhein and S. Chawla. “Mining spatio-temporal association rules, sources, sinks, stationary
regions and thoroughfares in object mobility databases,” in Proc. of the 11th International Con-
ference on Database Systems for Advanced Applications (DASFAA), volume 3882 of Lecture
Notes in Computer Science, pp. 187–201, Springer, 2006.

61. U. Wilensky. “NetLogo ﬂocking model,” http://ccl.northwestern.edu/netlogo/models/Flocking,

1998.

62. U. Wilensky. “NetLogo (and NetLogo User Manual),” http://ccl.northwestern.edu/netlogo, 1999.

Geoinformatica (2008) 12:497–528

527

63. O. Wolfson and E. Mena. “Applications of moving objects databases,” in Y. Manolopoulos,
A. Papadopoulos, and M. Vassilakopoulos (Eds.), Spatial Databases: Technologies, Techniques
and Trends, Idea group Co., 2004.

64. O. Wolfson, B. Xu, S. Chamberlain, and L. Jiang. “Moving objects databases: Issues and
solutions,” in M. Rafanelli and M. Jarke (Eds.), 10th International Conference on Scientiﬁc
and Statistical Database Management, Proceedings, Capri, July 1–3, 1998, pp. 111–131,
IEEE Computer Society, 1998.

65. X. Xiong, M.F. Mokbel, and W.G. Aref. “Sea-cnn: Scalable processing of continuous k-nearest
neighbor queries in spatio-temporal databases,” in Proc. of the 21st International Conference on
Data Engineering (ICDE 2005), pp. 643–654, 2005.

Mattias Andersson received his M.Sc. in Computer Science at Lund university, Sweden. Currently
he is completing his Ph.D. thesis at the same university. He works in computational geometry,
specialising in geometric networks. Applications of this work include transportation networks,
computer graphics and geographic information systems (GIS).

Joachim Gudmundsson received his Ph.D. in computer science from Lund University in Sweden.
During 2001-2004 he was a postdoctoral researcher at Utrecht University and at the Technical
University of Eindhoven in the Netherlands. Since 2005 he has worked as a senior researcher
at NICTA in Sydney, where he is currently heading the DMiST project (Data Mining in Spatio-
Temporal sets). His research interests are computational geometry and approximation algorithms.

528

Geoinformatica (2008) 12:497–528

Patrick Laube holds an M.Sc. (Geography, 1999) and a Ph.D. degree (Sciences, 2005) from
University of Zurich, Switzerland. His thesis covered the analysis of movement data, presenting an
approach for spatio-temporal data mining based on pattern detection and visualisation. Recently he
was a research fellow at the Spatial Analysis Facility at the University of Auckland, NZ, and a visiting
scholar at the GeoVISTA Center at Penn State University, PA, USA. He is currently working as a
research fellow in the Department of Geomatics at the University of Melbourne, Australia, focussing
on distributed spatial computing and geosensor networks.

Thomas Wolle studied computer science at Friedrich-Schiller-University Jena, Germany, where he
graduated in 2001. In the same year, he started as a research student at Utrecht University, the
Netherlands, where he obtained his Ph.D. degree in 2005. His research focussed on graph algorithms,
more speciﬁcally on graphs of bounded treewidth. In 2006, he joined the DMiST project as a
researcher at NICTA in Sydney, where he works on algorithms for geometric problems that emerge
in the ﬁeld of spatio-temporal data mining.

