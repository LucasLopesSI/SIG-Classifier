This article was downloaded by: [University of Delaware]
On: 27 June 2012, At: 14:42
Publisher: Taylor & Francis
Informa Ltd Registered in England and Wales Registered Number: 1072954 Registered
office: Mortimer House, 37-41 Mortimer Street, London W1T 3JH, UK

International Journal of Geographical
Information Science
Publication details, including instructions for authors and
subscription information:
http://www.tandfonline.com/loi/tgis20

Propagating radial waves of travel cost
in a grid
Dana Tomlin a
a Landscape Architecture and Regional Planning, University of
Pennsylvania, Philadelphia, PA, USA

Version of record first published: 04 Sep 2010

To cite this article: Dana Tomlin (2010): Propagating radial waves of travel cost in a grid,
International Journal of Geographical Information Science, 24:9, 1391-1413

To link to this article:  http://dx.doi.org/10.1080/13658811003779152

PLEASE SCROLL DOWN FOR ARTICLE

Full terms and conditions of use: http://www.tandfonline.com/page/terms-and-
conditions

This article may be used for research, teaching, and private study purposes. Any
substantial or systematic reproduction, redistribution, reselling, loan, sub-licensing,
systematic supply, or distribution in any form to anyone is expressly forbidden.

The publisher does not give any warranty express or implied or make any representation
that the contents will be complete or accurate or up to date. The accuracy of any
instructions, formulae, and drug doses should be independently verified with primary
sources. The publisher shall not be liable for any loss, actions, claims, proceedings,
demand, or costs or damages whatsoever or howsoever caused arising directly or
indirectly in connection with or arising out of the use of this material.

International Journal of Geographical Information Science
Vol. 24, No. 9, September 2010, 1391–1413

Propagating radial waves of travel cost in a grid

Dana Tomlin*

Landscape Architecture and Regional Planning, University of Pennsylvania, Philadelphia, PA, USA

(Received 27 June 2009; final version received 4 March 2010)

To calculate the minimum cost of travel to each location within a geographical area from a
specified set of locations, most geographic information systems represent that area as a
rectangular grid of discrete cells, each indicating the cost of traversing that cell’s
particular location. These increments of cost are then accumulated by proceeding from
cell to adjacent cell in a manner that resembles the propagation of waves. Because this
propagation is limited to the eight directions associated with each cell’s eight neighbors,
however, it is often misdirected, and travel costs are therefore often overestimated. This
article discusses the context, precedent, design, implementation, performance, and
implications of a new algorithm that eliminates such problems in a straightforward
manner. It does so by retaining the octangular propagation mechanism of earlier algo-
rithms while keeping track of the particular locations at which propagated waves of
accumulating travel cost either refract or diffract. The approach also holds promise for
significant improvement in areas ranging from dispersion modeling and shape analysis to
interpolation and the delineation of cost-minimizing paths.

Keywords: field-based models; network analysis; route planning

1. The problem
One of the things done well and often by many of today’s geographic information systems
(GISs) is to measure the planar distance to each location on a map from the nearest of a
specified set of locations. In Figure 1, for example, is a map on which dashed lines delineate
zones of distance ‘as the crow flies’ from the area shown in white.

A related technique that is done less well but used with increasing frequency involves a
broader interpretation of cartographic distance. From this perspective, ‘distance’ is measured
not in meters or miles but in terms of more generally defined ‘costs’ that reflect the time, the
effort, the expense, and/or the impact of some sort of travel. Consider Figure 2, for example,
which presents a map on which dashed lines delineate zones of distance from the same white
area depicted in Figure 1. Here, however, those lines depict distance ‘as the crow walks’ from
that area and incurs costs of travel that accumulate at different rates in different regions.
These rates are represented by four shades of gray, such that the cost of travel per unit of
physical distance is greater in the darker regions.

The fundamental notion here is that increments of travel cost can be associated with
increments of physical space such that travel through that space results in an accumulation of
these costs. In the case of planar distance, one could correctly assert that every square hectare
is 100 m wide from side to side. In the case of travel-cost distance, on the other hand, it might

*Email: tomlin.dana@verizon.net

ISSN 1365-8816 print/ISSN 1362-3087 online
# 2010 Taylor & Francis
DOI: 10.1080/13658811003779152
http://www.informaworld.com

Downloaded by [University of Delaware] at 14:42 27 June 2012 1392

D. Tomlin

Figure 1. Planar distance.

well be equally correct to assert that a particular hectare is 19 minutes or 73 dollars ‘wide’
with respect to a given mode of travel. Furthermore, the travel-cost ‘width’ of another square
hectare might well be higher or lower. Depending on the site conditions (e.g. forest vs. field
vs. roadway vs. open water) within that other hectare, travel over its physical width (still
100 m) could well result in a different accumulation of minutes or dollars (or ergs, enemies,
lost opportunities, headaches, risks, and so on).

Though the shortest distance between two points in a plane is certainly the length of a
straight line between them, this is not necessarily true in the case of travel-cost distance. In
that case, it is the length of whatever path can connect those points with the lowest
accumulation of incremental costs. Such a path will be straight only when all increments
of cost between these points are the same. Otherwise, the path must meander in order to
minimize those costs.

This distinction gives rise to two very different measurement techniques. While the
planar distance between any two points can be calculated using Pythagoras’ theorem without
reference to anything other their respective positions in the plane, travel-cost distance
requires considerably more. In order to determine the length of the least-cost path between
two points, all possible paths must be accounted for. A practical way of doing this is to
propagate what amount to waves of ever-increasing travel-cost distance emanating from one
of the two points (Warntz 1957). If this can be done in a manner that effectively simulates the
idealized motion of waves that are associated with physical phenomena (such as water, wind,
sound, light, or other forms of electromagnetic radiation), then the first wave to reach that

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1393

Figure 2. Travel-cost distance.

second point will be the one that has followed a path of minimal travel cost. From this
perspective, the key to measuring travel-cost distance is therefore that modeling of propaga-
tion. Most importantly, this must be done such that distance waves interact with varying
increments of cost in a manner that effectively replicates the diffraction and refraction of
physical waves as they interact with media of varying density.

Though various techniques have been employed over the years to represent travel-cost
‘media’ in digital form (Bemmelen et al. 1993), the one used most often in GIS involves
cartographic maps or ‘layers’ on which incremental costs are encoded in a raster format.
Here, each layer exists as a rectangular grid of numerical values that are arrayed in
perpendicular rows and columns of equal width. As such, each value is uniquely associated
with a square ‘cell’ (and/or the center thereof) at a particular row–column position of the grid
that represents a corresponding position in geographical space.

One of the standard techniques for measuring planar distances in a grid (Tomlin 1983)
involves a procedure that starts by setting the value of a specified cell to zero as shown in
Figure 3a, where cells are depicted as gray squares. It then proceeds to the right, setting the
value of that specified cell’s first neighbor to one and the value of each subsequent neighbor
to two more than the neighbor before it. Next, it proceeds in a similar manner to the left as
shown in Figure 3b. With the resulting values, it then does likewise both downward and
upward, as respectively shown in Figure 3c and d. The square root of each cell’s resulting
value will be its planar distance to the cell initially specified. With minor adjustments, this
technique can also be used to compute every cell’s planar distance from the nearest of more
than one specified cell as well as the bearing and/or the identity of such cells.

Downloaded by [University of Delaware] at 14:42 27 June 2012 1394

(a)

(b)

(c)

(d)

D. Tomlin

Add 1 

Add 3 

Add 5 

Add 7 

Add 9 

Add 11 

Add 13 

0

1

9

16

25

36

49

Add 7 

Add 5 

Add 3 

Add 1 

16

9

4

1

0

1

9

16

25

36

49

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3

9

16

25

36

49

10

17

26

37

50

13

20

29

40

53

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5 

Add 5

25

18

13

10

10

13

18

25

34

45

58

16

9

17

10

20

13

20

13

17

10

16

9

17

10

20

13

4

5

8

8

5

4

5

8

1

2

5

5

2

1

2

5

0

1

4

9

4

1

0

1

4

1

2

5

5

2

1

2

5

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3 

Add 3

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1 

Add 1

13

20

29

40

53

10

17

26

37

50

9

16

25

36

49

10

17

26

37

50

13

20

29

40

53

4

4

4

5

8

8

5

4

5

8

25

18

13

10

9

10

13

18

25

34

45

58

Figure 3. Measuring planar distance in a grid.

The technique shown in Figure 3 takes advantage of the discrete and regular nature of a
rectangular grid in order to apply Pythagoras’ theorem through what amounts to a rectilinear
form of propagation. While the modeling of travel-cost accumulation generally calls for a
less predictable and more dispersive form of propagation, this too can be facilitated by the
discrete and regular nature of a grid.

Most techniques for doing so begin by equating the grid with a network in which nodes
correspond to the centers of grid cells, arcs indicate the possibility of travel from one node to
another, and weights represent the cost of travel associated with individual arcs. This grid
network is usually configured as shown in Figure 4, where every node (white circle) is linked
to as many as eight immediately neighboring nodes by way of directed arcs (black arrows).
Here, orthogonally adjacent nodes are separated a planar distance equal to the orthogonal

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1395

Figure 4. An octangular grid network.

width of a grid cell, while diagonally adjacent nodes are separated by that distance times
1.4142, the square root of 2.

This network rendition of cartographic space makes it possible to take advantage of
well-established algorithms for the identification of least-cost paths (Deo and Pang 1984), a
number of which have been employed for decades (usually applied to less regular networks)
and one of which (Dijkstra 1959) is often cited in connection with GIS. A related technique
(Tomlin 1983) for the measurement of travel-cost distance (i.e. the accumulation of incre-
mental arc weights) around a given ‘starting’ node proceeds as follows for the case in which
all such weights are non-negative.

Step 1: Set the distance of the starting node to 0 and the distances of all other nodes to the

highest value possible.

Step 2: Designate the starting node as ‘active’.
Step 3: For each of the active node’s adjacent neighbors, set its distance to whichever is
less: its current distance value or the sum of the distance of the active node plus the
weight of the arc from the active node to that neighbor.

Step 4: Once every node has been active, stop.
Step 5: Among those nodes that have not yet been active, designate the one with the

lowest distance value as active.

Step 6: Proceed to Step 3.

One of the more fortunate characteristics of this approach is the degree to which it results in
propagation that is somewhat radial in nature. When applied to a grid, it accumulates

Downloaded by [University of Delaware] at 14:42 27 June 2012 1396

D. Tomlin

increments of cost in a manner that mimics the propagation of physical waves. As such, it
presents the opportunity to incorporate additional factors relating to travel such as ascent and
descent, speed and momentum, change in direction, and so on.

The fact that this approach results in propagation that is not precisely radial, however, is
also one of its less fortunate characteristics. When applied to a grid in which travel is
restricted to increments between adjacent cells, least-cost paths can never be straight except
in eight particular directions. Paths that should ideally be radial instead tend to zigzag at
angles of 45(cid:2) and result in waves of distance that are ultimately octagonal rather than
circular. This effect can be seen in Figure 2. It results in measurements of distance that are
unintentionally anisotropic: they vary according to direction.

The reason for this is illustrated in Figure 5, where selected nodes are depicted as white
circles that are labeled according to their distances from a particular node labeled 0. These
distances are measured along shortest paths that are constrained to orthogonal arcs
(horizontal and vertical arrows) of length 1.0 and diagonal arcs (diagonal arrows) of length
1.4142. The octagonal pattern of resulting distance contours (black dashed lines) reflects the
degree to which this form of measurement overestimates actual distances (white dashed
lines) along anything other than straight paths. Such measurements are accurate only at the
corners of those octagonal distance contours. Between the corners, they can be overesti-
mated by as much as 8.24%. The total amount of overestimation associated with the map
shown in Figure 2 is in fact 3.81%.

Figure 5. Measuring planar distance in octangular increments.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1397

It is both interesting and frustrating to note that this problem is largely unaffected by grid
resolution and therefore cannot be eliminated by employing a finer grid. Just as interesting
and more encouraging, however, is the fact that this problem is significantly mitigated by
variations in arc weight. In areas where incremental travel costs are heterogeneous, zigs and
zags occur more often, and those effects tend to mask the problems of anisotropic propaga-
tion. In such areas, measurements of travel-cost distance also tend to benefit from finer
resolution. One way to take advantage of this is to deliberately introduce small amounts of
random variation to areas where increments of travel cost would otherwise be homogeneous.
The more fundamental challenge, however, is to model propagation in a manner that is
not only able to refract and diffract appropriately through heterogeneous media but also to
radiate through homogeneous media without being affected by the kind of error illustrated in
Figure 5. Consider, for example, the map presented in Figure 6, which depicts the same
travel origin (in white) and incremental travel costs (in four shades of gray) as are depicted in
Figure 2. Here, concentric zones of distance (dashed contour lines) are now circular rather
than octagonal within each shade of gray. This is an improvement that affects not only the
measurement of travel-cost distance per se but also the identification of optimal routes, the
characterization of spatial forms, the simulation of spatiotemporal processes, and so on. In a
world where the routine use of GIS technology involves more and more responsibility for
issues relating to health, safety, security, and justice, improvement in the measurement of
distance, direction, size, and/or shape can be of considerable consequence.

Figure 6.

Improved measurement of travel-cost distance.

Downloaded by [University of Delaware] at 14:42 27 June 2012 1398

D. Tomlin

2. Previous solutions

Though the zigzag problem has long been recognized (Goodchild 1977), few solutions have
been proposed from within the field of GIS, and none appear to have yet been widely
adopted. This stands in contrast to recent work in the field of computational fluid dynamics
(CFD), where much more demanding problems of flow simulation have spawned the
development of numerous solution strategies (which unfortunately also tend to be much
more demanding in terms of computation). Among efforts to resolve the zigzag problem are
just three that are regularly cited in the GIS literature.

The first of these is straightforward. It calls for modification of the rectangular grid
network by adding arcs connecting non-adjacent nodes. Consider, for example, the grid
shown in Figure 7. Here, selected nodes (white circles) are labeled according to their direct,
planar distances from a particular node labeled 0. If a grid network were to be configured
such that every cell was linked to both adjacent and nearby cells as indicated here, then
distances measured along node-to-node paths would result in distance contours (black
dashed lines) more closely approximating circles (white dashed lines) than do those
shown in Figure 5. These contours would form 16-sided polygons offering accurate mea-
surements at their corners and overestimates between those corners of only as much as
2.75%. By including arcs to even more non-adjacent neighbors, distance zones can be
generated in the form of 32-sided triacontakaidigons and even-more-sided polygons that
rapidly become almost circular as the number of sides is increased.

There are problems with this approach, however, that relate to the handling of those
non-adjacent neighbors. In reference to Figure 7, for example, it is unclear how the nodes at a
distance of 2.24 should be handled in light of the nodes at distances of 1.00 and 1.41 that lie
between them and the node labeled 0, particularly in situations where the intermediate nodes
are of differing incremental costs. As noted by Xu and Lathrop (1995), techniques that
bypass such intermediate nodes may well ignore significant increments of travel cost. If the
intermediate nodes are included, on the other hand, this approach runs the risk of producing
results like those associated with octangular propagation.

To minimize that risk, Xu and Lathrop employ an alternative method of propagation that
calls for extended neighborhoods but also introduces special procedures to handle

4

4

4

4

4

4

4

4

00

4

0

0

0

00

4

4

0

0

4

4

4

4

4

4

Figure 7. Measuring planar distance in hexadecangular increments.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1399

intermediate nodes. Here, neighborhoods can be flexibly defined, they need not be sym-
metric, and (depending on which of several options is specified) they may well include only
a sparse sampling of possible neighbors. For each neighbor processed, a cumulative cost is
then calculated by accumulating the increments of costs associated with whatever inter-
mediate nodes may lie along a least-cost path to that neighbor.

Xu and Lathrop assert that ‘although it is not possible to eliminate every zigzagging path
in a raster database, the new method does achieve very high accuracy’. Reported results
suggest that both the accuracy and computational expense of this approach increase sig-
nificantly as greater numbers of neighbors are processed within each neighborhood.

The third strategy for modeling propagation through a grid network of octangular incre-
ments, however, is one that does indeed ‘eliminate every zigzagging path’. Though Douglas
(1994) presents this strategy by describing only its most essential step, that step reflects an
important insight. Here, incremental costs are again accumulated from node to adjacent node,
but each new increment is reduced by whatever amount is necessary to compensate for the
additional distance incurred by having to proceed in an octangular direction.

The process is illustrated in Figure 8, where travel-cost distance is to be calculated from
node A to node B in terms of incremental costs that are set to 3 for node C, 2 for node D, and
1 for all other nodes. To do so, nodes C and D are each regarded as the center of a circle
whose radius is equal to that node’s accumulated cost. For C, this cost is (1 + 3)/2 = 2.00. For
D, it is 1.4142 · (1 + 2)/2 = 2.12. Next, those circles are intersected to yield two of what
Douglas refers to as ‘phantom’ points (E and F). Whichever phantom point lies closest to A

A

00

D

B

Figure 8. A corrective technique for measuring planar distance in octangular increments.

Downloaded by [University of Delaware] at 14:42 27 June 2012 1400

D. Tomlin

is then selected, and a straight line is constructed from this point (E) to node B. That straight
line is divided into two segments at the point (G) where it intersects a straight line connecting
nodes C and D, and each of the two segments is then measured. The length of the segment
including the phantom point (from E to G) is measured by way of conventional planar
geometry. The length of the other segment (from G to B), however, is computed by multi-
plying its planar dimension by the increment of cost associated with node B. These two
lengths are ultimately added to yield the cumulative travel cost at node B.

Reported results suggest that this approach is as accurate as is possible for the resolution
of a given grid and that it does indeed produce what Douglas describes as an ‘accumulated
cost surface with essentially circular contours’.

The reason that these two algorithms have yet to be widely adopted in practice may well
be a matter of computational efficiency. Xu and Lathrop’s description of typical run times
that are ‘one or two orders of magnitude longer than the conventional’ can certainly sound a
bit daunting. And the same is true of Douglas’ observation that ‘the time needed to calculate
can be expected to increase by the square of the size of the matrices used’. The real issue,
however, may instead (or also) be a matter of extensibility. As practitioners in areas such as
hydrology, fire modeling, and epidemiology have become more sophisticated in their routine
use of GIS, so has the demand for propagation models that can be readily modified to
incorporate additional factors.

It is in response to concern for both efficiency and extensibility that an alternative

algorithm is proposed.

3. An alternative solution

The new algorithm can be described in terms of its design,
performance.

implementation, and

3.1. Design

magnum reginae sed enim miseratus amorem
Daedalus ipse dolos tecti ambagesque resoluit,
caeca regens filo vestigia

The lines from Virgil’s Aeneid credit Daedalus with the idea, but it was Ariadne who then
conveyed the strategy to Theseus in a gesture that would ultimately save his life. After
slaying the Minotaur, Theseus was able to escape from the Labyrinth at Knossos by simply
following a thread that he had been careful to unwind behind him on his way in.

At the risk of mixing this metaphor (which has already been widely used in other areas of
network theory) with that of propagating waves, a similar device is used here to address a
related set of problems. The solution to handling zigzags is to correct for both the increase in
distance and the change in direction associated with each zig or zag as soon as it occurs.
What makes that possible is a form of Thesean tether, a virtual thread extending from a
source of propagation to each new cell encountered as that propagation continues.

Consider the case in which a wave of accumulating travel costs proceeds through a
homogeneous medium, one that is represented by a grid in which the increment of cost
associated with every cell is the same. Under these circumstances, all threads should be
straight, and the travel-cost length of each can be calculated by multiplying its planar length
by that incremental cost.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1401

A

5.4142

B 

5.0990 

C 

Figure 9.

Incremental measurement of radial distance in a grid.

This can be done in a stepwise manner as shown in Figure 9. Note here that, if
the incremental travel cost associated with every cell were to be set to 1, then the distance
from A to B would be 4, and the distance from B to C would be 1.4142. The cell-by-cell
distance from A to B to C would therefore be 4 + 1.4142 = 5.4142. Clearly, however,
Pythagoras would argue that the direct distance between A and C should be (52 + 12)½ or
5.0990.

To make the necessary correction, the proposed algorithm simply remembers the row/
column position of A, so that when the wave of accumulating travel cost distance is about to
spread from B to C, the increment of distance between B and C can be adjusted (from 1.4142
to 0.0990) to yield the overall sum of 5.0990 rather than 5.4142. Thus, even though
increments of travel cost are being accumulated in waves that propagate from cell to adjacent
cell in only orthogonal and/or diagonal directions, each new increment is being adjusted to
reflect direct distance from each wave’s source. Significantly, the direction of this travel path
from A to C can also be easily calculated.

Things become a bit more involved when a wave of accumulating travel costs proceeds
through a heterogeneous medium, one that would be represented by a grid in which
incremental costs vary from one cell to another. Under these circumstances, a travel path
must change direction, and the cell at which that happens must then be regarded as a new
source of propagation. There are two general conditions under which this occurs, and these
are respectively associated with what can be envisioned as the refraction and diffraction of
travel-cost waves.

A refractive change in direction must occur whenever a wave of travel cost passes from
one medium to another (i.e. whenever a new cell is encountered whose incremental cost is
something other than that of the cell from which it was approached).

A diffractive change in direction, on the other hand, may occur whenever a wave of
travel cost passes next to a medium of higher density (i.e. whenever travel into and out of a
given cell changes direction around an adjacent cell whose incremental cost is higher).
Sixteen possible instances of this situation are illustrated in Figure 10, where the directions
of travel-cost waves are depicted as black arrows, the cells at which these directions pivot are
marked with white dots, and the adjacent cells responsible for such pivots are shown in
darker shades of gray.

Once a refractive or diffractive change in direction has occurred, all subsequent mea-
surements of cumulative travel cost must regard the cell at which this happens as a new
source of wave propagation. Any later accumulation must therefore be measured from and
added to the cost already accumulated at that pivotal cell. This is illustrated for a simple case

Downloaded by [University of Delaware] at 14:42 27 June 2012 1402

D. Tomlin

Figure 10. Potential instances of travel-cost wave diffraction.

of diffraction in Figure 11, where black arrows represent travel paths from a particular cell,
white dots mark this upper-left cell as well as those other cells at which these paths change
direction, and darker shades of gray denote the cells whose higher incremental travel costs
are responsible for such changes in direction.

Figure 11 also serves to illustrate another important requirement. In order to assure that
travel paths never bend except in cases of refraction or diffraction, the kind of adjustment
depicted in Figure 9 must only be applied in situations where incremental travel costs are
uniform.

Implementation

3.2.
The algorithm embodying this procedure has been implemented in the Python computer
programming language and executed using the ArcGIS(cid:2) geographic information system. At
the heart of that Python script is a function that accepts a pair of two-dimensional arrays as its
major inputs and generates a third as its output. Each array is read from or written to an
ArcGIS(cid:2) grid data set.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1403

Figure 11. Diffracting waves of travel cost.

The first of those inputs is an integer or real-number array called InitialCost. This
represents a grid on which every ‘starting’ cell from which travel cost is to be calculated is
set to a value indicating how much travel cost, if any, has already been accumulated at that
cell. While this value is normally set to zero, the ability to specify already-accumulated travel
costs makes it possible to use the output grid from an earlier travel-cost calculation as the
InitialCost input to a later one.

The second input is a real-number array called IncrementalCost, which represents a grid
on which each cell is set to a value indicating the width of that cell from side to side in
positive units of travel cost.

The function ultimately returns a real-number array called CumulativeCost, which
represents a grid on which each cell’s value indicates the shortest travel-cost distance to
that cell from the nearest InitialCost starting cell, where increments of travel cost are defined
by IncrementalCost values. This is done as follows:

Step 1: In CumulativeCost, set each starting cell to its InitialCost value and all other cells

to a specified maximum travel cost to be calculated.

Step 2: Place references to all starting cells into a queue sorted by their InitialCost values.
Step 3: Until the queue is empty, process its cells in their sorted order as follows, where

the cell being processed at any given time is referred to as the ‘active’ cell.

Step 4: For each of the (up to) eight ‘neighbor’ cells lying immediately adjacent to the

active cell, do the following.

Step 5: If the neighbor cell’s IncrementalCost value differs from that of the active cell, or
if the travel path into and out of the active cell pivots around an adjacent cell of
greater IncrementalCost value (as shown in Figure 10), then designate the active cell
as a potential ‘source’ cell for this neighbor (as shown in Figure 11), calculate the
neighbor cell’s cumulative travel cost by augmenting the CumulativeCost of the
active cell with the average IncrementalCost of the active cell and that neighbor
(multiplied by 1.4142 in the case of diagonal neighbors), and skip to Step 8.

Step 6: If any cell that lies directly between the neighbor cell and the active cell’s source
cell has an IncrementalCost value exceeding that of the neighbor cell, skip to Step 4
and the next of the active cell’s neighbors.

Downloaded by [University of Delaware] at 14:42 27 June 2012 1404

D. Tomlin

Step 7: Calculate the neighbor cell’s travel-cost distance directly from the active cell’s
source cell (as shown in Figure 9), and designate that source cell as a potential source
cell for this neighbor.

Step 8: Remove the active cell from the queue and, unless the neighbor cell’s newly
calculated cumulative travel cost fails to reduce its currently recorded CumulativeCost
value, replace that CumulativeCost value with this newly calculated cost, affirm the
neighbor’s newly designated source cell, remove any existing reference to this
neighbor from the queue, and insert a new reference to the neighbor at whatever
position in this cost-sorted queue is dictated by its CumulativeCost value.

The Python code for this algorithm is appended.

3.3. Performance

As implied earlier, performance in this context is largely a matter of effectiveness, efficiency,
and extensibility.

Effectiveness is essentially a matter of the degree to which propagation through a
homogeneous medium results in circular waves of distance, while propagation through
heterogeneous media results in waves of distance that refract and/or diffract in a manner
consistent with the densities of those media. To appreciate the effectiveness of the algorithm
proposed, consider again the map of planar distances presented in Figure 1. That map was
actually generated not by employing a planar distance–measuring technique like the one
illustrated in Figure 3. Rather, it was generated by using the proposed algorithm to accu-
mulate increments of travel cost that were all set to the same value. When the result is
compared to that of an operation intended to measure only planar distance (in particular, the
Euclidean Distance tool in ArcGIS(cid:2)), the two are virtually identical. Thus, what had been
overestimates of as much as 8.24% in the case of 8-neighbor propagation and as much as
2.75% in the case of 16-neighbor propagation have now been entirely eliminated.

Figure 12 demonstrates the effectiveness of this algorithm in refracting waves of travel-
cost distance through media of varying impedance and diffracting those waves around
impenetrable barriers. Here, travel-cost distances from the white dot are indicated by dashed
contour lines. The incremental travel cost associated with each of eight black rectangles is
great enough to effectively obstruct wave propagation and cause diffraction around those
barriers. Wave refraction is also evident in the upper- and the lower-left portions of this map.
In the upper (darker) portion, incremental costs are higher, and contour lines are therefore
closer together. In the lower-left (lighter) portion, incremental costs are lower, and contour
lines are therefore farther apart.

Efficiency in this context is a matter of the space and time required for computation. In
the algorithm proposed, the amount of space required is primarily dependent not on the
overall size of grid per se but only on the number of cells along the most distant ‘wavefront’
at any given time. As such, processing space is seldom likely to be an issue. Processing time,
on the other hand, is largely dependent on the number of cells for which distance values must
ultimately be calculated, and this number is affected by three major factors.

First is the maximum distance limit. As this distance is increased by a given amount, the
number of cells lying within that increased distance may grow by as much as the square of
that amount.

Second is the number of cells that must be traversed in order to reach that limit. This
number will be greater when cells are smaller and/or associated with lower incremental
costs.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1405

Figure 12. Travel-cost distance as measured by diffracting and refracting waves of accumulating cost.

Third is the overall pattern of starting cell locations. When starting cells are situated
farther away from one another (or from the edge of a grid), the number of intervening cells
for which distances must be calculated will generally be greater as well.

The speed of the proposed algorithm is also affected by the spatial pattern of incremental
costs. In areas where those costs are less uniform, processing speed is generally slower. The
time required to generate the travel-cost map shown in Figure 6, for example, was approxi-
mately 20% greater than that required to generate the map shown in Figure 1.

The Python implementation of this algorithm takes about twice as much processing time
as does the same software when no attempt is made to compensate for the effects of
octangular propagation. Another version implemented in the C# programming language
and packaged as an ArcGIS(cid:2) toolbox, however, has proven to be more promising. This
version has yielded execution times comparable to those of the ArcGIS(cid:2) Cost Distance tool,
which also measures travel-cost distance but does so without compensating for octangular
error.

To appreciate the extensibility of the proposed algorithm, consider the example pre-
sented in Figure 13. Here, a new condition has been added to those presented in Figure 12. A
topographic surface ascending toward the upper right has been introduced such that waves of
accumulating travel cost incur an additional cost that varies with the steepness of that
surface. As these waves proceed uphill at the steepest grade (toward the upper right), they
encounter the greatest amount of additional cost, and the resulting distance contours are
therefore closer together. As the waves proceed downhill at steeper and steeper grades
(orienting more and more toward the lower left), however, they encounter the lower amounts
of additional cost, and the resulting distance contours are farther apart.

Downloaded by [University of Delaware] at 14:42 27 June 2012 1406

D. Tomlin

Figure 13. Directional influence on travel-cost distance.

The topographic surface introduced here is encoded as a grid on which each cell’s value
indicates its position in the third spatial dimension perpendicular to those of the cartographic
plane. Thus, as increments of travel cost are accumulated in Step 5 or Step 7 of the algorithm
proposed, these can be easily modified according to factors such as the steepness or the
increase in physical separation associated with differences in the third-dimensional positions
of an active cell and its neighbor. While those positions could indeed represent topographic
elevations, they could just as easily represent measures such as barometric pressure or
population density and thereby be used to incorporate factors such as wind intensity or the
influence of urban development.

What makes this sort of extension so straightforward is the incremental nature of the
algorithm proposed. Like earlier methods (a number of which are also able to take topo-
graphy into account), it models the propagation of travel-cost waves by proceeding from cell
to adjacent cell. Unlike earlier methods, however, this one does not presume that the
direction of wave propagation at any given point is necessarily limited to one of the eight
particular bearings that extend from an active cell to a neighbor. Rather, that direction can be
much more precisely modeled as the bearing that extends toward an active cell’s neighbor
from that active cell’s own source cell. Such bearings can easily be calculated at Steps 5 and
7 of the algorithm proposed.

Significantly, this ability to model spatial propagation in discrete increments without
suffering directional bias can be extended to volumetric settings as well. Though the grid
cells in such settings would represent cubes rather than squares, and each could have as many
as 24 adjacent neighbors rather than eight, the algorithm proposed could certainly be adapted
for effective use in three-dimensional space.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1407

4.

Implications

An ability to better model the accumulation of travel costs can also affect a number of other
types of calculation that are routinely associated with the use of GIS. In general, these are
calculations that characterize each location’s relationship to the nearest of a selected set of
locations in terms of the identity of that nearest neighboring location, its distance, and/or its
direction(s).

To characterize every location by identifying the nearest of a specified set of locations is
to generate proximal polygons. In Figure 14 is an elementary example of how this funda-
mental procedure can be improved by way of the algorithm proposed. Here, locations above
and below the white line are respectively closer to the upper and lower white dots when
proximity is measured in units of physical distance. The same should also be true when
proximity is measured in uniform increments of travel cost. While the algorithm proposed
correctly situates the boundaries of such proximal polygons, earlier methods tend to generate
erroneous boundaries like the one depicted in black.

The generation of proximal polygons can be viewed as a heavy-handed form
inverse-distance-weighted interpolation, one in which each location of unknown value
is simply set to the nearest value known. From this perspective, it is clear that the effect
depicted in Figure 14 will also pertain to other forms of interpolation or density
modeling in which distances between locations are expressed in units of travel cost.
The same is likewise true for a number of shape-characterizing techniques. Consider, for
example, a tool that might measure narrowness in units of travel time or one that might
aggregate island-like areas into archipelago-like clusters on the basis of intervening site
conditions.

As indicated earlier, it is the ability to more precisely track the direction of travel-cost
wave propagation that most distinguishes the algorithm proposed from its predecessors.
Without that capability, it is very difficult indeed to effectively model increments of travel
cost that vary according to dynamic factors such as the speed, acceleration, or force with
which such increments of cost are encountered. It is likewise difficult to effectively model
dispersion phenomena (such as downwind plumes) and penumbral effects (such as cell
phone reception). The proposed algorithm’s directional refinements may prove to be of most
immediate interest, however, in generating least-cost paths (Collischonn and Pilar 2000,
Yu et al. 2003). Path finding has in fact been closely associated with much of the earlier work
on measuring travel-cost proximity.

Figure 14. Proximal polygon boundaries associated with alternative methods of measuring travel cost.

Downloaded by [University of Delaware] at 14:42 27 June 2012 1408

D. Tomlin

Figure 15. Least-cost paths associated with alternative methods of measuring travel cost.

To appreciate the implications of greater directional precision in this regard, consider the
example presented in Figure 15. On the left is a pattern of least-cost path directions limited to
octangular increments. On the right is a comparable pattern associated with the algorithm
proposed. In each case, arrows indicate the direction of least-cost travel from the white dot,
given incremental costs that are relatively low in the lighter region and high enough within
the black rectangles to make those areas act as impassible barriers. Several typical least-cost
paths are then depicted as white dashed lines. This ability to better trace paths of minimum
travel cost can likewise affect more complex techniques to identify suboptimal paths and to
allocate multiple-path networks.

Figure 15 can also be regarded in more general terms as a form of project summary.
Though only a snapshot, it is nonetheless one that captures both the fundamental problem
initially posed and the essential strategy proposed for its solution.

5. Conclusion

One of the more rewarding things about adolescence is the degree to which each new
development raises the engaging prospect of even more. As the field of GIS continues to
mature, it is especially gratifying to note the increasing frequency with which that tends to
that offers significant
occur. This article has introduced an algorithmic development
improvement over existing methods and yet can be implemented and extended with relative
ease. The algorithm proposed has been described, demonstrated, and made available in
hopes that it will indeed be implemented and extended in ways that encourage continued
development in the modeling of motion through geographical space.

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1409

Acknowledgments
This article reflects the much-appreciated critique of several anonymous reviewers.

The work presented has been supported by the US National Science Foundation under Grant
0308414 with the understanding that its author bears full responsibility for any errors, omissions, or
opinions.

The C# version of the algorithm proposed was implemented by Mr. David Zwarg of Azavea(cid:2) Inc.

(formerly Avencia(cid:2) Incorporated), a GIS software development firm based in Philadelphia.

References
Bemmelen, J.V., Quak, W., Hekken, M.V., and Oosterom, P.V., 1993. Vector vs. raster-based algo-
rithms for cross country movement in planning. In: Proceedings of AutoCarto 11, R.B. McMaster
and M.P. Armstrong (Eds). Bethesda, MD: American Congress on Surveying and Mapping,
304–317.

Collischonn, W. and Pilar, J.V., 2000. A direction dependent least-cost-path algorithm for roads and

canals. International Journal of Geographic Information Science, 14 (4), 397–406.

Deo, N. and Pang, C., 1984. Shortest-path algorithms: taxonomy and annotation. Networks, 14 (2),

Dijkstra, E.W., 1959. A note on two problems in connection with graphs. Numerische Mathmatik, 1 (5),

Douglas, D.H., 1994. Least cost path in GIS using an accumulated cost surface and slope lines.

Goodchild, M.F., 1977. Evaluation of lattice solutions to problem of corridor location. Environment

Tomlin, C.D., 1983. Digital cartographic modeling techniques in environmental planning. Thesis

275–323.

269–271.

Cartographica, 31 (3), 37–51.

and Planning A, 9, 727–738.

(PhD). Yale University.

Geographer, 9 (4), 2–7.

Warntz, W., 1957. Transportation, social physics and the law of refraction. The Professional

Xu, J. and Lathrop, R.G., 1995. Improving simulation of spread phenomena in raster-based geographic
information systems. International Journal of Geographic Information Systems, 9 (2), 153–168.
Yu, C., Lee, J., and Munro-Stasiuk, M.J., 2003. Extensions to least-cost path algorithms for roadway

planning. International Journal of Geographic Information Science, 17 (4), 361–376.

Appendix 1. Implementation in Python
The algorithm proposed can be implemented in the form of Python functions as follows:

def spread (HowManyRows,HowManyColumns,HowFar,

/
InitialCost,IncrementalCost,ShiftNorth,ShiftEast):

# RETURN A REAL-NUMBER ARRAY REPRESENTING
A GRID OF ACCUMULATED TRAVEL COSTS
#
# HowManyRows
# HowManyColumns
# HowFar
# InitialCost
#
#
#
# IncrementalCost
#
# ShiftNorth
#
# ShiftEast
#
# CumulativeCost
#

is an integer indicating number of rows in input and output grids
is an integer indicating number of columns in input and output grids
is an integer indicating maximum travel-cost distance to be calculated
is an integer or real-number array representing an input grid on which
StartingCells from which travel-cost distances are to be measured
are set to 0 (or greater to apply an initial "headstart" distance),
while others are below 0
is a real-number array representing an input grid on which
each cell’s value indicates its side-to-side dimension in travel cost
is an integer array recording each cell’s
row distance from its SourceCell
is an integer array recording each cell’s
column distance from its SourceCell
is a real-number array representing
the output grid of accumulated travel costs

Downloaded by [University of Delaware] at 14:42 27 June 2012 1410

D. Tomlin

# INITIALIZE
SqRtOf2 = math.sqrt(2)
OctagonalShift = [ 1, 1, 1, 1,SqRtOf2,SqRtOf2,SqRtOf2,SqRtOf2]
RowShift = [-1, 0, 1, 0,-1,-1, 1, 1]
ColumnShift = [ 0, 1, 0,-1,-1, 1, 1,-1]
InwardShiftNorth = 0
InwardShiftEast = 0
ActiveCost = 1.0
NewDistance = 1.0
ActiveList = [[0,0,0]]
for ThisRow in range(HowManyRows):

for ThisColumn in range(HowManyColumns):

if IncrementalCost[ThisRow][ThisColumn] , 1:
IncrementalCost[ThisRow][ThisColumn] = 1.0

if InitialCost[ThisRow][ThisColumn] .= 0:

ActiveList.append([InitialCost[ThisRow][ThisColumn],ThisRow,ThisColumn])
CumulativeCost[ThisRow][ThisColumn] = InitialCost[ThisRow][ThisColumn]

else: CumulativeCost[ThisRow][ThisColumn] = HowFar

ActiveList[0:1] = []
ActiveList.sort()

# LOOP THROUGH LIST OF ACTIVE CELLS
for NextActiveCell in ActiveList:

if NextActiveCell[0] . HowFar: break
ActiveDistance = NextActiveCell[0]
ActiveRow = NextActiveCell[1]
ActiveColumn = NextActiveCell[2]
ActivePosition = ActiveList.index(NextActiveCell)
ActiveCost = IncrementalCost[ActiveRow][ActiveColumn]
InwardShiftNorth = ShiftNorth[ActiveRow][ActiveColumn]
InwardShiftEast = ShiftEast[ActiveRow][ActiveColumn]

# LOOP THROUGH ACTIVE CELL’S ADJACENT NEIGHBORS
for NextNeighbor in range(8):

OutwardShiftNorth = -RowShift[NextNeighbor]
OutwardShiftEast = ColumnShift[NextNeighbor]
NeighborRow = ActiveRow + RowShift[NextNeighbor]
if NeighborRow , 0 or NeighborRow .= HowManyRows: continue
NeighborColumn = ActiveColumn + OutwardShiftEast
if NeighborColumn , 0 or NeighborColumn .= HowManyColumns: continue

# CALCULATE DISTANCE FROM ACTIVE CELL TO NEIGHBOR CELL
NewDistance = ((ActiveCost + IncrementalCost[NeighborRow][NeighborColumn]/2 ) \

* OctagonalShift[NextNeighbor]

# IF TRAVEL PATH FROM SOURCE TO NEIGHBOR REFRACTS,
# CALCULATE NEIGHBOR’S DISTANCE
# AND MAKE ACTIVE CELL A NEW SOURCE
if IncrementalCost[NeighborRow][NeighborColumn] \
, IncrementalCost[ActiveRow][ActiveColumn]:
NeighborShiftNorth = OutwardShiftNorth
NeighborShiftEast = OutwardShiftEast
NeighborDistance = ActiveDistance + NewDistance

# IF PATH DOESN’T REFRACT BUT DOES DIFFRACT,
# CALCULATE NEIGHBOR’S DISTANCE

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1411

# AND MAKE ACTIVE CELL A NEW SOURCE
else:

getSideCell (NextNeighbor,ActiveRow,ActiveColumn,InwardShiftNorth, \

InwardShiftEast,OutwardShiftNorth,OutwardShiftEast)

if IncrementalCost[SideRow][SideColumn] . ActiveCost:

NeighborShiftNorth = OutwardShiftNorth
NeighborShiftEast = OutwardShiftEast
NeighborDistance = ActiveDistance + NewDistance

# IF PATH DOESN’T REFRACT OR DIFFRACT
# BUT IS BLOCKED BY HIGHER INCREMENTAL COST,
# SKIP THIS NEIGHBOR
elif blocked (ActiveRow,ActiveColumn,InwardShiftNorth,InwardShiftEast, \

NeighborRow,NeighborColumn,IncrementalCost): continue

# IF PATH IS UNREFRACTED, UNDIFFRACTED, AND UNBLOCKED,
# CALCULATE NEIGHBOR’S DISTANCE FROM ACTIVE CELL’S SOURCE CELL
else:

NeighborShiftNorth = OutwardShiftNorth + InwardShiftNorth
NeighborShiftEast = OutwardShiftEast + InwardShiftEast
SourceToNeighbor = \

math.sqrt(math.pow((InwardShiftNorth + OutwardShiftNorth),2) \

+ math.pow((InwardShiftEast + OutwardShiftEast), 2))

SourceToActive = math.sqrt(math.pow(InwardShiftNorth,2) \

+ math.pow(InwardShiftEast,2))

ActiveToNeighbor = math.sqrt(math.pow(OutwardShiftNorth,2) \

+ math.pow(OutwardShiftEast,2))

OctangularFix = (SourceToNeighbor-SourceToActive) / ActiveToNeighbor
NeighborDistance = ActiveDistance + (NewDistance * OctangularFix)

# IF NEIGHBOR’S NEW DISTANCE EXCEEDS ITS CURRENT DISTANCE
# OR THE MAXIMUM DISTANCE LIMIT, SKIP THIS NEIGHBOR
if (NeighborDistance * 1.00001) .= CumulativeCost[NeighborRow][NeighborColumn] \

or NeighborDistance . HowFar: continue

# IF NEIGHBOR HAD ALREADY BEEN REACHED,
# REMOVE IT FROM THE ACTIVE LIST
if ShiftNorth[NeighborRow][NeighborColumn] ,. 0 \
or ShiftEast[NeighborRow][NeighborColumn] ,. 0:
for OldActiveCell in ActiveList[ActivePosition:]:

if OldActiveCell[1] == NeighborRow and OldActiveCell[2] == NeighborColumn:

del ActiveList[ActiveList.index(OldActiveCell)]
break

# ADD NEIGHBOR TO THE ACTIVE LIST, THE CUMULATIVE COST GRID,
# THE SHIFTNORTH GRID, AND THE SHIFTEAST GRID
for OldActiveCell in ActiveList[ActivePosition:]:

if NeighborDistance .= OldActiveCell[0]: continue
ActiveList.insert(ActiveList.index(OldActiveCell), \

[NeighborDistance,NeighborRow,NeighborColumn])

break

else:

ActiveList.append([NeighborDistance,NeighborRow,NeighborColumn])

CumulativeCost[NeighborRow][NeighborColumn] = NeighborDistance
ShiftNorth[NeighborRow][NeighborColumn] = NeighborShiftNorth
ShiftEast[NeighborRow][NeighborColumn] = NeighborShiftEast

# RETURN THE CUMULATIVE COST GRID
return CumulativeCost

Downloaded by [University of Delaware] at 14:42 27 June 2012 1412

D. Tomlin

def blocked (ActiveRow,ActiveColumn,InwardShiftNorth,InwardShiftEast, \
NeighborRow,NeighborColumn,IncrementalCost):
# RETURN 1 IF TRAVEL PATH FROM SOURCE TO NEIGHBOR
# IS BLOCKED BY HIGHER INCREMENTAL COST
SourceRow = int(ActiveRow + InwardShiftNorth)
SourceColumn = int(ActiveColumn - InwardShiftEast)
Blockage = 0
if abs(NeighborRow-SourceRow) .= abs(NeighborColumn-SourceColumn):

if NeighborRow ,. SourceRow:

if NeighborRow , SourceRow: RowStep = 1
else: RowStep = -1
if NeighborRow + RowStep ,. SourceRow:

Cshift = float(SourceColumn-NeighborColumn) \

/ float(abs(SourceRow-NeighborRow))

= float(NeighborColumn)

C
for NextRow in range(NeighborRow+RowStep,SourceRow-RowStep,RowStep):

C
= C + Cshift
NextCol = int(C + 0.5)
if IncrementalCost[NextRow][NextCol] . \

IncrementalCost[NeighborRow][NeighborColumn]:
Blockage = 1
break

elif NeighborColumn ,. SourceColumn:

if NeighborColumn , SourceColumn: ColStep = 1
else: ColStep = -1
if NeighborColumn + ColStep ,. SourceColumn:

Rshift = float(SourceRow-NeighborRow) / float(abs(SourceColumn-NeighborColumn))
R = float(NeighborRow)
for NextCol in range(NeighborColumn+ColStep,SourceColumn-ColStep,ColStep):

R = R + Rshift
NextRow = int(R + 0.5)
if IncrementalCost[NextRow][NextCol] . \

IncrementalCost[NeighborRow][NeighborColumn]:
Blockage = 1
break
return Blockage

def getSideCell (NextNeighbor,ActiveRow,ActiveColumn,InwardShiftNorth, \

InwardShiftEast,OutwardShiftNorth,OutwardShiftEast):

# IDENTIFY SIDE CELL AROUND WHICH TRAVEL PATH
# FROM SOURCE TO NEIGHBOR PIVOTS
global SideRow, SideColumn
SideRow = ActiveRow
SideColumn = ActiveColumn
if InwardShiftEast == 0: IncomingSlope = 99999999.9
else: IncomingSlope = float(InwardShiftNorth)/float(InwardShiftEast)
if InwardShiftNorth . 0 and InwardShiftEast == 0:

if OutwardShiftEast
== 1:
elif OutwardShiftEast == -1:

SideColumn = ActiveColumn + 1
SideColumn = ActiveColumn - 1

elif InwardShiftNorth , 0 and InwardShiftEast == 0:

if OutwardShiftEast
== 1:
elif OutwardShiftEast == -1:

SideColumn = ActiveColumn + 1
SideColumn = ActiveColumn - 1

elif InwardShiftNorth == 0 and InwardShiftEast . 0:

SideRow
if OutwardShiftNorth == 1:
elif OutwardShiftNorth == -1: SideRow

= ActiveRow - 1
= ActiveRow + 1

elif InwardShiftNorth == 0 and InwardShiftEast , 0:

if OutwardShiftNorth == 1:
SideRow
elif OutwardShiftNorth == -1: SideRow

= ActiveRow - 1
= ActiveRow + 1

Downloaded by [University of Delaware] at 14:42 27 June 2012 International Journal of Geographical Information Science

1413

elif InwardShiftNorth . 0 and InwardShiftEast . 0:

if NextNeighbor == 0 or NextNeighbor == 4: SideColumn = ActiveColumn - 1
elif NextNeighbor == 1 or NextNeighbor == 6: SideRow
elif NextNeighbor == 5:

= ActiveRow + 1

if IncomingSlope , 1.0:
elif IncomingSlope . 1.0: SideColumn = ActiveColumn + 1

= ActiveRow - 1

SideRow

elif InwardShiftNorth , 0 and InwardShiftEast . 0:

if NextNeighbor == 1 or NextNeighbor == 5: SideRow
elif NextNeighbor == 2 or NextNeighbor == 7: SideColumn = ActiveColumn - 1
elif NextNeighbor == 6:

= ActiveRow - 1

if IncomingSlope , -1.0: SideColumn = ActiveColumn + 1
elif IncomingSlope . -1.0: SideRow
elif InwardShiftNorth , 0 and InwardShiftEast , 0:

= ActiveRow + 1

if NextNeighbor == 2 or NextNeighbor == 6: SideColumn = ActiveColumn + 1
elif NextNeighbor == 3 or NextNeighbor == 4: SideRow
elif NextNeighbor == 7:

= ActiveRow - 1

if IncomingSlope , 1.0:
elif IncomingSlope . 1.0: SideColumn = ActiveColumn - 1

= ActiveRow + 1

SideRow

elif InwardShiftNorth . 0 and InwardShiftEast , 0:

if NextNeighbor == 3 or NextNeighbor == 7: SideRow
elif NextNeighbor == 0 or NextNeighbor == 5: SideColumn = ActiveColumn + 1
elif NextNeighbor == 4:

= ActiveRow + 1

if IncomingSlope , -1.0: SideColumn = ActiveColumn - 1
elif IncomingSlope . -1.0: SideRow

= ActiveRow - 1

Downloaded by [University of Delaware] at 14:42 27 June 2012 