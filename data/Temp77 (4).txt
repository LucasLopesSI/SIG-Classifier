This article was downloaded by: [University Of Pittsburgh]
On: 12 November 2014, At: 06:04
Publisher: Taylor & Francis
Informa Ltd Registered in England and Wales Registered Number: 1072954 Registered
office: Mortimer House, 37-41 Mortimer Street, London W1T 3JH, UK

International Journal of Geographical
Information Science
Publication details, including instructions for authors and
subscription information:
http://www.tandfonline.com/loi/tgis20

Formal information modelling for
standardisation in the spatial domain
Stephan Winter a & Silvia Nittel b
a Department of Geomatics , The University of Melbourne ,
Victoria 3010, Australia E-mail:
b Department of Spatial Information Science and Engineering ,
University of Maine , 5711 Boardman Hall, Orono, ME
04469-5711, USA E-mail:
Published online: 19 May 2010.

To cite this article: Stephan Winter & Silvia Nittel (2003) Formal information modelling for
standardisation in the spatial domain , International Journal of Geographical Information Science,
17:8, 721-741, DOI: 10.1080/13658810310001596067

To link to this article:  http://dx.doi.org/10.1080/13658810310001596067

PLEASE SCROLL DOWN FOR ARTICLE

Taylor & Francis makes every effort to ensure the accuracy of all the information (the
“Content”) contained in the publications on our platform. However, Taylor & Francis,
our agents, and our licensors make no representations or warranties whatsoever as to
the accuracy, completeness, or suitability for any purpose of the Content. Any opinions
and views expressed in this publication are the opinions and views of the authors,
and are not the views of or endorsed by Taylor & Francis. The accuracy of the Content
should not be relied upon and should be independently verified with primary sources
of information. Taylor and Francis shall not be liable for any losses, actions, claims,
proceedings, demands, costs, expenses, damages, and other liabilities whatsoever
or howsoever caused arising directly or indirectly in connection with, in relation to or
arising out of the use of the Content.

This article may be used for research, teaching, and private study purposes. Any
substantial or systematic reproduction, redistribution, reselling, loan, sub-licensing,
systematic supply, or distribution in any form to anyone is expressly forbidden. Terms &
Conditions of access and use can be found at http://www.tandfonline.com/page/terms-
and-conditions

INT. J. GEOGRAPHICAL INFORMATION SCIENCE, 2003
VOL. 17, NO. 8, 721–741

Research Article

Formal information modelling for standardisation in the spatial
domain

STEPHAN WINTER
Department of Geomatics, The University of Melbourne, Victoria 3010,
Australia; e-mail: winter@unimelb.edu.au

SILVIA NITTEL
Department of Spatial Information Science and Engineering,
University of Maine, 5711 Boardman Hall, Orono, ME 04469-5711, USA;
e-mail: nittel@spatial.maine.edu

(Received 3 August 2000; accepted 20 May 2003 )

Abstract. This paper presents the results and experiences of applying a formal
tool to writing speciﬁcations for software in the spatial domain. We take a
speciﬁcation from a standards organization to demonstrate the properties of this
approach, and we compare our result with the semi-formal speciﬁcation of the
standards organization. The expected advantages—formal semantics of speciﬁed
interfaces, total abstraction from implementation, executable prototype, and
extendable algebraic structure—can be veriﬁed. However negative experiences
are reported also: pure abstract code turns out to appear overloaded and
difﬁcult to read (by humans). With this work we contribute to the foundations
of standardisation efforts in the spatial domain, preserving an object oriented
modeling approach.

1.

Introduction
This paper presents the results and experiences of applying a formal tool to
writing speciﬁcations for software in the spatial domain. Current state of the art
writing such speciﬁcations is utilizing UML (Uniﬁed Modelling Language, Booch
et al. 1999; OMG 2000). UML is not formal
in its semantics, and remains
descriptive in specifying behavior of methods. This paper takes a published
speciﬁcation from a standards organization, translates it into a formal speciﬁcation,
and compares the two. The selected example is the gridded coverage, a speciﬁcation
taken from the bookshelf of the OpenGIS Consortium (OGC). Neither the topic is
critical for this paper, nor is the organization, because our interest lies in design
methodologies
like the International
Standards Organization (ISO) or OGC apply conceptually the same methodology
in designing spatial standards (Berre et al. 2000).

standards. Standards organizations

for

International Journal of Geographical Information Science
ISSN 1365-8816 print/ISSN 1362-3087 online # 2003 Taylor & Francis Ltd
http://www.tandf.co.uk/journals
DOI: 10.1080/13658810310001596067

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 722

S. Winter and S. Nittel

1.1. What is an abstract speciﬁcation?

Software speciﬁcations are abstract in a sense that they describe a domain—in
the scope of this paper: the geographical domain, especially ﬁelds. They are called
abstract speciﬁcations as long as they do not relate to any technology, platform, or
other implementation speciﬁc issues, like data structures, or programming language
constructs. Abstract speciﬁcations are part of the software engineering process; they
are written by computer scientists. Basically abstract speciﬁcations represent a
domain ontology, deﬁning the features of the domain and their behaviour in a
formal
language (Gruber 1993, Guarino 1998). For domain experts—here,
geographers—abstract speciﬁcations may be difﬁcult to read.

However, the domain experts have to check and guarantee that an abstract
speciﬁcation is correct, which means it describes the domain in a way domain
experts perceive it. Checking a speciﬁcation for correctness is a process that needs
extensive communication between the authors and the domain experts, and tools
supporting this communication. The most popular tool is based on a graphical
interface. Graphics appeal intuitively, which gives reason for the popularity of such
a tool. Nevertheless understanding graphics depends heavily on interpretation,
which includes the danger of miscommunication. Our approach will be based on a
language with a formal semantics. This language allows development of executable
speciﬁcations. Thus the communication between authors and domain experts
consists of discussing test cases and their behavior, instead of reading code or
interpreting graphics.

1.2. Why are abstract speciﬁcations important?

Geographical information systems handle spatial features in very different ways.
If systems are to co-operate with each other they need a language to do so. This
language abstracts from implementation issues. Such a language is provided by
standardized interfaces that vendors can add to their systems. Standardized
interfaces can be utilized by other systems without knowledge of proprietary
formats. Each system translates the standardized structures and functionality into
internal structures and methods. Such interfaces are deﬁned by organisations like
OGC and ISO by providing abstract speciﬁcations and standardized ways to
implement them. Thus the bigger goal of standards is interoperability between
systems, allowing data access across platforms and communication between
networked value-adding services.

1.3. What is the contribution of this paper?

The motivation for this paper is twofold:

. The lack of formalized semantics of spatial datasets and operations is
considered as the main handicap in interoperability of spatially enabled
services. Our approach overcomes some aspects of this limitation.

. The lack of speciﬁcation tools that guarantee correctness and consistency
raises costs and efforts in maintenance of standards and hinders standards
organizations from progress. Our approach should be cheaper in maintenance
by providing executable speciﬁcations and guaranteed consistency through the
speciﬁcation life-cycle.

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

723

In fact it is the challenge for standards organizations to deﬁne open interfaces
that can be proven to be consistent, complete, and can be implemented as provably
correct (for compliance testing). Algebraic speciﬁcations help (Guttag and Horning
1978, Lin 1998, Frank 1999). Languages supporting the writing of algebraic
speciﬁcations are functional programming languages, which became mature in the
(Peyton Jones et al. 1999). Functional
last decade, among them Haskell
programming languages provide a formal syntax, code speciﬁes behaviour (the
language atoms are functions) and can be executed (for testing correctness). Thus
they have been proposed for use in standards for several years now (Kuhn 1994,
1997, Frank and Kuhn 1999). However, the idea was not recognized by standards
organizations, probably for reasons of existing skills, apparent comprehensability of
a visual interface, and popularity of other tools—UML is the dominating modeling
language in the software industry (Kobryn 1999).

For that reason our research interest is to prove of practicability of writing a
standard in the functional programming language Haskell, and an investigation of
how far abstraction can be done in this way. The hypothesis was the expectation
that this approach describes the semantic aspect of interfaces (behaviour) formally,
can be communicated easily, can be checked for type consistency, can be tested for
completeness and correctness, and separates clearly between an abstract and an
implementation speciﬁcation. We report our results and experiences here. The
expected advantages are veriﬁed. However negative experiences are reported also:
pure abstract code turns out to appear overloaded and difﬁcult for humans to read.
With this work we contribute to the foundations of standardisation efforts in the
spatial domain, preserving an object oriented modelling approach.

The paper is structured as follows. Section 2 presents the problem of writing
abstract speciﬁcations in the spatial domain, and it summarizes previous work.
Then our running example is presented in §3: the OpenGIS coverage speciﬁcation.
Section 4 gives an overview of algebraic speciﬁcations in functional programming
languages, which is the tool that is applied in §5 for a formal version of the
OpenGIS coverage speciﬁcation. In §6 we investigate the received speciﬁcation for
its properties. Section 7 contains the discussion and conclusions.

2. Problem statement

In this section the context of the paper is introduced in detail. The role of
speciﬁcations for standards is discussed here as well as the speciﬁc challenge to set
up standards in the spatial domain. Then the previous work is presented and related
to the contribution of this paper.

2.1. Speciﬁcations in the context of standards

The problem of building and maintaining large, i.e. complex and heterogeneous
information systems—not only spatial ones—is a problem generally acknowledged
by the software industry (Gibbs 1994). The emerging trend to componentialization
increases the demand for clean software engineering methodologies, as different
components will have to co-operate with each other.

Software engineering provides many techniques and tools supporting the
software development process. One of the most important phases of this process is
the speciﬁcation (Liskov and Zilles 1978, Liskov and Guttag 1986). Speciﬁcations
rely on abstraction, decomposition, and formal notation of a conceptual model and

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 724

S. Winter and S. Nittel

the logical

represent a model at
level of software design (Worboys 1995).
Speciﬁcations describe the what of pieces of a task (‘what are the actors?’, ‘what are
their relations?’, ‘what kind of actions have to be taken?’), not the how (‘how do the
actions have to be executed?’). Hereby, speciﬁcations do not only name the actions
but also describe the restrictions, result and meaning of these actions,
i.e. the
semantic aspects of an action.

Speciﬁcations are essential for standards: standards typically have to describe
what things are, how they should behave, what correct behaviour is, but not how
things should be implemented (data structures and algorithms). Such speciﬁcations
do not make any assumption on technologies for implementation (abstract
speciﬁcations).

In general, three properties of an abstract speciﬁcation have to be veriﬁed:

1. It has to match the problem to be speciﬁed.

This property is assured by agreement of experts (validation); thus the
speciﬁcation has to be communicable to domain experts.

2. It has to be consistent in itself.

This property can be checked automatically if and only if the speciﬁcation
is made in a formal language, and the degree of the check depends on the
(type-) strictness of the language.

3. It has to be complete.

This property can be checked semi-automatically via extensive testing,
especially that of exceptions and strange cases. Testing can be alleviated if the
speciﬁcation is made in an executable language.

interpreting and executing the speciﬁcation.
The latter two require a tool
Speciﬁcations in functional
languages are executable; those in UML are not.
However, also the validation of a functional speciﬁcation (and of implementations)
lacks formal tools.

Standards are speciﬁcations for the whole software vendor and application
development community. Their development far exceeds some of the demands for a
single software product speciﬁcation:

. specifying experts and implementation experts can no longer communicate

. full understanding of

the speciﬁcation has

to be derivable from the

. speciﬁcations with a status of a standard should be consistent and error-free

directly;

speciﬁcation documentation directly;

to avoid costly changes to product;

(ﬂexibility is restricted);

. speciﬁcations with a status of a standard need to have some durability

. speciﬁcations with a status of a standard need general acceptance (only in case
of legal norms—like ISO standards—implementation can be prescribed).

The main challenge for standard speciﬁcations lies in unambiguity. Each vendor
implementing a speciﬁcation realizes an interpretation of the speciﬁcation. For later
interoperability of software, this interpretation has not only to be valid, it has to
match the semantics.

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

725

2.2. Complexity of standards for geographic information

Geographical

information deals with physical, observable reality as well as
social reality (Searle 1995). The objects to be dealt with are partly bounded by
physical boundaries (bona ﬁde), partly bounded by agreement of people (ﬁat)
(Smith and Varzi 1997). Some of the ﬁat objects may have an exact deﬁnition, some
have not. Deﬁnitions of objects (i.e. their boundaries) are a function of observation
context (scale). Observation can never be precise. Thus, dealing with indeterminate
for
boundaries, a variety of contexts and their ontologies is a constituent
geographical information (Burrough and Frank 1996). Standardized speciﬁcations
of spatial phenomena and services are essential for communicating geographical
information (Kuhn 1997, Frank and Kuhn 1999).

In the ﬁeld of geographical information, several institutions work on standards
to achieve interoperability between different service components, among them OGC
(Kottman 1999), ISO (2000), and several others. Also, there is work done to align
different standards, e.g. between OGC and ISO (Østensen 2000).

Interoperability standards for spatial information systems deal not only with
data exchange formats between different systems, but deﬁne spatial entities as
objects with behavior and include a services model such as for standard coordinate
system conversion. Furthermore, standards integrate different forms of representa-
tion seamlessly. Thus, standards for geographical information systems model highly
complex spatial worlds. Speciﬁcation tools and techniques that support unambi-
guity, automatic consistency checking, and modularization are more necessary then
ever.

2.3. Previous work

It becomes clear that the tools used for the speciﬁcation need the capability to
represent and to deal with semantics since all readers of a speciﬁcation should have
the semantics of a speciﬁcation. Current
an unambiguous understanding of
speciﬁcation techniques in standards organizations are based on visual object
oriented modelling in UML (Booch et al. 1999, OMG 2000). UML neither has
formal semantics (Bruel et al. 2000) nor allows formal modelling of the semantic
aspects of expressions. The latter is usually done by comments in text form. For
that reasons, models in UML are not executable.

The requirement in the ﬁeld of geographical

information recently lead to
proposals to use functional languages for writing algebraic speciﬁcations (Egenhofer
and Frank 1992, Frank and Kuhn 1995, 1999; Kuhn, 1997; Frank, 1999). Algebraic
speciﬁcations (Guttag and Horning 1978, Horebeek and Lewi 1989, Loeckx et al.
1996) provide the following features:

. they have a mathematical clean form,
. they are sufﬁciently abstract,
. they are constructive, which means they are executable and their behavior can

be checked, and

. modules can be added to complex systems.

A recent investigation of many-sorted algebraic data models for GIS showed the
usefulness of the approach, but stated the lack of a suitable language (Lin 1998).
The critique on suitable tools is quite old (Backus 1978), however. From our point

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 726

S. Winter and S. Nittel

of view functional programming has overcome the usability problems. Functional
programming languages have formally deﬁned semantics (Stoy 1977, Peyton Jones
1987). Functional languages like Haskell are declarative, operational, and object-
oriented (Peyton Jones et al., 1999, Hudak et al. 1999, Bird 1998), and thus, ﬁt the
need for a usable tool to implement speciﬁcations as many-sorted algebras. The
work of Kuhn and Frank demonstrates the usability of Haskell for capturing the
semantics of expressions (Kuhn 1994, 1997, Frank and Kuhn 1999). Their interest
in expressiveness is acknowledged here; however, a proof of practical applicability
still has to be supplied.

2.4. Contribution of this work

We build on the work above, and use many-sorted algebras as a basis for the
speciﬁcation of a spatial standard. Many-sorted algebras allow speciﬁcation of a
spatial standard in separated modules of, for example, features, geometry, spatial
reference systems, etc., and combining them to a whole. We use Haskell as a
speciﬁcation language since Haskell supports the deﬁnition of operations as pure
mathematical
these
operations formally. Furthermore, it allows us to compile, check and execute the
speciﬁcation.

functions, and also allows to capture the semantics of

Our concern in this work is to use the approach above, to investigate its
practicality and usefulness by selecting a real-world spatial standard, and specifying
the syntactic and semantic aspects of a complete section of this standard formally
via Haskell. We look at questions like: If this approach is advantageous for the
above reasons, does it create at the same time new problems? Is the standard
development process different? What are the consequences for the creation, the
maintenance, and the extension of a standard? Are the efforts for a formal standard
competitive in time and cost? Does the approach have any impact on the domain?
We will report on our ﬁndings and compare them with the practice in standards
development.

3. Standards by OGC: The OpenGIS coverage speciﬁcation

In this

section, we shortly describe the process of how OGC deﬁnes
speciﬁcations. Following, we will introduce the grid coverage as described in the
essential model to introduce the terminology for the classes of the domain. We also
give a short example of
the OGC’s UML speciﬁcation and the resulting
implementation speciﬁcation, and discuss this approach.

3.1. The speciﬁcation process of OGC

OGC is a consortium of industry, academic and government members who meet
regularly to cooperatively deﬁne the OpenGIS Model (Kottman 1999), a standard
for interoperability of GI services and data across different platforms.

In a ﬁrst phase, the OGC members deﬁned the vision, scope and content of the
model (i.e. a seamless model for vector geometry and rasters as well as a service
is documented in the abstract speciﬁcation. The abstract
model). The result
speciﬁcation does—like a speciﬁcation during the software engineering process—
describe the problem and tasks without making any assumptions of possible
technologies that might be used to implement it. The abstract speciﬁcation consists

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

727

of two parts: a verbal description, the essential model, and a semi-formal abstract
model using UML. Today, the abstract speciﬁcation consists of 16 chapters.

for

from its members.

implementation speciﬁcation proposals

To achieve practical interoperability, GIS software itself has to be interoperable;
thus, based on the abstract speciﬁcation, OGC uses a Request-for-Proposal process
to call
(For
practicality reasons, these RFPs are for well-deﬁned subparts of the abstract
speciﬁcations. For example, the implementation speciﬁcation for geometry was
limited in a ﬁrst step to the so-called simple features.) An implementation
speciﬁcation uses the abstract speciﬁcation, and makes a suggestion of how its
concepts should be best implemented using most likely technologies such as SQL,
Java, XML, Microsoft’s COM/OLEDB, or OMG’s CORBA. The selected
technologies depend on the state of the art of widely-used distributed computing
platforms. These might change over time, and new implementation speciﬁcations
might be added still based on the existing abstract speciﬁcation. There is one
information speciﬁcation per platform, and the proposers have to make sure that
the implementation speciﬁcations for different platforms are consistent, especially
semantically consistent. Implementation speciﬁcation proposals are reviewed by the
OGC members and voted on for acceptance as standards. Implementation speci-
ﬁcations are maintained and aligned with each other during a revision process. At
this point, companies start building products based on an implementation
speciﬁcation that exhibit the implementation speciﬁcation interfaces. Products
can then be branded OGC-compliant if they fulﬁll an OGC conformance test.

For this paper, we select the coverage chapter of the abstract speciﬁcation (OGC
2000b), and concentrate on grid coverage, for which recently an implementation
speciﬁcation has been adopted (OGC 2000a).

3.2. The OpenGIS essential model for coverage

Coverage is coined by OGC for all kinds of ﬁeld representations: grid, image,
TIN, polyhedral surface, and more. Coverage is deﬁned as a special subtype of a
feature. In the OpenGIS model, feature is the main concept for any kind of spatial
entity. A feature has properties deﬁned as a list of pairs of property name and
property value.

A coverage contains a special property, a coverage function (cfunction). (A
coverage might have one or more cfunctions.) A cfunction is a function that has a
spatial domain, and a set of values as range. Typically, the spatial domain of the
cfunction is a set of (any) geometries. (In the OpenGIS model, geometries are (sets
of) any kind of point, line, or polygon.) For each geometry in the spatial domain,
the cfunction evaluates the value at this location. The general concept of a value is a
vector v of single values of different types. An example would be the temperature
and the rainfall at a given point. Thus, the range of a cfunction is a set of
homogeneous vectors. When a cfunction has a continuous spatial domain,
it
calculates a value for each point in the spatial domain via interpolation. In a
simpler case, if the spatial domain is discrete, i.e. it encompasses a ﬁnite set of
geometries, the cfunction is called a discrete cfunction. Finally, if the spatial domain
is restricted to a ﬁnite set of points, we talk about a discrete point cfunction.

Grids are closely related to discrete point cfunctions. In the special case of a grid
geometry, the domain of the cfunction is a ﬁnite set of points in regular order.
Using the grid geometry as a spatial domain, the abstract speciﬁcation introduces

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 728

S. Winter and S. Nittel

another specialized discrete point cfunction, the grid value matrix. The grid value
matrix consists of a set of point-value-pairs whereby the points form a grid. A grid
coverage is a specialized coverage containing a grid value matrix as specialized
cfunction. Furthermore, a grid coverage has an evaluator which evaluates the value
for each grid point. If the domain of a grid coverage is extended to the convex hull
of a grid, the evaluator can implement an interpolation function to calculate values
for each point in the convex hull. Several interpolation algorithms are used today;
nearest neighbour is the most common, and is the default function in the OpenGIS
speciﬁcation.

3.3. The OpenGIS abstract model for coverage

The essential model above verbally captures the scope of our example. In a
second step, the objects of the essential model, their relations, and their properties
are abstracted and represented in UML. We select from OGC’s abstract model the
cfunction and the discrete cfunction to demonstrate the properties of such a semi-
formal representation.

Figure 1 depicts a UML representation of the CFunction, and its relationship to
Coverage. In UML, the arrow between Coverage and CFunction represents a
dependency relationship between an independent Coverage and a dependent
CFunction. However, this presentation is ambiguous since the relation is not
named;
if it should represent an association it does not contain multiplicity
information: has a coverage exactly one, or at least one CFunction? Furthermore,
the diagram shows that a CFunction has two methods, evaluate and domain, and
speciﬁes their input and output data types. Invisible here but attached to the
diagram a textual description of parameters and methods can exist. These textual
descriptions are repeated in the textual part of the abstract model making them
visible in the document. The semantic aspect is still not captured formally.

Figure 2 models when a DiscreteCFunction is a special case of a CFunction;
thus, DiscreteCFunction inherits all methods from CFunction and is able to
overwrite them, and new methods can be added. In UML, the semantics of an
inheritance arrow is clearer than that of a dependency.

Figure 3 depicts a DiscreteCFunction in a context with Coverage. One can see
that the domain of a DiscreteCFunction is discrete and ﬁnite, since it returns a
ﬁnite list of geometries. However,
the presentation does not capture which
geometry arguments are acceptable for the evaluate function. It might be that any

Figure 1. The UML context diagram of OGC for CFunction.

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

729

Figure 2. The UML class diagram of OGC for DiscreteCFunction.

Figure 3. The UML context diagram of OGC for DiscreteCFunction.

geometry types are acceptable, or only geometry objects of the type found in the
function’s domain.

3.4. Discussion of the OGC approach

This process demonstrates that the use of UML in the abstract speciﬁcation is
only semi-formal with important portions of the speciﬁcation written in English.
The UML part is open to interpretations, and so far ambiguous. Furthermore, the
correctness of the UML model cannot be guaranteed or tested.

A quick comparison of the draft implementation speciﬁcation for grid coverage
with the presented abstract model shows changes in the implementation. The non-
formal derivation of the implementation speciﬁcation from the abstract speciﬁca-
tion allows implementors to interpret the abstract speciﬁcation, and make decisions
that are not aligned with the intention of
the abstract model. Where the
implementation speciﬁcation can solve problems with an imperfect abstract
initiated.
speciﬁcation, a revision of
Additionally,
implementation speciﬁcations for different platforms have to be
aligned, which is also a process managed informally in OGC. Many of the problems
would be solved if implementation speciﬁcations were derived from the abstract
model automatically for all platforms (Berre et al. 2000). Again, this requires a
formal abstract model and a way to check the correctness and completeness of the
abstract model. For these reasons we propose another, more formal tool for the
abstract speciﬁcation.

speciﬁcation should be

the abstract

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 730

S. Winter and S. Nittel

4. Functional languages for spatial standards

Here, we recapitulate algebraic speciﬁcation as one of

today’s advanced
software engineering techniques. We choose a functional programming language to
write our algebraic speciﬁcations, and present the principles of the language.

4.1. Algebraic speciﬁcations

An algebra captures the coordinated behaviour of a set of operations that are
applied to the same object. An algebra consists of three parts: a type, a set of
operations, and the behaviour (or semantic) of the operations which is deﬁned by
axioms. An algebra does not describe what the objects are but how they behave,
and captures the semantics of this behaviour. Algebras can be used to specify
abstract data types by behaviour, and do not determine the implementation
(Horebeek and Lewi 1989, Loeckx et al. 1996). Consider for example a possible
algebra of points, given by a type (or sort in terms of algebra) Points, two
operations getX, getY on the type, which return the coordinates of a point, and
an axiom for equality of two points a and b: equal a b~(getX a~~getX b)
&& (getY a~~getY b). Note that the axiom is independent from the internal
implementation of points; it deﬁnes behaviour (or semantics) only.

Many-sorted algebras (Guttag and Horning 1978, Horebeek and Lewi 1989,
Loeckx et al. 1996) are structures consisting of some sets of objects (types) and a
number of functions whose arguments and results belong to these sets (Horebeek
and Lewi 1989, p. 15). Consider a second type Lines. If there are operations start
and end to return the start and end point of a line, then an axiom concatenated can
be deﬁned that checks whether two lines are concatenating. The type declaration
would be concatenated :: LinespLinespBool, and the speciﬁcation of
the behaviour could look like concatenated a b~(start a~~start
b)d(start a~~end b)d(end a~~start b)d(end a~~end b).

Consider an example related to OGC speciﬁcations, on (spatial) features and
their properties. For OGC a feature has an identiﬁer and a list of properties; one of
the properties is the geometry of the feature, which can be accessed directly. The
algebra of Features utilizes objects of the type Properties;
it provides
operations and axioms on features. Typical operations could be getFeature-
Properties: Featurep[Property], where the square brackets denote a list,
or getGeometry :: FeaturepProperty. A second algebra speciﬁes opera-
tions and axioms for Properties. Then both algebras can be composed with no
internal adaptation.

Composability of many-sorted algebras allow a piece-wise development of the
speciﬁcation. The pieces can be composed as long as types are pair-wise disjoint and
no naming conﬂict occurs. Composability is essential for speciﬁcations in complex
domains like the spatial. It is part of the abstraction of the domain (Liskov and
Guttag 1986). In executable algebraic speciﬁcations pieces can be tested separatly
for correctness and completeness, and afterwards combined to more complex parts.

4.2. Functional programming languages for algebraic speciﬁcations

Using functional programming languages (Backus 1978, Henson 1987, Jones
1995, Frank and Kuhn 1995, Bird 1998) for writing speciﬁcations, the mathematical
foundation of many-sorted algebras is preserved, and additional advantages are
obtained from automatic processing and interpreting the code. Functional

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

731

languages appear to be a natural means of describing algebras. The examples above
were given in the syntax of Haskell, the functional language of our choice. The code
for points looks like:

class Points p where
x
y
equal :: ppppBool
equal a b~(x a~~x b) && (y a~~y b) – axiom deﬁnition

– operation declaration
– operation declaration
– axiom declaration

:: ppFloat
:: ppFloat

An algebraic speciﬁcation written in Haskell consists of classes (for the types of the
algebras) and functions that describe axioms as well as operations. Functions
deﬁned at class level represent axioms, and functions deﬁned at instance level
represent operations. Consider the example of points. The function equal could be
deﬁned on class level. For the operations returning coordinates we need an instance
for an explicit data type:

data Point~Pt String Float Float
instance Points Point where
x (Pt name xval yval)~xval
y (Pt name xval yval)~yval

– operation deﬁnition
– operation deﬁnition

Compilers or interpreters of the language ﬁrst parse the code. Code accepted by a
parser is written in correct syntax. Further checks depend on the speciﬁc properties
of the chosen language. We decided to specify in Haskell (Bird 1998, Hudak et al.
1999), or, to be precise, in an implementation of Haskell called Hugs (Jones et al.
2000). Haskell has a number of properties recommending its use for algebraic
speciﬁcation:

. Haskell is a strongly typed language, i.e., each type has to be unambiguous at
compile time. For that reason, code accepted by a compiler or an interpreter
guarantees type consistency.

. Related to the type concept, Haskell allows no side effects, which eliminates

unforseen interactions and makes the behaviour transparent.

. Haskell

is a polymorphic typed language. Classes and functions can be
instantiated for different types, which increases re-usability of code. More-
supports multiple inheritance and
over,
overloading; this will be exploited in the following for modularization.

the class concept of Haskell

. Modularity accomplishes the requirement for abstraction and decomposition.
Furthermore, it resolves the naming problems combining different algebras by
providing qualiﬁed namespaces.

. Haskell

is a declarative language.

the necessary level of
abstractness for speciﬁcations by describing exactly the what and not the
how. This makes the code extremely compact and readable, compared to
imperative languages. Declarativeness captures the semantics of function
signatures.

It provides

. The class concept and declarativeness allow to specify constructors that
extend an initial speciﬁcation, consisting of a class name and the declaration
of its functions only, to a constructive speciﬁcation (Loeckx 1987, Loeckx

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 732

S. Winter and S. Nittel

et al. 1996). Constructive speciﬁcations are executable;
i.e. constructive
speciﬁcations represent at the same time prototypes of the speciﬁed program.
Constructive speciﬁcations have an operational
the
behaviour of the program.

semantic which is

Consider points again. An executable speciﬁcation can be tested, like:

a, b :: Point
a~Pt ‘‘pointA’’ 45.9 57.6
b~Pt ‘‘pointB’’ 49.3 53.1
test~equal a b

In the next section we use Haskell for a many-sorted algebraic constructive
speciﬁcation of the grid coverage.

5. A functional version of the OpenGIS coverage speciﬁcation

In this section the coverage abstract model is presented in an alternative form,
as an application of Haskell. In principle, there are two approaches to achieve a
formal speciﬁcation from the OGC documents:

1. One can start from the essential model, then extract the objects and the
relations from the essential model, and put them into a functional language.
2. One can start from the abstract model, taking the objects and relations and

translate them into a functional language.

The ﬁrst approach yields a speciﬁcation which is nearly independent from the
abstract model of OGC. Differences would relate more to different abstractions and
conceptualizations than to different capabilities of the used tools UML and
Haskell. The second approach relies on the abstraction in OGC’s abstract model.
Thus it has to cope with the ambiguity and inconsistency of the UML speciﬁcation.
However, the goal of this investigation is a comparison of expressiveness and
practicability of tools and not of the speciﬁcations, and therefore the second
language is
approach is chosen. The transition from UML to the functional
described by examples that show the similarities and the differences compared to
the UML model. These similarities and differences are discussed.

5.1. The classes and function declarations

In this section the UML classes and operations are translated into Haskell
classes and function declarations. Behaviour (function deﬁnitions) will be added in
the next section.

Consider the (UML-)class CFunction in ﬁgure 1. Representing a class

CFunctions in Haskell looks like:

class CFunctions cf where

evaluate :: cfpGeometrypVector
domain :: cfp[Geometry]

The class contains the declaration of two functions, evaluate and domain. The
function evaluate takes a CFunction of the abstract data type cf and a

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

733

geometry, and returns a vector of function values. The implicit meaning that the
vector contains the values at the given location of the geometry will be explicated
later. The function domain takes a CFunction, and returns a list of geometries.
Again the meaning that the geometries represent the domain of the coverage
function is explicated later.

Declarations introduce the names of functions and their parameter types. So far
the code example shown above has exactly the same power of expressiveness as the
UML code of ﬁgure 1. A minor difference (which is not visible in this example) is
evident in the constraint that in Haskell everything has to be written as a function:
even parameters in UML classes will be functions in Haskell (the UML class
CFunction contains no parameters). From the perspective of an abstract
speciﬁcation—i.e. a speciﬁcation with no reference to implementation speciﬁc
details or architectures—this is an advantage: the abstract speciﬁcation in Haskell is
restricted clearly to interfaces,
it does not allow decisions about how to code
parameters.

A closer look at the example shows signiﬁcant differences between the UML

and the Haskell speciﬁcation of a CFunction:

. We decided to describe the domain via a list of geometries, where the UML
speciﬁcation shows only a single geometry. This is not a contradiction because
OGC considers lists of geometries to be a geometry (GeometryCollection)
again. However, in the class DiscreteCFunction (ﬁgure 3) the UML code
uses lists for the domain, too. We need a consistent notation for the type
checking system of Haskell.

. Another difference can be found in the parameter type of the evaluation
function in CFunctions. OGC’s UML code shows a point where we decided
to put in a geometry. One reason is again type consistency with the inheriting
class DiscreteCFunction. Another reason is an inconsistency in OGC’s
text with its UML code; the text demands that the function parameter has to
use the geometry type of the domain of the CFunction, otherwise the function
should return an error.

The correct speciﬁcation of the UML-class DiscreteCFunction (ﬁgure 3) is in
Haskell:

class CFunctions a)DiscreteCFunctions a where

num :: apInt
values :: ap[Vector]

The functions evaluate and domain are inherited and need not to be

Following this approach the UML model of OGC can be translated into

Haskell with the same power of expression but more consistency.

declared again.

5.2. Semantics

Semantics of declarations in UML as well as in Haskell are captured mostly in
the names of the declared classes and functions. The abstract model of OGC uses
extensive verbal descriptions to document the meanings of classes and the behavior

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 734

S. Winter and S. Nittel

of their interfaces. These descriptions need to be interpreted by readers of the
abstract model. In contrast, Haskell allows speciﬁcation of semantics in a formal
manner.

Given a declaration of the function domain (see above), one can add its

behaviour by:

domain cf~map geom (getGVPs cf)

getGVPs is an operation in the algebra of cfunctions returning the geometry-
value-pairs that form the cfunction. The function geom is an operation in the
algebra of geometry-value-pairs. It returns the geometry for a given geometry-
value-pair. Finally, map is an operation in the algebra of lists, which is in-build in
Haskell. It maps a function on each element of a list, returning the list of function
results. Thus the code deﬁnes the semantic of domain by stating that the domain of
a cfunction is the list of all geometries that are contained in the cfunction’s deﬁning
geometry-value-pairs.

Similarly the two functions of DiscreteCFunctions can be deﬁned,

specifying their semantics formally:

num dcf ~length (domain dcf)
values dcf~map value (getGVPs dcf)

The num method returns the cardinality of the domain. This is determined by the
length of the list of all geometries, which is ﬁnite since DiscreteCFunction has
a ﬁnite domain. The values method returns the list of values of all geometry-value-
pairs that deﬁne the DiscreteCFunction.

The examples show that implementations in Haskell specify behaviour, not
algorithms. By that, function implementations remain compact and comprehensive,
i.e. the formal speciﬁcation of semantics can be communicated.

5.3. Abstraction

The Haskell examples from above were kept simple for comprehensability. A
functional programmer would probably start with them, but then the code can be
speciﬁcation from all
improved with the goal of
implementation issues. The above examples still contain references to concrete
data structures in the typed declarations, namely Geometry and Vector. The use
of data types can be eliminated by introducing abstract classes (Geometries,
Vectors) which describe the behaviour of abstract types (g, v). After revision the
speciﬁcation is purely abstract:

separating an abstract

class (Geometries g, Vectors v)

)CFunctions a g v | apg v
where

evaluate
domain

:: apgpv
:: ap [g]

Thus, this speciﬁcation is about semantics of types, not about their implementation,
a desirable property for abstract speciﬁcations. Implementation decisions for data

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

735

types can be shifted completely to the realization of classes in instances, for
example:

instance CFunctions CFunction Geometry Vector

where the data types CFunction, Geometry, and Vector replace the abstract
data types of the speciﬁcation. Abstraction in this way shifts commitments for data
types through dependency chains to base classes. Base classes have no further
dependencies. In the coverage speciﬁcation, an example of a base class is
PropertyValues. This class is needed only for ﬁxing a data type, and no
functions need to be speciﬁed:

class PropertyValues a
instance PropertyValues PropertyValue

executable. Adding instances

Thus the abstract speciﬁcation can be limited to class declarations only. This set of
class declarations can be checked for type consistency. However, pure class
declarations are not
semantic
speciﬁcation and links to data types for executability. Instances are comparable
to implementation speciﬁcations of OGC, if they are considered as interpretations of
the abstract speciﬁcation for a programming environment. Here the environment is
Haskell, and we remain still independent from speciﬁc technologies like CORBA or
COM. Abstract and implementation speciﬁcation together can be executed and
tested.

completes

the

5.4. The grid coverage in Haskell

Following the approach presented above the grid coverage section from OGC’s
speciﬁcation Coverage and its Subtypes (OGC 2000b) was transferred into Haskell.
In this section, we present our ﬁndings.

The complete code of the formal speciﬁcation is available via ftp from ftp://
ftp.geoinfo.tuwien.ac.at/winter/. The unzipped package can be viewed by a normal
text editor, and it can be tested using Hugs (Jones et al. 2000), which is public
domain software.

Coverage and grid coverage are speciﬁed in about 20 modules/classes. The size
of the pure abstract speciﬁcation is more compact than OGC’s abstract model.
However, we added constructors and test data for test cases, which increases the
volume to about 20 A4 pages.

Characteristics of the Haskell speciﬁcation are:

. A class hierarchy CFunctions, DiscreteCFunctions, Discrete-
PointCFunctions, and GridValueMatrices. GridValueMatrices
are composed by array collections. Each array has to have a constant data
type, and the arrays have to have the same origin, orientation, resolution and
size. Orthogonal to the matrices, PointValuePairs exist which represent
the values at one grid position (or,
the evaluation function allows
interpolation, at any point in the grid coverage area).

if

. A class hierarchy Feature, Coverage, and GridCoverage. The

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 736

S. Winter and S. Nittel

GridCoverage is a feature represented by a (distinctive) property with the
name ‘‘CFunction’’ and the value GridValueMatrix.

. A class for AnyType, a complex data type that can be anything, a number, a
string, a geometry, or a CFunction. This type is used for the property values
of feature properties. Methods of the class AnyType allow determination of
the actual type as well as the value of the property.

One goal of the formal speciﬁcation in Haskell is the proof of practicality. For
that reason, we cover only a well-deﬁned subset of the abstract speciﬁcation,
namely coverage and grid coverage, and set out to achieve similar completeness for
the other parts of this abstract model.

6. Properties of the functional speciﬁcation

The Haskell package representing an abstract model of coverage and grid
coverage is executable and can be tested. We report here about the proof of
consistency and about the checks for correctness and completeness.

6.1. Consistency

Having the speciﬁcation in a formal typed language, (internal) consistency can
be checked automatically. The Haskell interpreter checks syntax and grammar, not
the semantics. Take again the domain example:

domain :: cfp[Geometry]
domain cf~map geom (getGVPs cf)

While loading the module, the Haskell
interpreter parses the code (it is valid
Haskell, so no objections will occur) and checks the chain of types in the called
functions. To do so the function declarations are utilized:

p The method getGVPS takes a CFunction and returns a list of

GeometryValuePairs.

p The method map takes a function (here: geom) and maps it onto a list. The
the function: geom takes a

result
GeometryValuePair from the list and returns a Geometry.

is a list of

the output

type of

p That means the method domain takes a CFunction and returns a list of

Geometries.

The consistency check for domain will succeed, because the types ﬁt together,
and the chain matches with the declaration of domain. Because the check of
consistency passes automatically and for the complete code, we can state that
consistency is proven if a module or package is loaded successfully. Contexts and
type dependencies in abstracted speciﬁcations load a lot of additional type checking
work to the interpreter, but the tasks are mainly the same, and type conﬂicts will be
recognized by the interpreter.

Speciﬁcation tools for UML support checking of consistency not with this
strictness. Neither the language UML is a typed language, nor an interpreter for
UML is available.

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

737

6.2. Correctness

Some of our interpretations of the essential model of OGC may give reason for
discussion. This is a desirable property of a formal speciﬁcation: it should improve
communication between domain experts (i.e. the authors of the essential model)
and formalists (the authors of the abstract model). If contradictions between the
two models or misinterpretations of the essential model can be easily identiﬁed
and eliminated, the speciﬁcation method is useful. Furthermore, the abstract model
in Haskell is executable. It allows testing of behaviour, i.e. domain experts only
have to check and to accept the behaviour. Behavior is communicated and
discussed in the form of test cases (critical ground terms) which can be set up in
Haskell easily. Execution of the tests check that the values of the test cases are the
values expected.

Our Haskell speciﬁcation shows some differences to OGC’s abstract model in
UML. This is due to the fact that we were required to make design decisions that
captured not only the parts but also the relationships between the parts in a
coherent, and compilable way. Additionally we speciﬁed constructors among the
operations, creating constructive speciﬁcations. In this sense, we produced a
speciﬁcation that is closer to an implementation speciﬁcation, and thus, narrows the
gap between an abstract and an implementation speciﬁcation.

The development of the Haskell speciﬁcation showed signiﬁcant shortcomings
of OGC’s abstract model. These shortcomings exist regarding deﬁnitions that could
be consistent, but are not correct when tested. Examples are:

. Evaluation of coverage. All types of CFunctions use a multi-type value
the Evaluator represents one single evaluation (or
for multi-type value vectors

vector. However,
interpolation) method, which is not useful
(multitype vectors are allowed explicitly).

. Inheritance of properties, like Evaluator or SpatialReferenceSystem,
through the hierarchy of CFunctions, GridValueMatrix, and Grid-
Coverage, is not evident in the abstract model. That leaves no signiﬁcant
difference between GridValueMatrix and GridCoverage, because all
required properties for the GridCoverage are taken from higher classes and
are not unique for the GridCoverage.

What cannot be checked in the consistency check is the behaviour of func-
tions. This exceeds internal correctness and refers to a correct formal representa-
tion of another model, the essential model of the domain. Only the domain
expert
can guarantee
correctness.

the behaviour; no automatic

can evaluate

routine

One possibility to check behaviour is reading, understanding and accepting the
code. Compared to imperative programming languages, declarative code is
extremely compact and could be understood easily by Haskell programming
experts. However, because the validation of behavior has
to be done in
coordination with domain experts, code may not be the best way to communicate.
An alternative is to check behaviour by examples. Choosing typical, simple or even
trivial examples from the speciﬁed domain eases communication with domain
experts in evaluating the result. Consider again the domain method. Given any
simple CFunction the method domain can be applied on it, and the result can
be evaluated:

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 738

S. Winter and S. Nittel

cf :: CFunction
cf~†
test :: [Geometry]
test~domain cf

We conclude that
tests of behavior are easy to provide in an interpreter
environment. Our Haskell modules typically have implemented some test functions
at the end of each ﬁle; they can be called directly.

6.3. Completeness

We made several short cuts in the functional speciﬁcation. For instance,
Features are simpliﬁed here, and also we do not consider non-regular
DiscretePointCFunctions. Doing so we achieve a (more or less) complete
functional speciﬁcation with regard to the chosen topics from the essential model.
Additions can be made by merging other algebras, e.g. for Features. Merging
algebraic speciﬁcations do not require any changes inside a given speciﬁcations.
This is especially true for speciﬁcation tools that provide namespaces, like Haskell
with its concept of qualiﬁed import.

After the agreement that the speciﬁcation reﬂects the purposes of the essential
model, tests can be continued to check the treatment of extremal test cases. The
procedure is in principle the same as before. As a result, it could be stated which
extremal cases or exceptions are covered by the speciﬁcation.

7. Discussion and conclusions
7.1. Summary

We proposed a formal tool for specifying spatial standards, using a functional
programming language for writing many-sorted algebras. We exempliﬁed the
applicability for a topic from the OpenGIS Consortium’s bookshelf. Our formal
version of that abstract model could be compared in detail and as a whole with
OGC’s abstract model as well as with OGC’s implementation model for the grid
coverage. We veriﬁed some (expected) advantages of the formal speciﬁcation: a
formal semantic of speciﬁed interfaces, an executable prototype, guaranteed
consistency, an extendable algebraic structure, a total abstraction from implemen-
tation. Additionally, we exempliﬁed the complexity of abstract formal code, and we
argued that communication of the speciﬁcation should be made through its
behaviour instead of its code.

Our formal speciﬁcation remains incomplete with regard to OGC’s coverage
speciﬁcation. With the presented speciﬁcation procedure, other parts of OGC’s
speciﬁcation could be added,
like triangulated irregular networks, or Thiessen
polygons. We remain incomplete also with regard to cuts at the limits of our
selected topic; for example, the class Features is realized only in its most
primitive version. Features are treated in another book of OGC. A many-sorted
algebra for Features can be added easily, replacing our poor version. Hugs
supports the composition by separating the namespaces of modules.

The provided formal speciﬁcation contains constructor functions and utilizes
them for test cases. Test cases show the behaviour of the speciﬁcation. Their
real value lies in the possibility for implementers to check the behaviour of
their implementation against the behaviour of the speciﬁcation. Conformance

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

739

testing—up to now an external and expensive process—could proﬁt from this
property by delivering the conformance test cases together with the speciﬁcation for
in-house testing.

7.2. Conclusions and future work
We have shown that

formal

speciﬁcations

in functional

languages are
manageable and turn out to be valuable. The applied speciﬁcation technique is
superior to semi-formal visual modelling in UML due to formal semantic,
consistency, and executability. It is to be expected that such speciﬁcations are
in application development and conformance testing. Even more
cheaper
it is to be expected that such speciﬁcations are easier to maintain,
important,
due to automatic checks and direct testing capabilities. Therefore, the approach can
be recommended to apply the technique in spatial standards organizations.

From a scientiﬁc perspective, we have shown how to separate abstract and
implementation parts in formal speciﬁcations. Further we have made clear the
differences between a semi-formal and a formal speciﬁcation, and developing the
formal version forced us to solve the inconsistencies in the existing semi-formal
speciﬁcation. We see the following open questions.

. Can abstract modelling in Haskell be supported by a visual tool similar to

UML?
Looking at our procedure—we took the UML classes and methods as they
are—we expect that a visual tool similar to UML-tools would help to create
speciﬁcations from scratch. We expect also that such an improvement of the
user interface would improve the acceptance of Haskell
in the standards
community.

. Can a formal speciﬁcation be transformed automatically in less formal

speciﬁcations, e.g. in UML?
This idea could improve the acceptance, too. In principle, there is no problem,
because class names, class dependencies, and function names and types can be
taken directly from the functional code. However, putting this in UML
speciﬁcation, with the loss of all behavioural
provides a less
information. A special problem is
function
deﬁnitions into readable text.

the translation of

formal

formal

. Can an OGC implementation speciﬁcation be derived automatically from

Haskell?
Implementation speciﬁcations are provided for several technologies by OGC.
It would be desirable to derive these speciﬁcations automatically, i.e. aligned
in their semantic.

. How far can we go with Haskell?

We have shown that a single topic of OGC’s bookshelf can be speciﬁed in
Haskell. Also we have stated that other algebras can be added without any
difﬁculty. Further, in Haskell a speciﬁcation is identical to its prototype. Once
the complete bookshelf is speciﬁed in Haskell, one has at the same time a GIS
prototype conforming with the OGC standard (better: realizing the OGC
standard).

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 740

S. Winter and S. Nittel

Acknowledgments

Gerhard Navratil and Andrew Frank, both TU Vienna, gave valuable input and
ideas to improve the functional speciﬁcation. Also we gratefully acknowledge the
help of Cliff Kottman, OGC, in interpreting OGC’s abstract speciﬁcation Topic 6:
The Coverage and its Subtypes.

References
BACKUS, J., 1978, Can programming be liberated from the von Neumann style? A functional
style and its algebra of programs. Communications of the ACM, 21, 613–641.
BERRE, A. J., SKOGAN, D., GRONMO, R., SOLHEIM, I., HOFF, H., and SKJELLAUG, B., 2000,
Practising the ISO/TC 211 approach to GI interoperability. In Space Applications
Institute, 6th EC-GI&GIS Workshop Lyon (Brussels: European Commission, Joint
Research Centre).

BIRD, R., 1998, Introduction to Functional Programming Using Haskell. Series in Computer

Science (Hemel Hempstead, UK: Prentice Hall Europe).

BOOCH, G., RUMBAUGH, J., and JACOBSON, I., 1999, The Uniﬁed Modeling Language

Reference Manual (Reading: Addison-Wesley).

BRUEL, J.-M., EVANS, A., FRANCE, R., LANO, K., KENT, S., MOREIRA, A., and RUMPE, B.,
2000, The precise UML group home page. Technical report http://www.cs.york.
ac.uk/puml/index.html.

BURROUGH, P. A., and FRANK, A. U. (editors), 1996, Geographic Objects with Indeterminate

Boundaries (London: Taylor & Francis).

EGENHOFER, M. J., and FRANK, A. U., 1992, Object oriented modeling for GIS. Journal of

the Urban and Regional Information Systems, 4, 3–19.

FRANK, A. U., 1999, One step up the abstraction ladder: Combining algebras—From
functional pieces to a whole. In Spatial Information Theory. Vol. 1661 of Lecture
Notes in Computer Science, edited by C. Fieksa and D. M. Mark (Berlin: Springer-
Verlag), pp. 95–107.

FRANK, A. U., and KUHN, W., 1995, Specifying open GIS with functional languages. In
Advances in Spatial Databases. Vol. 951 Lecture Notes in Computer Science, edited
by M. J. Egenhofer, J. R. Herring (Berlin: Springer), pp. 184–195.

FRANK, A. U., and KUHN, W., 1999, A speciﬁcation language for interoperable GIS. In
Interoperating Geographic Information Systems, edited by M. F. Goodchild, M.
Egenhofer, R. Fegeas, C. Kottman (Norwell, MA: Kluwer), pp. 123–132.

GIBBS, W. W., 1994, Software’s chronic crisis. Scientiﬁc American, 271, 72–81.
GRUBER, T. R., 1993, Toward principles for the design of ontologies used for knowledge
sharing. Technical report ksl 93-04, Knowledge Systems Laboratory, Stanford
University.

GUARINO, N., 1998, Formal ontology and information systems. In 1st International
Conference on Formal Ontology in Information Systems, edited by N. Guarino, (Ed.),
(Trento, Italy: IOS Press) pp. 3–15.

GUTTAG, J. V., and HORNING, J. J., 1978, The algebraic speciﬁcation of abstract data types.

HENSON, M. C., 1987, Elements of Functional Languages. Computer Science Texts (Oxford:

HOREBEEK, I. V., and LEWI, J., 1989, Algebraic Speciﬁcations in Software Engineering

Acta Informatica, 10, 27–52.

Blackwell Scientiﬁc Publications).

(Berlin: Springer-Verlag).

HUDAK, P., PETERSON, J., and FASEL, J. H., 1999, A gentle introduction to Haskell 98.

Technical report, http://www.haskell.org/tutorial/.

ISO, 2000, ISO/TC 211 programme of work. Technical report http://www.statkart.no/

isotc211/pow.htm.

JONES, M. P., 1995, Functional programming with overloading and higher-order
polymorphism. In Advanced Functional Programming, edited by J. Jeuring, E.
Meijer, Vol. 925, Lecture Notes in Computer Science (Berlin: Springer), pp. 97–136.
JONES, M. P., and REID, A. and YALE HASKELL GROUP, 2000, Hugs online. The Hugs 98

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 Standardisation in the spatial domain

741

system home page, http://www.haskell.org/hugs/, Oregon Graduate Institute of
Science and Technology.

KOBRYN, C., 1999, UML 2001: A standardization odyssey. Communications of the ACM, 42,

29–37.

KOTTMAN, C. A., 1999, The Open GIS Consortium and progress toward interoperability in
GIS. In Interoperating Geographic Information Systems, edited by M. F. Goodchild,
M. Egenhofer, R. Fegeas, C. Kottman (Norwell, MA: Kluwer), pp. 39–54.
KUHN, W., 1994, Deﬁning semantics for spatial data transfers. In Waugh, T. C., Healey,
R. G. (Eds.), Advances in GIS Research—Proceedings of 6th International Symposium
on Spatial Data Handling (Edinburgh:
International Geographical Union),
pp. 973–987.

KUHN, W., 1997, Approaching the issue of information loss in geographic data transfers.

Geographical Systems, 4, 261–276.

LIN, F.-T., 1998, Many sorted algebraic data models for GIS. International Journal of

Geographical Information Science, 12, 765–788.

LISKOV, B., and GUTTAG, J., 1986, Abstraction and Speciﬁcation in Program Development.
The MIT Electrical Engineering and Computer Science Series (Cambridge, MA: MIT
Press).

LISKOV, B., and ZILLES, S., 1978, An introduction to formal speciﬁcations of data
abstractions. In Current Trends in Programming Methodology. Vol. 1. edited by R. T.
Yeh (Englewood Cliffs, N.J.: Prentice-Hall), pp. 1–33.

LOECKX, J., 1987, Algorithmic speciﬁcations: a constructive speciﬁcation method for abstract
data types. ACM Transactions on Programming Languages and Systems, 9, 646–685.
LOECKX, J., EHRICH, H.-D., and WOLF, M., 1996, Speciﬁcation of Abstract Data Types

(Chichester: Wiley-Teubner).
OGC, 2000a, OpenGIS grid coverages

implementation speciﬁcation.

Implementation

Speciﬁcation Draft Version 1.0, Open GIS Consortium.

OGC, 2000b, The OpenGIS speciﬁcation model, topic 6: The coverage type and its subtypes.

Tech. Rep. 00-106, Open GIS Consortium, Inc.

OMG, 2000, UML resource page. Tech. rep., http://www.omg.org/uml/.
Østensen, O., 2000, Joint steering group on spatial standardization and related interoper-

ability. Technical report http://www.spatialstandards.org/.

PEYTON JONES, S., HUGHES, J., AUGUSTSSON, L., BARTON, D., BOUTEL, B., BURTON, W.,
FASEL, J., HAMMOND, K., HINZE, R., HUDAK, P., JOHNSSON, T., JONES, M.,
LAUNCHBURY, J., MEIJER, E., PETERSON, J., REID, A., RUNCIMAN, C., and
WADLER, P., 1999, Haskell 98: A non-strict, purely functional language. Technical
report http://www.haskell.org/onlinereport/.

PEYTON JONES, S. L., 1987, The Implementation of Functional Programming Languages.
Prentice Hall International Series in Computer Science. (New York: Prentice Hall).

SEARLE, J. R., 1995, The Construction of Social Reality (New York: The Free Press).
SMITH, B., and VARZI, A. C., 1997, Fiat and bona ﬁde boundaries: Towards an ontology of
spatially extended objects. In Spatial Information Theory (COSIT ’97), Vol. 1329 of
Lecture Notes in Computer Science, edited by S. C. Hirtle, A. U. Frank (Laurel
Highlands, PA: Springer) pp. 103–119.

STOY, J. E., 1977, Denotational Semantics: The Scott-Strachey Approach to Programming

Language Theory (Cambridge, Massachusetts: MIT Press).

WORBOYS, M. F., 1995, GIS: A Computing Perspective (London: Taylor & Francis).

Downloaded by [University Of Pittsburgh] at 06:04 12 November 2014 