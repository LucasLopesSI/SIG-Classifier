International Journal of Geographical Information
Science

ISSN: 1365-8816 (Print) 1362-3087 (Online) Journal homepage: http://www.tandfonline.com/loi/tgis20

Spatial range queries using traces

YAN-NONG HUANG

To cite this article: YAN-NONG HUANG (1998) Spatial range queries using traces, International
Journal of Geographical Information Science, 12:6, 561-577, DOI: 10.1080/136588198241671

To link to this article:  http://dx.doi.org/10.1080/136588198241671

Published online: 06 Aug 2010.

Submit your article to this journal 

Article views: 45

View related articles 

Full Terms & Conditions of access and use can be found at
http://www.tandfonline.com/action/journalInformation?journalCode=tgis20

Download by: [University of Waterloo]

Date: 07 August 2017, At: 10:28

int. j. geographical information science, 1998, vol. 12, no. 6, 561± 577

Research Article

Spatial range queries using traces

YAN-NONG HUANG
Hewlett-Packard Laboratories, 1501 Pagemill Road, 1 U-4A Palo Alto,
CA 94304, USA
e-mail: ynhuang@hpl.hp.com

(Received 22 July 1996; accepted 15 August 1997 )

Abstract. A trace, de® ned as a set of points satisfying some constraints,
is
introduced to specify ranges in which interesting objects are located. The paper
shows how the declarativeness of the query language is enhanced by introducing
this concept, and how explicitly recognized traces have a signi® cant impact on
query optimization. Two typical spatial queries are considered: spatial select and
join. For spatial select queries, one needs to collect together distance related
conditions concerning the same spatial attribute and to recognize them as a trace;
this trace is used against the spatial index (if any) de® ned on the attribute, for
query optimization. The trace concept is then extended to a region (instead of
constant objects in the plane). This is necessary for spatial join queries since the
spatial objects, in terms of which join conditions are speci® ed, are bound by a
relation. Because the whole plane is usually divided into rectangular regions by
R-tree indexing, we consider actual traces on the basis of rectangles. A region r
of one join relation and a region s of another join relation are `joinable’ (contain
potentially joinable tuples) if r (or s) intersects with the trace on the basis of s
(or r). By recursively exploring the R-tree indexes on the join attributes from
roots to leaves, one may ® gure out joinable pages before searching for the
principal relations.

1.

Introduction
Spatial query languages ought to deal with, among other things, at least two
types of query conditions. The ® rst concerns spatial relationships ( Kainz et al. 1993 ),
including both directional relationships like east, west, south or north, etc., and
topological relationships (Clementini et al. 1994, Egenhofer 1991, Egenhofer and
Sharma 1993 ) with object boundaries involved like overlap, cross, contain, disjoin,
etc. Some e(cid:128) ort has been devoted to studying e(cid:129) cient algorithms for processing
queries of this kind (Chang et al. 1988).

The second type of query conditions concerns spatial ranges. In fact, range
queries have been proven useful in the traditional relational databases. Data struc-
tures have been studied to support the range queries for totally ordered attributes
as well as for spatial or multiple attributes ( Bentley and Friedman 1979, Guttman
1984, Valduriez and Viemont 1984, Yu and Jiang 1988 ). An example of a range
query on multiple attributes might be `® nd all the employees aged between 30 and
50 whose salaries range between $50 000 and $70 000’. In a coordinate system with
Salary and Age as orthogonal axes, this query represents a rectangle. A spatial range
query can be `® nd all Roman Catholic churches in a speci® ed region’. The region of

1365± 8816/98 $12´00 Ñ

1998 Taylor & Francis Ltd.

Downloaded by [University of Waterloo] at 10:28 07 August 2017 562

Yan-Nong Huang

interest can be speci® ed with a hand-drawn shape on the screen, a circle or a
rectangle for example.

We are primarily concerned in this paper with the spatial range queries ( Boursier
and Mainguenaud 1992, Lu and Han 1992 ), especially with the way spatial ranges
are represented and handled. To address this concern, the concept of trace is intro-
duced. On the one hand, this concept is used to increase the declarativeness of the
query language, and, on the other, it allows one to take advantage of the existing
spatial index for query optimization. A trace is a set of points satisfying some given
constraints, and these constraints are usually speci® ed analytically with a group of
equalities or inequalities. A resolution of these constraints may usually lead to a
cleaner or simpler mathematical representation, with which one may easily recognize
the geometric shape and region implied by the group of equalities or inequalities.

In recent years, research e(cid:128) orts have been devoted to constraint databases ( Frank
and Wallace 1995, Grumbach and Su 1996, Karacapilidis et al. 1995 ). These were
in part motivated by database applications ( like geographical information systems)
involving in® nite numeric domains which can be represented ® nitely through
constraints.

Our focus here is on the expression of a set of query conditions (constraints) as

geometric shapes, which can consequently be used for spatial query optimization.

The remainder of the paper is organized as follows. We ® rst motivate the concept
of trace from two di(cid:128) erent points of view in § 2. Then, after brie¯ y discussing our
spatial data model in § 3, the concept of trace is addressed in § 4. In § 5, a query
language that allows trace related constraints to be expressed is discussed through
a number of examples; we believe that this concept can be used in an internal
language to implement distance related conditions that are expressed in an external
language as a trace. Issues regarding the query optimizations in the presence of
recognized traces are addressed in § 6. A conclusion is drawn in § 7.

2. M otivations

We motivate the trace concept from two di(cid:128) erent points of view: declarativeness
of the query language (spatial ranges are described analytically instead of being
drawn with hands), and query optimization.

2.1. Declarativeness

Using the hand-drawn region to select the objects of interest represents several
drawbacks. First is a lack of precision. If we want to ® nd objects in a circle, how is
the centre of the circle located? How can its radius be measured? Second, and more
importantly, some regions are di(cid:129) cult to draw manually.

We introduce in this paper, the trace concept to overcome these problems. A
trace is a set of points satisfying some given constraints, and these constraints are
usually speci® ed analytically with a group of equalities or inequalities. Thus, a trace
de® nes a region in the plane.

To motivate this concept, let us consider a simple example. Suppose that a real
estate company uses a spatial database to manage its properties for sale. Each
property is characterized by its location (so a property is regarded as a point) along
with other spatial or non-spatial attributes. A family wants to buy a house which
should satisfy the following condition among others: the distance from the house to
the wife’s work place must be less than half the distance from the house to the
husband’s. It is not trivial for an average user to ® gure out the described region

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

563

without some geometric reasoning. Rather, we would prefer to let the user specify
the region declaratively just like:

D istance(W ) < 0´5 D istance (H ),

where W and H denote respectively the wife’s and husband’s work places.

If we take the wife’s work place as the origin and the straight line crossing both
the wife’s and the husband’s work places as the horizontal axis (see ® gure 1), the
2 where d is the
target region can then be speci® ed as Ï
distance between the wife’s work place and the husband’s work place. Simplifying
this formula leads to (x + (d/3 ))
, which corresponds to the inside part
of the circle centred at (Õ

(d/3 ), 0 ) of radius 2d/3.

2 < ( 2d/3 )

2 < 1
2 Ï

2+ y

2 + y

2+ y

(x Õ

d )

x

2

2.2. Query optimizatio n

The trace concept can also be motivated from the query optimization point of
view. Indexes have been largely used in the database query processing. The B-tree
( Knuth 1973) is likely to be the most common structure to indexing a one-dimen-
sional attribute. The R-tree (Guttman 1984), an extension of the B-tree, and its
variants (Sellis et al. 1987 ) have often been used to index multi-dimensional objects
which, in general, do not have `meaningful’ total order as is the case with more
traditional data types like integers or reals.

In a classical database, one may de® ne an index on an attribute or a group of
attributes. In a geographical database with complex object attributes involved, one
would have to build a number of di(cid:128) erent indexes on the same geometric attribute,
each corresponding to a function applicable to this attribute if each geometric or
spatial function had to have its own index structure. This situation might lead to an
overwhelming number of indexes de® ned on a single relation. It should be noted
that indexing enhances query optimization at the expense of update overheads since
we have to update all the indexes de® ned on the principal relation whenever an
update occurs.

As an alternative to the method proposed in Lu and Han ( 1992 ), our major
concern here is to minimize the number of indexes on a relation. That is, instead of
introducing any new index structure, we consider employing the commonly used
index, the R -tree, for spatial range queries.

A spatial query may involve some geographical or spatial functions for expressing
search constraints, like distances between objects. These spatial- or geometric-func-
tion related query conditions might actually de® ne a geometric region, as was shown

Figure 1. Trace (Distance (W ) < 0´5 Distance (H)).

Downloaded by [University of Waterloo] at 10:28 07 August 2017 564

Yan-Nong Huang

above. Recognizing explicitly the region implied by these conditions allows one to
take advantage of the existing R -tree spatial index for query optimization.

3.

Spatial data model
This section brie¯ y describes our spatial data model. We basically adopted an
extended relational model augmented with complex object attributes (Abiteboul et al.
1995 ) to represent geometric features. A complex object is built up of primitive data
like integer, real, etc., or previously constructed complex objects; complex object
constructors can be a tuple, set or list. Points and segments are the most elementary
components in the spatial modelling. A point is represented by its coordinates (tuple)
and a segment by two endpoints (tuple). More complex shapes can be a polyline or
a polygon, composed of a number of segments (set). Relatively small objects like a
house can be stored as a point, a ® eld like a university campus can be represented
as a polygon, and ® nally a street can be modelled as a polyline. Di(cid:128) erent complex
objects may share some of the components. For example, a campus boundary may
be part of a street. Each geographical object is identi® ed by a unique OID.

A database schema may contain not only classical alphanumeric data types like
integers, reals or dates, etc. but also complex data types for representing spatial
objects. A set of uniform tuples are stored in a database relation, e.g. a set of houses
may be stored in the Houses relation, a road network may be stored in the Roads
relation. A number of relations constitute a geographical database. Thus a map can
be stored in a database composed of di(cid:128) erent kinds of spatial objects like Houses,
Roads, Fields and so on.

4. Traces

In this section, we elucidate the concept of a trace used in our query language.
A trace is a set of points satisfying a number of constraints speci® ed analytically.
Given two points A and B in the plane, all points of which the distance to A is less
than the half of the distance to B form a trace, as shown by the example in § 2.

Geometric constraints are usually speci® ed in terms of distances. Distances may
be those from a point to another point, from a point to a polyline or from a point
to a polygon. The distance from a point to a polyline is de® ned as the shortest
distance from the point to component segments (or lines) of the polyline. Distances
involving areas ( polygons) are more complex because one has to de® ne precisely
what is mean by `distance to an area’. It might be the shortest distance to, or the
distance to a particular point (the centre of gravity for a pre-de® ned `central’ point,
for example) within the area of interest. In the ® rst interpretation distances depend
on the shape of the area in question. They may become more complicated when
they get involved in the comparison with other distances. For example, ® gure out
all points p such that the distance from p to the university campus (a polygon) is
less than the distance from p to the City Hall building (a point). In this paper, we
consider the second interpretation (the distance from a point to a polygon is de® ned
as that from the point to a particular point of the polygon, therefore, the point-to-
polygon distance is reduced to the point-to-point distance), and leave the ® rst
interpretation to a forthcoming study. Basic traces are ® rst considered.

De® nition 1. Let P and Q be two (di(cid:128) erent ) points, L and M, two segments, a and
b, positive reals, op among <, >
sum operators respectively; given a condition C ond , a trace in the plane, denoted by

, 1 and + the arithmetic multiply and

, =, >, >

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

565

T race(Cond ), is de® ned as the set of points satisfying C ond . C ond can be one of the
following:

1. D istance(P) op a
2. D istance(L ) op a
3. D istance(P) op b D istance (Q )
4. D istance(P) op D istance(Q ) + a
5. D istance(P) + D istance(Q ) op a
6. D istance(L ) op D istance (P)
7. D istance(L ) op D istance (M )

Note that in the above de® nition, we omit the target point itself. For example,
in the ® rst trace de® nition, D istance (P) op a denotes the set of points R such that
the distance between P and R op a, which corresponds to the inside or outside part,
depending upon the operator op, of the circle centred at P of radius a.

These traces correspond to regions surrounded by lines (segments), circles, ellipses
or other curves in the plane. Trace 1 is the inside or outside, depending on the
orientation of the inequality, part of a circle; Trace 2 is surrounded by two segments
parallel to L and to half circles; Trace 3 is surrounded by a circle if b Þ
1, or by a
line otherwise; Traces 4 and 5 are regions with respectively (a branch of ) a hyperbola
and an ellipse as boundaries. Boundaries of the two last traces are composed of
several smoothly connected curves. Trace 6 is surrounded by a portion of a parabola
and two rays whereas the boundaries of Trace 7 are composed of 5 di(cid:128) erent curves:
two rays, two parabolic portions and a segment. Figure 2 depicts Traces 1, 2, 6 and 7.

Basic traces can be combined to form a more complex trace. That is,

Figure 2. Trace illustrations.

Downloaded by [University of Waterloo] at 10:28 07 August 2017 566

Yan-Nong Huang

De® nition 2. Let T1 and T2 be two traces, then any of the following is also a trace:

1. T1 And T2
2. T1 Or T2
3. Not T1

As a matter of fact, the last Boolean operator is not necessary when constructing
complex traces. The operator Not can be eliminated by ® rst having it precede
immediately basic traces ( DeMorgan’s Law); then transforming Not T , T being
a basic trace, to another basic trace or a complex trace with only the operator
is
transformed into
O r
T race(D istance (P) > a) whereas (Not T race(D istance (P) = a))
into (T race(D istance
(P > a) O r T race(D istance (P) < a)) .

involved. For example,

(Not T race(D istance(P) <

a))

Finally, it should be noted that, by normalization of Boolean expressions, any
basic or combined trace can be described with a number of systems of simultaneous
( linear or square) equalities or inequalities and, these systems are disjunctively
connected.

5. Query language

Many spatial functions ( Langou and Maingeunaud 1994 ) have been suggested
as additions to the query language in order to perform geometry related computa-
tions. These functions include those for various spatial relationship comparisons
(inside, outside, cross; left, right, west, south, etc.), the polygon surface computations
and di(cid:128) erent distance computations, etc. They were implemented in our query
language, as well as distance related query conditions expressed as a trace.

Traces increase the declarativeness of the query language, as will be shown with
several examples. Suppose our running database is composed of the following
relations:

Houses( price Real, location Point, year Date);
Schools(name Char( 32 ), location Point);

where Point is the coordinate type modelling zero-sized objects in the plane.

Ex ample 1. Consider the query `Retrieve houses of which the price is less than
$200 000, the construction year is after 1990 and the distance to the wife’s work
place is less than half the distance to the husband’s work place’. In the query language
augmented with traces, the query can be expressed as:

select location
from Houses
where price< 200 000 And year> 1990
And location In T race(D istance(W ) < 0´5 D istance (H ))
where W and H correspond to the locations of the wife’s and the husband’s work
places.

In this example, the ® rst two conditions concern non-spatial attributes whereas
the third is about the spatial attribute `location’. Instead of specifying, with a hand-
drawn shape on the screen, the desired region in which the attribute must ® t, we
achieve the goal by analytically describing the constraints the targeted points need
the trace. This makes the query language more declarative by saving
to satisfyÐ

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

567

users from performing any computations to determine the exact region where targeted
points may be located.

Traces allow descriptions of some regions which are otherwise di(cid:129) cult to draw

by hand.

Ex ample 2. Consider the query `Retrieve houses of which the sum of the distance
to the wife’s work place and the distance to the husband’s work place is less than
10 km’. It is clear that the region containing the quali® ed houses is the inside part
of an ellipse. It is di(cid:129) cult to manually draw such a shape precisely. Instead, we may
express the query in a more declarative way:

select location
from Houses
where location In T race(D istance (W ) + D istance (H ) < 10 )

Combined traces may specify a more complex region.

Ex ample 3. Consider the query `Retrieve houses of which the sum of the distance
to the wife’s work place and the distance to the husband’s work place is less than
10 km, and which are more than 2 km away from a certain highway, HW’. Here is
a conjunctive spatial query condition, which can be expressed as a combined trace:

select location
from Houses
where location In
(HW ) >2 ))

relations.

(T race(D istance (W ) + D istance (H ) < 10 ) A nd T race(D istance

Conditions recognized as a trace can even be used to join two di(cid:128) erent spatial

Ex ample 4. Consider the query `Retrieve houses of which the sum of the distance
to the wife’s work place and the distance to the husband’s work place is less than
10 km, and which are less than 0´5 km within a school area’. In these combined
conditions, the second trace speci® es a spatial condition with respect to a point
bound by a relation, rather than by a ® xed point or polyline as in the previous
examples. This actually implies a spatial join between the two relations Houses
and Schools.

select Houses.location , Schools.nam e
from Houses, Schools
where Houses.location
(D istance(School s.location) < 0´5 ))

In

(T race(D istance(W ) + D istance(H ) < 10 ) A nd T race

As a matter of fact, one can use any basic trace listed in De® nition 1 of § 4, or
any combined trace listed in De® nition 2 of the same section to express distance
related query conditions.

It should be pointed out that classical relational query language,

like SQL,
augmented with point-to-point, point-to-line and point-to-polygon distance func-
tions, can express trace queries. In reality, we don’t have to use the keyword `trace’
to envelope the distance related conditions in the external
language. The trace
language can be regarded as an internal language which is capable of identifying
explicitly traces. To translate a query of the external language into the internal

Downloaded by [University of Waterloo] at 10:28 07 August 2017 568

Yan-Nong Huang

language, we need only cluster distance related conditions concerning the same
coordinate attribute to form a trace. Explicitly recognized traces can be used for
query optimization, as will be shown in the next section.

6. Query optimization with traces

Clustering a set of distance related conditions together to form a trace implies
converting `alphanumeric’ conditions into spatial or geometric ones, thus we may
take advantage of the spatial index if any. As we have seen in the previous section,
traces can be used to express select as well as join conditions. We now discuss the
query optimizations for two di(cid:128) erent cases: select and join.

We here suppose that a spatial index like the R -tree (Guttman 1984) structure is
index, a

de® ned over the select or join attribute. In the absence of the spatial
sequential scan over the relation appears to be necessary.

Recall that an R-tree structure consists of decomposing a plane into several
regions so that each region contains approximately the same number of objects.
Each region is then further decomposed into several sub-regions based on the same
rule; every divided sub-region contains approximately the same number of objects.
This decomposition process continues until the ® nal sub-regions can ® t into a single
IO page. Notice that we here consider the clustering R -tree structure, that is, the
principal relation is clustered according to the R -tree structure, so a sub-region at
leaf level corresponds to an IO page. With slight modi® cations, the proposed ideas
can be easily adapted to the non-clustering R -tree structure.

Remarks: ( 1) a region is not necessarily divided into disjoint sub-regions; ( 2 ) a

region is in general divied with `regular’ shapes, usually rectangles.

6.1. Select

The problem under consideration is this: given a relation R with r as one of its
coordinate type spatial attributes, we would like to select tuples of R that satisfy
some constraints on r. Suppose that an R -tree structure index was constructed on
the attribute r.

Return now to Ex ample 3 of the last section, where we were asked to retrieve all
the houses of which the sum of the distance to the wife’s work place and the distance
to the husband’s work place is less than 10 km, and which are more than 2 km away
from a certain highway, HW . Suppose that a spatial index of the R -tree structure
was de® ned on the attribute `location’ of the relation `House’. This spatial indexing
is depicted in ® gure 3 where a dot represents a house location in the plane. The
plane is ® rst divided into three sub-regions R 1 , R 2 and R 3 ; each sub-region is then
divided into smaller sub-regions. Figure 4 shows the R -tree structure. A node in the
R -tree corresponds to a plane decomposition. Each entry of a node has two ® elds,
one describing the region it represents and the other pointing either to a lower level
R -tree node which corresponds to a ® ner plane decomposition, or to a data page in
the principal relation.

It is clear that if one did not recognize the select conditions as a trace describing
a geometric region in the plane, one would not be able to take advantage of the
existing spatial index to improve the performance for query optimization; in other
words, one would have to scan the whole relation sequentially to ® nd out the relevant
locations.

In fact, the ® rst select condition `the sum of the distance to the wife’s work place
and the distance to the husband’s work place is less than 10 km’ corresponds to the

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

569

Figure 3. Plane divided with regions: Houses.location.

Figure 4. R-tree: Houses.location.

inside part of an ellipse in ® gure 3 (W and H are the wife’s and husband’s work
places respectively). In the second select condition `more than 2 km way from a
certain highway, HW ’, it is supposed that HW is a `su(cid:129) ciently’ long segment (so
regarded as a line in this context ). Hence, the conjunctive condition corresponds to
the shaded part inside the ellipse, which will be referred to as the target range.

Once the distance-function related conditions are recognized as a trace, an
`alphanumeric’ query can then be regarded as a spatial range query. For better
performance, the index illustrated in ® gure 4 is used for query optimization. We start
at the root of the R -tree by comparing the target range with each of the entries R 1 ,
R 2 , and R 3 , to determine those that intersect with the target range; R 1 and R 3 are
found. Take now R 1 and R 3 as the new starting points, we then ® nd that R 13 of R 1 ,

Downloaded by [University of Waterloo] at 10:28 07 August 2017 570

Yan-Nong Huang

and R 32 of R 3 intersect with the target range. R 13 and R 32 give the addresses of the
pages where information about relevant houses is stored. Therefore, only two disks
accesses to the principal relation are needed to get required information in contrast
to nine when not using the spatial index.

In summary, given any basic or combined trace (§ 4 ) for select operation, using
traces to enhance the performance for spatial query optimization involves the follow-
ing steps: ( 1 ) gathering distance related constraints about the same coordinate
attribute to form explicitly a trace; ( 2) recognizing the geometric region expressed
with a trace; and ( 3) searching the spatial index (R-tree) against the recognized
region for addresses of the relevant data pages.

With these addresses, we need only read in main memory pages containing the
most relevant data from the principal relation. This may reduce substantially the
number of disk accesses.

Let us consider step 3 in the above process, which involves repeatedly the
intersection check between the recognized geometric region and a rectangle. As
discussed earlier in § 4, a region is described with a set of disjunctive systems of
simultaneous equalities or inequalities. If none of these systems is satis® able, one
can claim that the set of relevant objects is empty without searching the R -tree;
otherwise, it is necessary to verify whether there exists a system that intersects with
the system of inequalities describing the rectangle in question. Since these systems
are disjunctively connected, one may check them one after another and stop at the
® rst system intersecting with the rectangle. If no system is found intersecting with
the rectangle,
it means that the region and the rectangle are disjoint. Systems
describing the geometric region are not necessarily disjoint (they may be disjoint).
Since they are only used for intersection check rather than for access into data pages
(only rectangles in leaves of the R -tree are used for data page access), no date page
is accessed more than once.

It should be noted that given two geometric shapes which are represented by
relatively `few’ systems of equalities, verifying the emptiness of their intersection has
a constant time computational complexity.

6.2. Join

When select conditions are expressed in terms of objects bound by a relation
instead of by some `constants’, the spatial select turns into a spatial join: this is the
case with Ex ample 4 of the last section. In this example, the relation `Houses’ is
joined with the relation `Schools’. The join attributes are Houses.location and
Schools.location. It is clear that if none of the join attributes is indexed, we have to
scan both relations sequentially in order to perform the join operation.

Consider now that one of the join attributes, say for example Houses.location, is
indexed. To realize the join operation between two relations `Houses’ and `Schools’,
we have to scan the whole relation whose spatial attribute is not indexed, that is,
scanned, we perform a select operation. The
`Schools’. For each tuple of `Schools’
realization of this operation may bene® t from the presence of the index de® ned on
the attribute Houses.location, as was shown in the last subsection.

In what follows, we are primarily interested in cases where both join attributes

are indexed:

Given two relations R and S, each having a coordinate type spatial attribute, say
r for R and s for S that both r and s are indexed. We study how to e(cid:129) ciently

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

571

implement the join operation between R and S under point-to-point distance related
join conditions. Join conditions can be either of the basic forms: D istance (r, s) op d
, =, >, >
where op is an operator among <, <
and d is non-negative, or any of
the combinations of basic forms with the logical connectors.

The intuitive approach is ® rst illustrated with a simple example, and we then
consider as an extension of the trace concept which is useful for optimizing joins
over R -tree-indexed attributes. An algorithm for distance related join processing is
® nally presented.

6.2.1. An example

Let us go back to Ex ample 4 of the last section and consider a simpli® ed version
which only includes the second condition in the `where’ clause. The query becomes
`Retrieve all the houses which are less than 0´5 km from a school area’. A SQL-like
query is:

select Houses.location , Schools.nam e
f rom Houses, Schools
where Houses.location In T race(D istance(School s.location) < 0´5 )

We suppose that the spaces of Houses.location and of Schools.location are divided
for indexing purposes (see ® gures 2 and 4), and an R -tree is built for each of the
join attributes (see ® gures 3 and 5). Furthermore, the two spaces are described by
the same coordinate system.

It is clear that for a given school location (School s.location), the condition

T race(D istance(School s.location) < 0´5 )

centred at Schools.location of

de® nes a circle
radius 0´5. However, when
Schools.location varies within the range of the whole relation `Schools’, we need to
extend the concept of trace, which was on the basis of constant objects, to that built
upon a range of objects.

Since the space of Schools.location is divided into a number of sub-regions, each

Figure 5. Plane divided with regions: Schools.location.

Downloaded by [University of Waterloo] at 10:28 07 August 2017 572

Yan-Nong Huang

being a rectangle (® gure 5 ), we now consider the region which could be covered by
the set of circles of radius 0´5, the centres of which are in a rectangle.

In ® gure 7, A is a rectangular area. For any point P in A , T race(D istance(P) <
d )
corresponds to a circle; when P passes through A , the region covered by all these
d ), corresponds to the area whose boundaries
circles, denoted as T race(D istance(A) <
are dashed.

With this extension to the concept of trace, we now consider the join, given two

spatial indexes on Houses.location (® gure 4) and on Schools.location (® gure 6 ). The
space of Houses.location will be referred to as R -space, that of Schools.location S-
space. Both spaces have been divided into a number of sub-regions by the indexing.
We here use r(cid:160) to denote a sub-region at leaf level in R -space and s(cid:160) to denote a sub-
region at leaf level in S-space. The central idea consists of ® nding out all pairs of
(r(cid:160), s(cid:160)) such that r(cid:160) contains tuples potentially joinable with tuples in s(cid:160). To this end, we
may use the R -tree.

0´5 ) and T race(D istance (S2 ) <

We start at the roots of both R -trees to verify if any of R 1 , R 2 and R 3 intersects
with any of T race(D istance(S1 ) <
0´5 ). If no intersection
is detected, that means the relations are not joinable; hence, the join result is the
empty relation. If some R i
0´5 ), these
regions may contain tuples potentially joinable; continue then with the node pointed
by R i in the Houses.location R -tree and the node pointed by S j in the Schools.location
R -tree to repeat the same veri® cations. This process continues until we end up at
leaves of both R -trees with the set of pairs of the page address containing joinable
tuples. We then look into the principal relations with each pair of the page address
to actually join tuples of `Houses’ and `Schools’.

intersects with some T race(D istance(Sj ) <

6.2.2. T races on the basis of a region

As we have seen in the last subsection, in order to e(cid:129) ciently process the spatial
join operation over attributes R -tree-indexed, we should ® rst of all ® gure out the
trace on the basis of a rectangular area. That is, if A is a rectangular area, we are
interested in ® nding all points P such that there exists at least one point Q in A
satisfying: D istance (P, Q ) op d where op is an operator among <,
Formally,

, =, >,

.

T race(D istance(A) op d ) = p
Q×A

T race(D istance (Q ) op d ).

In the sequel, we only consider T race(D istance(A) <

d ) and T race(D istance(A) >

since T race(D istance (A) < d )
(D istance(A) > d )

is

included

in

T race(D istance(A) <

d ),

is included in T race(D istance(A) >

d ), T race(D istance(A) = d )

d )
T race
is

Figure 6. R-tree: Schools.location.

Downloaded by [University of Waterloo] at 10:28 07 August 2017 <
>
Spatial range queries using traces

573

equivalent to (T race(D istance (A) <
are merely intersection, union or complement of the basic ones.

d ) A nd T race(D istance (A) >

d )) . Combined traces

For ease of presentation and without loss of generality, suppose that A is sur-

rounded by four lines x = a1 , x = a2 , y = b1 and y = b2 where a1 <

a2 and b1<

b2.

d ) It is simple to verify that T race(D istance(A) <
T race(D istance (A) <
to the region surrounded by four segments on sides x = a1 Õ
x = a2 + d, b1<
the four circles of radius d centred at corners, embedded by the extensions of the
edges of A (see ® gure 7).

d ) corresponds
d, b1 <
b2;

a2, y = b2+ d; and parts of

a2, y = b1Õ

b2 ; a1<

d; a1<

x <

x <

y <

y <

The following (disjunctively connected ) systems of equalities/inequalities may be

a possible description for the region:
First, four circles at corners,

then, two rectangles covering the rest of the space,

{(x Õ

{(x Õ

{(x Õ

{(x Õ

a1 )

2+ ( y Õ

a2 )

2+ ( y Õ

a1 )

2+ ( y Õ

a2 )

2+ ( y Õ

b1 )

b1 )

b2 )

b2 )

2<
2<
2<
2<

2

2

2

2

d

d

d

d

x <

a2

d <

y <

b2 + d

d <

x <

a2+ d

y<

b2

b1Õ

G a1<
G a1Õ

b1<

Obviously, these sub-areas overlap each other. Recall that they are only used for
intersection check rather than for access into data pages (only rectangles in leaves
of R -trees are used for data page access), so no redundant processing may happen.
d ) It does not seem to be trivial to ® gure out immediately
d ). So ® rst consider its complement:

the region represented by T race(D istance(A) >
the set of points from which the distances to any point of A are less than d.

T race(D istance(A) >

In ® gure 8, A is a rectangular area. Consider the intersection of the four circles
of radius d centred at corners of A , we would like now to show that the distance
from a point P of this intersection to any point of A is less than d. Let Q be any

Figure 7. T race(D istance(A) <

d ).

Downloaded by [University of Waterloo] at 10:28 07 August 2017 574

Yan-Nong Huang

Figure 8. T race(D istance(A) >

d ) .

point in A . Draw two lines crossing P parallel to the edges of A ; A is thus divided
into four rectangular parts, so Q necessarily falls into at least one of these four parts.
Let’s suppose without loss of generality that Q is in the bottom right part of A , C is
the corner included in this part. Since the distance between P and Q is not greater
than that between P and C , the latter is in turn less than d (since P is inside the
circle centred at C ); therefore the distance between P and Q is less than d.

To show the intersection of the four circles corresponds to the set of points from
which the distances to any points of A are less than d, we need further to verify that
for any point Q outside this intersection, there exists at least one point of A from
which the distance to Q is greater than d. It is straightforward; since Q is outside
the intersection, there must exist a circle centred at some corner D of A , such that
Q is outside the circle, so the distance between Q and D is greater than d.

Hence, T race(D istance(A) >

d ) is the whole plane minus the intersection of the

four circles of radius d centred at corners of A .

A possible description for the region is the following (disjunctively connected )

systems:

and

{(x Õ

{(x Õ

{(x Õ

a1 )

2+ ( y Õ

a2 )

2+ ( y Õ

a1 )

2+ ( y Õ

b1 )

b1 )

b2 )

2>
2>
2>

2

2

2

d

d

d

{(x Õ

a2 )

2+ ( y Õ

b2 )

2>

2

d

6.2.3. Spatial join optimizatio n

Recall that given two relations R and S, each having a coordinate type spatial
attribute, r for R and s for S and that both r and s are indexed. We want to join R
and S under C ond (r, s), a join condition relating r and s. C ond can be either of the
basic forms: D istance(r, s) op d where op is an operator among <, <
d is non-negative; or any of the combinations of basic forms with the logical
connectors.

, =, >, >

and

In terms of traces, the join condition can be expressed as: r In T race(Cond (s)) ; or

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

575

equivalently, s In T race(Cond (r)) . Both traces may lead to the same performance
improvement.

Consider ® rst an algorithm that computes the set of pairs of page addresses of

R and S containing joinable tuples.

Algorithm: Producing the set of pairs of addresses of joinable pages;

Prototype:
Input:

Output:

Search ( Input: Er, Es; Output; Joinables);
Er a node entry of the R -tree of the relation R ;
Es a node entry of the R -tree of the relation S ;
Joinables: the set of pairs of page addresses of R and S containing
joinable tuples.

Method:
begin ( 1) If Er.region intersects with T race(Cond ( Es.region)) then

If both Er and Es are in leaves Then Joinables = Joinables n {(Er.pointer,
Es.pointer)};
If Er is in a leaf And Es is not Then

For each entry EEs of the node pointed by Es.pointer

Search ( Er, EEs, Joinables);
If Es is in leaf And Er is not Then

For each entry EEr of the node pointed by Er.pointer

Search ( EEr, Es, Joinables);

If none of Er and Es is in a leaf Then

For each entry EEr of the node pointed by Er.pointer

For each entry EEs of the node pointed by Es.pointer

Search ( EEr, EEs, Joinables);

end;

Each entry of an R -tree node has two ® elds denoted as `region’ and `pointer’ in
the algorithm: `region’ is a description of the rectangular region represented by the
entry; and `pointer’ points to a data page of the principal relation if the entry is at
leaf level, or to another R -tree node for further plane decomposition otherwise.

If the trace on the basis of a sub-region of S.s space intersects with a sub-region
of R .r space, these two sub-regions may contain tuples potentially joinable; namely,
these two sub-regions are joinable.

Statement ( 1 ) in the algorithm consists in verifying if a sub-region of R .r is
joinable with a sub-region of S.s. To this end, we need to consider the intersection
between the sub-region of R .r (or of S.s) and the trace on the basis of the sub-region
of S.s (or of R .r). For discussions on this intersection check, one may refer to the
last two paragraphs of § 6.1.

To obtain all pairs of joinable pages ( leaves in R -trees), we have to search the
R -tree of both R and S from roots to leaves. If an entry of the root of R is joinable
with an entry of the root of S, we go down to the lower level of both R -trees to
continue the process. Therefore, the algorithm is recursive.
To invoke the algorithm, we use Search (7 T, Pr8

, Joinables); where T
denotes the whole plane, 7 R, P8 denotes a node entry with R as region and P pointer
pointing to the corresponding node, Pr points to the root of the R -tree of R , Ps to
the root of the R -tree of S and ® nally, Joinables is initialized to the empty set B.

, 7 T, Ps8

Downloaded by [University of Waterloo] at 10:28 07 August 2017 576

Yan-Nong Huang

The algorithm will bring back the set of pairs of addresses of joinable pages of R
and S through the output variables Joinables.

With what are obtained by the algorithm through Joinables, we can access into
the principal relations. Precisely, for each item ( RPage, SPage) in Joinables, read in
main memory the page RPage of R and the page SPage of S to verify the actual
matching between tuples of R and those of S and to produce the resulting tuples.

Therefore, one needs only to explore pages containing potentially joinable tuples;

the number of IO accesses can thus be minimized.

We here considered only a subset of distance related conditions listed in § 4 for
join query optimization. However, we believe they are likely to be the most useful
in practice. Future research will investigate query optimization for join operations
involving more complex related conditions.

7. Conclusion

We have proposed in this paper the trace concept for spatial range queries.
Signi® cance of this concept can be viewed in two di(cid:128) erent ways. First, a geometric
region can be speci® ed analytically. So, it allows description of regions which are
di(cid:129) cult to draw manually. Second, clustering distance related query conditions into
a trace allows explicit recognition of the geometric region of interest; consequently,
we may take advantage of the existing commonly used spatial index for query
optimization.

Distances considered in the paper are point-to-point, point-to-line and point-to-
polygon; point-to-polygon distance is regarded as the distance from the point to a
particular point within the polygon (the gravity centre or a pre-de® ned `central’
point). Future work will study de® nitions and handling of more ¯ exible semantics
for distances involving areas (for example, distance to an area could refer to the
shortest distance to that area).

Gathering spatial or geometric function related query conditions to form a trace
seems to be a very promising direction. Further research will
investigate traces
involving more complex geometric functions than distance functions, and query
optimization issues on spatial joins of more than two relations.

References
Abiteboul, S., Hull, R. and Vianu, V., 1995, Foundations of Databases (Reading, Mass.:

Bentley, J.-L. and Friedman, J., 1979, Data structure for range searching, Computing Surveys,

Addison ± Wesley).

11, 397± 409.

Boursier, P. and Mainguenaud, M., 1992, Spatial Query Languages: Extended SOL vs.
Visual Languages vs. Hypermaps. In Proceedings of the 5th International Symposium
on Spatial Data Handling (Columbia, SC: IGU ), pp. 249± 259.

Chang, S. K., Yan, C. W., Dimitroff, D. C. and Arndt, T., 1988, An intelligent image
database system, I.E.E.E. T ransaction on Software Engineering, 14, 681± 688.
Clementini, E., Sharma, J. and Egenhofer, M., 1994, Modelling topological relations:

strategies for query processing, Computers and Graphics, 18, 815± 822.

Egenhofer, M., 1991, Reasoning about binary topological relations. In Proceedings of 2nd

International Symposium SSD (ZuÈ rich, Switzerland: Springer), pp. 143± 160.
Egenhofer, M. and Sharma, J., 1993, Topological relations between regions in r

2 and z

2. In

Proceedings of 4th International Symposium SSD, Singapore (Singapore: Springer),
pp. 613± 636.

Frank, A. U. and Wallace, M., 1995, Constraint based modelling in a GIS: road design as
a case study. In Proceedings of the ACSM/ASPRS Annual Convention and Exposition
T echnical Papers, Vol. 4 ( Bethesda, MD: American Congress on Surveying and

Downloaded by [University of Waterloo] at 10:28 07 August 2017 Spatial range queries using traces

577

Mapping and American Society for Photogrammetry and Remote Sensing ),
pp. 177± 186.

Grumbach, S. and Su, J., 1996, T owards Practical Constraint Databases (MontreÂ al, Canada:

ACM PODS).

Guttman, A., 1984, R-trees: A dynamic index structure for spatial searching. In Proceedings
of the ACM-SIGMOD, Conference on Management of Data (New York: ACM Press),
pp. 47± 57.

Kainz, W., Egenhofer, M. and Greasley, I., 1993, Modeling spatial relations and operations
with partially ordered sets, International Journal of Geographical Information Systems,
7, 215± 229.

Karacapilidis, N., Papadias, D. and Egenhofer, M., 1995, Collaborative spatial decision
making with qualitative constraints. In Proceedings of the ACM-GIS W orkshop ( New
York: ACM Press), pp. 53± 59.

Knuth, D., 1973, T he Art of Computer Programming: Sorting and Searching, Vol. 3 (Reading,

Mass.: Addison ± Wesley).

Langou, B. and Mainguenaud, M., 1994, Graph data model operations for network facilities
in a GIS. In Advances in GIS: Proceedings of the 6th International Symposium on Spatial
Data Handling, T. C. Waugh and R. Healey (London: Taylor & Francis).

Lu, W. and Han, J., 1992, Distance-associated join indices for spatial range search. In

Proceedings of
Alamitos: IEEE Computer Society), pp. 284± 292.

the 8th IEEE International Conference on D ata Engineering (Los

Sellis, T., Roussopoulos, N. and Falousos, C., 1987, R+Õ

tree: a dynamic index for multi-

dimensional objects. In Proceedings of the 13th International Conference on V ery L arge
D atabases (Boston: ACM Press), pp. 507± 518.

Valduriez, P. and Vie’mont, V., 1984, A multikey hashing scheme using predicate trees. In
Proceedings of ACM SIGMOD Conference on Management of Data (Brighton: Morgan
Kaufmann), pp. 107± 114.

Yu, T. C. and Jiang, T., 1988, Adaptive algorithms for balanced multidimensional clustering.

In Proceedings of the 4th IEEE International Conference on D ata Engineering (Los
Alamitos: IEEE Computer Society), pp. 386± 393.

Downloaded by [University of Waterloo] at 10:28 07 August 2017 