Geoinformatica (2011) 15:75–109
DOI 10.1007/s10707-010-0112-5

TIDES—a new descriptor for time series
oscillation behavior

Leonardo E. Mariote · Claudia Bauzer Medeiros ·
Ricardo da Silva Torres · Lucas M. Bueno

Received: 22 July 2008 / Revised: 1 December 2009 /
Accepted: 31 May 2010 / Published online: 18 June 2010
© Springer Science+Business Media, LLC 2010

Abstract Sensor networks have increased the amount and variety of temporal
data available, requiring the definition of new techniques for data mining. Related
research typically addresses the problems of indexing, clustering, classification, sum-
marization, and anomaly detection. There is a wide range of techniques to describe
and compare time series, but they focus on series’ values. This paper concentrates on
a new aspect—that of describing oscillation patterns. It presents a technique for time
series similarity search, and multiple temporal scales, defining a descriptor that uses
the angular coefficients from a linear segmentation of the curve that represents the
evolution of the analyzed series. This technique is generalized to handle co-evolution,
in which several phenomena vary at the same time. Preliminary experiments with real
datasets showed that our approach correctly characterizes the oscillation of single
time series, for multiple time scales, and is able to compute the similarity among sets
of co-evolving series.

Keywords Time series similarity computation · Time series descriptor ·
Oscillation of series · Series co-evolution

L. E. Mariote · C. B. Medeiros (B) · R. da S. Torres · L. M. Bueno

Institute of Computing, University of Campinas—CP6176,
Campinas, São Paulo, 13084-851, Brazil
e-mail: cmbm@ic.unicamp.br

L. E. Mariote
e-mail: leonardo.mariote@gmail.com

R. da S. Torres
e-mail: rtorres@ic.unicamp.br

L. M. Bueno
e-mail: lucas@ic.unicamp.br

76

1 Introduction

Geoinformatica (2011) 15:75–109

An increasing number of applications periodically collect information from some
environment, creating and analyzing temporal data on phenomena that can be
artificial (e.g., computer network traffic) or natural (e.g., temperature). Sensor
networks [2, 28, 38] are rapidly becoming prime data providers, e.g. in biodiversity
systems, urban traffic analysis, or even inside a room. In order to make sense of this
huge amount of data, new mining techniques must be developed. Similarity search is
used as a basis for the majority of mining activities, and is thus an important problem
to be investigated.

Several research initiatives have addressed this problem, using different methods
for compacting, indexing, and querying time series. A time series Si is a sequence
of points pi =< valuei, ti > that provide measurements of phenomena (the value)
sampled at timestamps ti. Some methods are specific for comparing entire time
series—e.g., [34], while others can work with subsequences [10, 19, 40]. These studies
can be directed towards static series (i.e., when the data set does not grow during
analysis, for instance, in historical series) or dynamic series (those that can be
updated while they are being analyzed—typical of stream data).

Given factors such as series volume, heterogeneity of values and diversity of
phenomena represented, similarity among series is not computed using the series
themselves. Rather, the idea is to compare structures that represent the series in a
more compact manner (feature vectors) under different distance functions.

Whereas most research efforts propose representation structures based on the
values of a series (see, for instance, the survey of [7]), this paper addresses the
problem of similarity search from a novel perspective, motivated by user needs.
It presents a new series descriptor, which represents data evolution and oscillation
trends, instead of concentrating on actual data values. Our descriptor, TIDES (TIme
series oscillation DEScriptor), allows summarization and comparison of oscillations
of time series for different temporal scales.

Figure 1 shows an example of the kind of concern met by our work. The curve in
regions A and B evolves in the same way, but these two sub-series are displaced
relative to the y-axis. Several kinds of value-based descriptors would not detect
their similarity. This is one of the situations in which TIDES will identify similar

Fig. 1 The problem of
displacement in the Y-axis

Geoinformatica (2011) 15:75–109

77

patterns. However, TIDES’ main difference lies in recognizing oscillation patterns,
for multiple temporal granularities.

Part of this work was reported in [29], for comparing individual time series. Here,
we extend this work to cope with co-evolution. In more detail, we show how TIDES
can be generalized to describe the simultaneous oscillations of a set of co-evolving
time series. Under this generalization, it is possible to mine for complex similarity
patterns: instead of comparing two series, experts can compare two sets of time series
and thus detect correlations of oscillation patterns. There is a scarcity of papers on co-
evolution, and this extension of TIDES is a step towards helping solve this problem.
Experimental results with TIDES show that it can detect similarity in oscillations
for real and synthetic time series, in one and multiple temporal scales, as well as in
mining for similarity in co-evolving sets of series.
The main contributions of the paper are thus:

–

–

–

proposal of a new kind of evaluation of time series similarity, based on the
TIDES multiscale descriptor, which, unlike related work, deals with oscillation
patterns;
use of TIDES in describing not only the evolution of single series, but also the
co-evolution of multiple phenomena; and
experimental validation of the proposal (for single and for co-evolving series),
including a prototype to help users visually inspect the results

The rest of this paper is organized as follows: Section 2 analyzes related work;
Section 3 presents TIDES; Section 4 generalizes TIDES to deal with co-evolution
analysis; Section 5 presents experimental results; Section 6 briefly presents our Web
prototype for mining oscillation patterns; and Section 7 contains conclusions and
future work.

2 Concepts and related work

Research in time series covers many fields, from their visualization to storage struc-
tures and indexing. Part of this research concerns mining aspects—e.g., classification
or pattern matching—whereas other experts consider series within a database
context—and thus concentrate on query processing techniques. Mining and querying
time series strongly rely on similarity mechanisms. Our paper deals with similarity
issues, thus providing a basis for a wide range of operations.

According to [35], the operations most studied in series mining include, among

others:

–
–
–
–

–

indexing—to speed up retrieval and similarity computation;
clustering—to group series into clusters, under some similarity criteria;
classification—to assign a series to one or more classes;
summarization—to create a compact approximation for large series, for visual-
ization or processing needs;
anomaly detection—to find all sub-sections of a series that deviate from expected
behavior. Outlier detection is a specific case of anomaly detection.

To these aspects we also add forecasting operations, in which the past behavior of

a phenomenon is used to predict its future evolution.

78

Geoinformatica (2011) 15:75–109

Many techniques are used to perform these operations, such as machine learning
(supervised and non-supervised training), linear regression, dynamic programming
and signal decomposition [10, 13, 14]. According to Faloutsos [9], many of these
operations are tightly interconnected. Hence, there have been proposals to construct
a basic set of primitives to be used to perform them—e.g., the combination of pattern
discovery and similarity search can be used to predict values. All functionalities
require some sort of comparison, to recognize patterns, where exact matching is
virtually impossible.

This section presents a brief review of issues concerning mining and querying
time series. We start by an overview of series mining, and a discussion of distinct
comparison procedures. Finally, the section discusses the issue of co-evolution.

2.1 Basic concepts and terminology

Time series mining is a specific problem within pattern mining. Our work is specially
concerned with (1) representing a set of relevant characteristics of a given (set
of) time series and (2) computing similarity between two series, or two sets of co-
evolving series (series co-evolution).

From a high-level perspective, similarity mechanisms are based on the notions
of feature descriptor and distance function. A feature descriptor is typically a set of
values, organized according to some structure, that summarizes a given series. Vec-
tors are the most common structure used, and feature descriptors are therefore often
called feature vectors—the term adopted by us. Two objects are considered similar if
the distance between their descriptors is below some threshold. Similarity depends
on the features selected [37]—thus, distance functions are intimately associated with
the algorithms used to create the vectors. Examples of distance functions involve
Manhattan (also known as L1) and Euclidean—L2 [39].

Challenges in this area include designing functions that will extract the appropriate
descriptors, and determining adequate distance functions. Threshold values, and
adequate distance functions must be validated by experts for each application
domain.

The separation between the vector and the distance function has the advantage
of isolating these two different problems needed to handle similarity. A similar
approach is also followed by the survey on time series of [7], separating the issues
of (i) reducing dimensionality of a series and (ii) defining a distance measure.

Once the descriptor < feature vector, distance function > has been defined, it can
be used to process similarity in mining activities. Similarity can be computed against
entire series, or for subsets thereof. There are moreover specific techniques for static
and dynamic series analysis. Many of them rely on the notion of sliding windows to
select a portion of a series. Examples of such situations occur when series present
periodic behavior (e.g., [40]), or when querying streams [12, 17].

2.2 Mining time series—general overview

Temporal data mining has been subject to extensive research. Several projects
address the problems of compacting, comparing, indexing and forecasting the be-
havior of time series. The classification of time series proposed by [36] enumerates
some basic criteria to compare and classify series. Regularity and type (discrete,

Geoinformatica (2011) 15:75–109

79

continuous, stepwise or event-based) are among the most important, as well as the
time unit used to sample data. Values are usually inserted following their timestamp
ordering. This is often used to simplify indexing structures. There is a distinction
between static and dynamic series, in which the first case corresponds to data that
will not suffer further updates, whereas the second characterizes data sets that may
be updated during the mining activity, in particular stream data. Though stream data
have been studied for a long time (e.g., stock market information), they have come
to the forefront with the dissemination of sensor-based applications.

Stream processing involves many problems. Data are continuously updated, some-
times at high speed rates, resulting in long series—and in very large data volumes,
when one deals with sensor networks. Streams are normally treated as append-only
files, with transient records [3]. Often, in order to save storage space, older values
are discarded after a period of time. Another common approach adopted for sensor
network data is to summarize data from several sensors into one aggregated value,
thus reducing the amount of data to be processed (e.g., [33]).

Forecasting is directly associated with the use of comparing present behavior with
similar past behavior [40]. Prediction can be performed using numerical regression
techniques, which can generate parameters to characterize series [10, 34, 41]. This
can in turn help define a function that computes approximations to the values of
a series. Prediction precision depends on the kind of regression used, and on the
characteristics of data distribution. For instance, if this distribution is not continuous,
linear regression may not provide good results. Supervised and unsupervised training
can also be used in prediction [3].

Series data need to be pre-processed to fill in eventual gaps between two mea-
surements. This is related to the problem of Fitness of Use [11], in which series
are analyzed and preprocessed to check their quality in terms of completeness and
correctness. As pointed out by [11], there are many sources of errors and gaps in a
series, such as equipment malfunctioning or communication failures. Errors can be
detected, for instance, by comparing the value in a series to an inferred value [9]. If
they are very different, the measured value may be an outlier, or represent an error.
There are many approaches for filling gaps in series (e.g., statistical, probabilistic
or inference-based methods, as well as many kinds of interpolation)—see, for
instance, [5]. Such techniques can also be used to speed up queries in series stored
in database systems—e.g., [6]. User queries are posed on the views, and not on the
data.

Our work assumes that the series have undergone all needed preprocessing, and
thus we do not concern ourselves with errors or quality issues. We now turn our
attention to the construction of descriptors, which is the initial step of any mining
and querying approach. First we will discuss mechanisms to create representation
structures, and then approaches to distance computation.

2.3 Characterization of a time series—deriving representations

There are many approaches to represent a time series. According to the survey
presented in [7], these approaches can be classified into data adaptive (e.g., inter-
polation) and non-data adaptive (e.g., spectral analysis). We, instead, classify these
approaches according to the kind of representation adopted—linear segments, sym-
bolic representations, and spectral analysis. This is not an exhaustive classification,

80

Geoinformatica (2011) 15:75–109

since other classes of approaches exist—e.g., approximation by Chebyshev polyno-
mials [4]—but it covers the most common representation solutions. We point out that
several representations techniques can be composed—e.g., PAA (see Section 2.3.1)
combines linear segmentation with symbolic representations.

2.3.1 Linear segmentation schemes

The simplest and most common characterization of a series is a straightforward
approximation by linear segments (PLA, or Piecewise Linear Approximation).
According to Keogh and Smyth [21], linear segmentation can be applied to most
data types, even if they are not stationary in time—situation in which spectral
representations do not perform well. Segmentation, moreover, can be used in noisy
series, besides being conceptually simpler. There are several algorithms for efficient
segmentation. Keogh et al. [23] present three main approaches for segmentation—
top down, bottom up and sliding windows.

The bottom up approach uses greedy algorithms that follow the stages:

– Traverse the series, uniting two successive points by line segments
– Compute the error introduced by eliminating each segment
– Remove the segment that results in the smallest error

This process is repeated until some stopping criterion is met.

The top down approach uses the reverse process. It starts by a single segment,
that unites the first and the last points of a series. Next, the technique computes the
increase in accuracy obtained by introducing another point, and inserts the point that
provides the biggest gain. This is repeated until some accuracy threshold is obtained.
For both approaches, stopping criteria depend on the application domain.

The sliding window approach is used to process continuous series, i.e., those
that do not have a fixed number of points. Tests performed by [21] indicated
that the bottom up technique is the most appropriate. A hybrid approach (SWAB
segmentation) that combines the bottom-up and the sliding window approaches is
also reported to yield good results.

Another approach that uses linear segmentation is proposed in [19]. In this
method, a user can assign a weight to each segment. These weights are stored with
the endpoints of the segments, and are used in the distance function. This enables the
user to choose which segments are more important than others in a similarity query.
Other segmentation studies have tried to represent series using step functions, in
which a series is approximated by a sequence of steps—i.e., segments are parallel to
the X-axis. Piecewise Aggregate Approximation (PAA) [26] is one such technique. At
regular times it extracts data samples (e.g., the average of the period), and represents
an interval with this value. In some cases, the value of the step can be defined by other
means—e.g., the average of the values collected in that interval.

The APCA approach Adaptive Piecewise Constant Approximation [18] is similar,
but it is an adaptive representation, in which time intervals are not regular. The
length of the segments is adjusted to the variation of data: the length of segments,
and the number of segments to represent a period can vary. The difficulty of APCA
lies in indexing, since the number of elements that represents one series is variable. In
order to solve this problem, [18] proposes a solution based in two different distance

Geoinformatica (2011) 15:75–109

81

functions. The first one looks for the best possible approximation to a given series.
The second, which is easier to compute, ensures that the distance computed will
be strictly smaller than the real distance. Keogh and Pazzani [24] treat the issue of
indexing APCA representations. Their comparison with other indexing techniques
show that their proposal can be used by many kinds of distance functions.

Most techniques that adopt the APCA approach consider that series are static.

The APCAS method [17] adapts the segmentation algorithms to process streams.

2.3.2 Symbolic representations

In symbolic representation [15, 20, 26, 32], the series is somehow converted into
a sequence of symbols, i.e., a series of values is transformed into a string. This
representation allows the use of text matching algorithms to compare series.

Lin et al. [27] points out, however, that symbolic representations have the same
dimensionality of original data and that distance computation has no correspondence
with the original distance between series. Their SAX approach solves these problems
[27]. It first applies a PAA approximation, thereby reducing dimensionality, and then
assigns symbols to each step. Symbol assignment again reduces dimensionality, by
creating classes whose boundaries are called breakpoints, representing levels into
which step values can be classified. A step value that falls within two breakpoints is
assigned the corresponding class symbol.

Still another approach associates segments with states of a finite state machine
that describes the phenomenon being measured [40]. Here, symbols correspond to
the states.

As will be seen, TIDES follows procedures that are analogous to those in SAX,
combining segmentation with symbolic representation. Unlike SAX, however, it
concentrates on angular variation, whereas SAX and all other methods deal with
collected values.

2.3.3 Use of spectral information

Another family of feature extraction functions is based on analyzing spectral infor-
mation present in the series. Many signal processing techniques have been used to
this effect [9]. Examples include the use of Fourier Transform [10], Singular Value
Decomposition (SVD) [25], and Wavelet Transformations. Although these solutions
are able to represent behavior with a small number of coefficients, they require the
curve to be locally stationary in time. Furthermore, there can be problems when
similarity computation involves some kind of scale or displacement processing.

The Discrete Fourier Transform (DFT) can eliminate noise introduced at data
capture, by decomposing a series into a set of sinusoidal functions, whose coefficients
are used in the representation. According to Faloutsos et al. [10], a small number of
coefficients suffices to obtain a good description of most series. While DFT can only
represent a series in a single time scale, wavelets allow multiple scales/resolutions.
However, they can only be used in time series whose length is a power of two. In
singular value decomposition (SVD) [25], only the most significative dimensions of
a data set are maintained, reducing the dimensionality of the initial data set. This

82

Geoinformatica (2011) 15:75–109

technique, however, may not present satisfactory results [9], and does not scale well
to large series [7].

Spectral transformations may be used in isolation or as a part of a sequence
of transformation steps. An example is the work of Rafiei and Mendelzon [34],
whose goal is to support more elaborate database queries on series, allowing user
interaction during query processing. The authors define different mappings from
DFTs coefficients into a multidimensional index (R*-tree), which is used to reduce
the number of similarity candidates. This approach presents performance problems,
because the indexing structure is constructed for each query. It can only be applied
to static sequences, and cannot be used in the search for subsequences. This is,
nevertheless, an interesting example in which spatial indexing structures are used
to index time series and to compute distance functions.

The STPCA (Space-Time Principal Component Analysis) approach of [16] re-
duces spatio-temporal series simultaneously along the temporal and spatial axes
using principal component analysis. Data sources are sensors distributed spatially,
for values collected at identical intervals. Their descriptor relies on combining
both spatial and temporal dimensions, creating bidimensional matrices, in which
each element is a value captured by a sensor placed in a specific position, for a
given instant of a day. Matrices are combined and processed, resulting in much
smaller matrices, whose columns (or rows, depending on the case) become the new
series—the input to similarity computation. Experiments with real historical data
on traffic sensors show that this kind of reduction provides good approximations.
However, atypical traffic days (e.g., holidays) are not well captured unless processed
in isolation—the entire day becomes an outlier.

2.4 Characterization of a time series—distance functions

Distance computation is classified by [7] into lock-step measures (L p norms), elastic
measures (in which one point in one series may be mapped to several points in
another) and other special measures (based on thresholds, and on patterns).

Distance functions are intimately associated with the representation chosen.
L p norms are the most common, including Manhattan (L1) and Euclidean (L2)
functions. Though frequently used, they are not suitable to all cases [20, 32]—e.g,
when symbolic representation is chosen.

In other cases, series that present similar behavior can have relative displacements
as regards the Y-axis (as mentioned in the introduction), or differ in temporal scales.
In such situations, distance functions that compare pairwise points (such as L1 or L2)
would not detect the similarity. The Time Warping Distance [20, 32] was proposed to
solve this problem. In this approach, rather than computing the distance between
two series at each sampled instant, the technique computes the points for which the
distance is to be evaluated. Time Warping Distance was originally considered unable
to allow exact indexing mechanisms [1]. Dynamic Time Warping [20] was introduced
to solve this issue, and meet performance requirements. This has enabled the use of
Time Warping Distance for several kinds of application domains.

If this distance solves the problem of temporal displacements, no technique, to
our knowledge, directly attacks the problem of Y-axis displacement. As will be seen,
our descriptor is able to solve this problem, by describing series oscillation behavior.

Geoinformatica (2011) 15:75–109

83

TIDES can be combined with Dynamic Time Warping to solve at the same time the
issues of Y- and time-axis displacements.

While all these functions can be applied to numeric values, symbolic repre-
sentations require a different kind of distance metrics. To compute the distance
between two series represented symbolically, one must quantify the distance between
each pair of symbols employed—e.g., using the text-based edit distance [31]. Such
functions are also adopted, for instance, in bioinformatics, to compare DNA strings.
In symbolic representations that are applied to reduced series (e.g., in PAA), a
symbol stands in fact for a class that contains a set of values. Hence, the distance
between two symbols can be defined by the distance between the sets of points—e.g.,
the centroid of each class is computed, and the distance between classes is computed
as an L p distance between the centroids.

For an overview of some distance functions on symbolic representations, the
reader is referred to [7]. The same survey points out that very good performance
can be obtained by Euclidean and DTW distances—i.e., “Euclidean is the fastest and
most straightforward, and DTW is the oldest elastic measure”. They are both shown
to outperform most distance computation functions in series classification. We adopt
a basic Euclidean function in our computations.

2.5 Data co-evolution

One time series characterizes the evolution of a given phenomenon with time. An
associated problem is that of co-evolution. This occurs whenever we are faced with a
set of series that represent phenomena that evolve together, and where each series
influences the evolution of the others [41]. The challenge is to perform a joint analysis
of these series, discovering their relationships.

Agriculture is an example where experts frequently perform co-evolution analysis.
In order to monitor crop growth, several factors have to be taken into account.
Experts often concentrate on a few key issues—in particular temperature, rainfall
and NDVI (normalized vegetation index). The latter is computed from satellite
images, and quantifies the concentration of green leaf vegetation in an area. An
NDVI time series is computed using a time series of satellite images as a data
source. A point in such a series corresponds to the greenness factor measured from a
composite satellite image, for a specific region (covered by one or more pixels). The
point’s timestamp corresponds to the composite image’s timestamp.

Experts are required to analyze the joint evolution of these variables, for a
given region, and study their correlation—e.g., excess of rain (or a long period
of abnormally low temperatures) may destroy a crop and hence affect the NDVI
measured for a region. A study of the co-evolution of these variables helps forecast
crop yield, provided that specific patterns are identified. For instance, suppose
temperature, rainfall and NDVI time series are available for a given region, together
with crop yield history for the same region. Then, experts can infer future yields
for that crop and region if temperature, rainfall and NDVI series show co-evolving
patterns similar to those in the past. Sections 4 and 5 extend this example with
analysis of real data we use in our co-evolution experiments.

Joint analysis of a set of series presents several problems, e.g., they can differ from
each other in sampling frequency, or value range. This kind of analysis is becoming

84

Geoinformatica (2011) 15:75–109

increasingly relevant, due to the dissemination of sensor networks in many kinds of
geospatial applications. One may even envisage co-evolution analysis for one single
kind of phenomenon, such as the one performed in our experimental analysis of
Section 5, e.g., to detect spatial correlations or anomalies.

There is comparatively little research reported in co-evolution of time series.
Yi et al. [41] present a technique for co-evolution analysis, in which they predict
trends, detect outliers and analyze correlation of distinct streams. This technique,
called MUSCLES (MUlti-SequenCe LEast Squares), is based on linear regression
of multiple variables. MUSCLES forecasts the evolution of a given series by jointly
applying linear regression on the last w values of all the series being analyzed. The
values of the variables used in the analysis are not stored, which hampers subsequent
use of other mining techniques.

Co-evolution analyses are found in many kinds of domain, and the techniques
applied might perhaps be extended to perform mining in co-evolving time series.
One example is the work of [30], who analyze the co-evolution of models and data,
where models are created and run on the data. As more data are collected, models
must be re-evaluated and re-executed. The idea is to develop mechanisms to support
simultaneous model tuning and updates to data sets.

While [30] deals with scientific time series, the research presented in [8] concerns
a completely different area—software engineering. The main issue, here, is to
manage systems requirements in the development of information systems. However,
a change in one set of requirements may modify all others—thus, requirements
evolve together and affect each other.

3 The TIDES descriptor

3.1 Overview

From a high level point of view, the TIDES descriptor is derived as follows. Similar
to other approaches, our work performs adaptive piecewise linear segmentation, and
then assigns a symbolic representation for each segment. Unlike all other descriptors,
the information used to represent each segment is its angular coefficient.

This section describes TIDES in two stages. The first stage presents the construc-
tion of the feature vector (Section 3.2) and the definition of the distance function
(Section 3.3). This is the basis of the descriptor, and allows comparing the oscillation
behavior of any two series. The second stage introduces the multiscale description
of one series (Section 3.4), whereby TIDES is able to represent one single series
in multiple time granularities. As a consequence, two series can be compared for
distinct temporal scales.

Table 1 shows the main symbols used in this section.

3.2 Feature vector extraction

3.2.1 Transformation into segments

Our feature descriptor represents the data as a set of linear segments, using a linear
segmentation algorithm with the bottom-up approach—see previous section. Each
of the segments has an angular coefficient ai with respect to the vertical axis. This

Geoinformatica (2011) 15:75–109

Table 1 Symbols used in the
definition of TIDES—one and
multiple scales

85

Time series i
Point in a series at timestamp ti
Number of points in a series
A segment { pi, pi+1} produced by segmentation
Number of segments used to segment Si
Angular coefficient of segment gi
Length of projection of segment gi onto the X-axis
Number of classes for symbol assignment
Symbol that represents one of the ng classes
Symbol in series A that has been assigned

to the ith segment

Feature vector < yi, li >
Feature vector after normalization
Size of normalized vector vn
Number of scales in a multi-scale representation

Si
pi
n
gi
nseg
ai
li
ng
y
yi,A

vs
vn
m
κ

coefficient represents the oscillation trend of a series in the corresponding time
interval. The points where two segments meet are called join points in the rest of
this paper. Figure 2 shows a linear segmentation for a time series. Two contiguous
segments are tied to one join point.

In more detail, bottom-up segmentation starts by linking the points { p1, p2, ..., pn}
of a given series by line segments {{ p1, p2}, { p2, p3}, ..., { pi, pi+1}, ..., { pn−1, pn}}.
Next, the sequence of segments is examined in an iterative process. At each iteration,
a segment is removed, being chosen so as to introduce the smallest error in the
series. An iteration involves the following. Suppose that segment { pi, pi+1} is to
be removed; this requires replacing segments { pi, pi+1} and { pi+1, pi+2} by a new
segment { pi, pi+2}. The length of the projection on the X-axis of the new segment
is equal to the sum of the lengths of the projections of the two segments that were
removed. Figure 3 illustrates one iteration step. The two segments in series (a) are
replaced by one segment in series (b).

We considered distinct criteria for error computation, always based on compar-
ison with an error threshold, established by the user. Consider points Pi−1, Pi and
Pi+1, and suppose the middle point (coordinates xi, yi) is eliminated, resulting in a
new segment s connecting Pi−1 and Pi+1. We tested the following criteria:

–

–
–

computing the difference between the areas below the curve, before and after Pi
is eliminated;
computing the difference in angles at Pi−1 if Pi is eliminated; and
computing the difference between values yi and Yi, where the latter is the value
at the y-axis, at x = xi for the segment s.

Fig. 2 Linear segmentation of
a time series

86

Geoinformatica (2011) 15:75–109

Fig. 3 Eliminating one
segment from the linear
representation of a time series

The last kind of computation presented the best behavior in our tests.
We tested the segmentation procedure with several stop criteria:

–

–

Stopping when the accumulated error introduced by segment elimination
reaches a given threshold;
Stopping whenever the error introduced by the elimination of one segment
reaches a given threshold; and

– Using a pre-defined (fixed) number of segments.

For each of these criteria, we ran similarity computations with 1,800 queries, for
series with 60 points. The third option (fixed number of segments) presented the best
performance, being therefore adopted to characterize the series.

3.2.2 Feature vector representation

Our feature vector is based on the notion of angular coefficient to characterize a
series’ oscillation patterns. An angular coefficient represents the slope of a segment
wrt the vertical axis. Consider a series S that has been transformed into nseg segments
< g1, g2, ..., gnseg
>. The initial vector that is used to compute the feature vector is
defined as

v =<< a1, l1 >, < a2, l2 >, ..., < anseg

, lnseg

>>

(1)

where ai is the angular coefficient of segment gi and li is the length of its projection
on the horizontal axis. Figure 4 shows the angular coefficients obtained from the
segmented series (b) of Fig. 3.

The use of angle values, however, may introduce several problems in similarity
computation (e.g., due to precision issues or overflows). For this reason, we adopted a
widespread solution—symbolic representation—see Section 2. Under this approach,
in TIDES, angular coefficients in one series are submitted to a classification function
Fclass, and are assigned to a class (which is represented by a symbol). These classes

Geoinformatica (2011) 15:75–109

Fig. 4 Angular coefficients of
series in Fig. 3b

87

are created by clustering functions. Thus, the feature vector vs is defined as1

vs =<< y1, l1 >, ..., < ynseg

, lnseg

>>

(2)

where yi
is the symbol of the class assigned to segment gi. Figure 5 shows a
classification function converting the series of angular coefficients from Fig. 4
into a series of symbols, representing the angular variations—and thus oscillation
behavior—of the series. Notice that symbol y1 appears twice, indicating that the two
segments have been assigned to the same class.

An angular coefficient can vary between 0◦ and 180◦ (or 0 and π radians), in
relation to the vertical axis. This range of possible values is partitioned in ng sets,
where ng is defined by domain experts.

Angular coefficient a j will be classified by Fclass as belonging to class i when:

(i − 1) ∗ 180
ng

≤ a j < i ∗ 180
ng

(3)

Algorithms 1 and 2 respectively compute feature vectors for one and multiple

scales.

Algorithm 1 SingleScaleFeatureVector(S, nseg, ng)
1: g ← segmentSeries (S, nseg) {Segment input time series S into nseg segments,

producing a vector of line segments g};

2: for i = 1 to nseg do
3: < pi, pi+1 >← g[i]; {Extract endpoints of ith segment}
ai ← computeAngularCoefficient(< pi, pi+1 >);
4:
li ← computeProjectionIntoX(< pi, pi+1 >);
5:
yi ← classifyCoefficient(ai, ng);
6:
vs[i] ←< yi, li >; {vs is the output feature vector}
7:
8: end for
9: RETURN;

1We use vs to stress that the vector uses symbolic representation.

88

Geoinformatica (2011) 15:75–109

Fig. 5 The use of the
classification function in time
series of Fig. 4

Algorithm 2 MultiScaleFeatureVector(S, ScaleSet, ng)
1: for j ∈ ScaleSet do
2:

v ← segmentSeries(S, j); {Segment input time series S into j segments, pro-
ducing a vector of line segments g};
{FOR i = 1 to j, compute elements of feature vector vs[i] = < yi, li >—see
Algorithm 1}

3: ms[ j] = vs; {ms is the multi-scale feature vector}
4: end for
5: RETURN;

3.3 Distance function

Once the feature vector is extracted, the next step is to define the distance function.
Symbolic representation supports several kinds of distance functions. We define the
distance between two consecutive classes to be 1, following the angular partition of
the interval [0◦,180◦]. For instance, if ng = 3, then the classes correspond to symbols
yc1, yc2, yc3, where yc1 stands for all angles of class c1, i.e., in the interval [0◦,60◦), and
so on. Then, the distance between yc1 and yc2 is 1, and between yc1 and yc3 is 2.

To compute the distance between two feature vectors we used the following.
First, two feature vectors vsA and vsB with different number of segments need to be
normalized into new feature vectors, vnA and vnB, with the same size. Normalization
consists in creating additional (virtual) join points, so that all segments will be
aligned, with the same number of points.

Normalization is performed the following way. Suppose that, in a given timestamp
ti, just one series—vsA—has a join point. We then insert an artificial join point in the
other series—vsB—for the same timestamp ti, so that both series can be compared at
ti. This artificially inserted point transforms a single segment in vsB into two distinct
segments, with the same oscillation behavior (and thus the same symbol).

Figure 6 illustrates the normalization process, for series SA and SB that have been
approximated by segmentation functions and then normalized. Points j1 to j7 are the

89

(4)

(5)

Geoinformatica (2011) 15:75–109

Fig. 6 The normalization
process, creating two artificial
join points

original join points, and points p1, p2, and p3 are artificial join points created in the
normalization process.

The distance between vnA and vnB is given by:

D(vnA, vnB) =

d(< yi, li >A, < yi, li >B)

i=m(cid:2)

i=1

where < yi, li >A stands for the ith element of vnA, d(< yi, li >A, < yi, li >B) is the
distance between the ith (normalized) segment of vectors vnA and vnB, and m is the
size of the normalized vectors. Distance d is computed as:

d(< yi, li >A, < yi, li >B) = (| yi,A − − − yi,B |) ∗ li

Intuitively, this is the same distance approach followed by several other methods,
which compute the distance between two vectors as the sum of the distances between
pairs of corresponding segments. Distance computation performs O(n) comparisons,
where n is the number of segments of a feature vector. We recall that the distance
between any two consecutive symbols is 1. Algorithm 3 shows distance computation
for one scale.

Algorithm 3 DistanceOneScale(vsA, vsB)
1: Normalize vsA and vsB, producing vnA and vnB;
2: d ← 0;
3: for i = 1 to |vnA| do
4: < yi,A, li,A >← vnA[i] {Extract ith element of vnA}
5: < yi,B, li,B >← vnB[i]
6:
7: end for
8: RETURN d

d ← d+ computeSymbolDistance(yi,A, yi,B); {Compute Eq. 5}

3.4 Multiscale description

So far, our descriptor provides the oscillation behavior of a series that has been
approximated by linear segments. This approximation, however, depends on the
number of points chosen in the segmentation process. This may not be sufficient to

90

Geoinformatica (2011) 15:75–109

Fig. 7 Four different
representations for series
number 120, using one (a), five
(b), 13 (c) and 30 (d) segments

describe actual oscillation trends. To solve this, we extend our solution to a multiscale
approach: instead of representing a series by one feature vector vs, we describe it
using multiple feature vectors < vs >. Each vector corresponds to a segmentation
obtained with a different number of points.

The multiscale feature vector of TIDES is thus:

ms =< vs(1), vs(2), ..., vs(k), ..., vs(κ) >,

where k is the number of segments used to approximate the series in a given time
granularity, vs(k) is a feature vector, for a scale with k segments, and κ is the maximum
scale. In particular, vs(1) uses the endpoints of the series, and corresponds to a single
segment. The value of κ is defined by domain experts.

Figure 7 illustrates this idea, with the segmentation of a series extracted from the
Synthetic Control dataset,2 identified by number 120. It shows how to approximate
the series with one (a), five (b), 13 (c), and 30 (d) segments. Each scale corresponds
to a distinct level of detail—e.g., with one segment it is possible to see the rough
oscillation tendency (ascending, descending, stationary).

Intuitively, the multiscale approach allows users to analyze a series under distinct
granularities. For instance, suppose two series are similar at scales 1 and 2, and
dissimilar afterwards. This means that only for very coarse time granularities they
show the same tendency. In another example, two series may be similar in a fine
granularity—say, n segments—but dissimilar at levels 1 and 2. In this second case,
one curve is ascending (in terms of the Y-axis) and the other descending, but local
oscillations follow the same behavior.

For multiscale analysis, the feature vector is composed of an array of feature
vectors. The multiscale comparison between two series is done in two basic steps.
First of all, the vectors for each scale are compared, using the distance function
defined. As an example, consider two multiscale feature vectors for series SA and
>. To compare
> and msB =< vs
SB, msA =< vs

, ..., vs

, ..., vs

, vs

, vs

(1)
B

(2)
B

(κ)
B

(κ)
A

(1)
A

(2)
A

2www.cs.ucr.edu/∼eamonn/timeseriesdata/

Geoinformatica (2011) 15:75–109

91

(2)
A
(2)
B , and so on. Notice that normalization must be performed for each scale

these series, we should normalize them pairwise, and compare vn
with vn
separately.

(1)
A with vn

(1)
B , vn

The distance function for the multiscale case is based on computing Eq. 4
repeatedly for each scale considered. The distance between two multiscale feature
vectors msA and msB is based on the multiscale distance vector

DM =< D(vn

(1)
A

, vn

(1)
B

), ..., D(vn

(κ)
A

, vn

(κ)
A

) >

(6)

(1)
A

(1)
B

, vn

where D(vn
) is computed using Eq. 4. Distance vector DM can subsequently
be used to compute several kinds of distance functions—e.g., sum or Euclidean
distance. The distance vector itself is a good indicator of the scale(s) for which
two series can be considered most similar, as illustrated in Section 5. For instance,
DM =< 73814, 3830, 277 > indicates that the series oscillation behavior becomes
progressively similar as the number of segments is increased (see example of Fig. 11,
discussed in Section 5).

4 Generalizing TIDES to cope with co-evolution

Co-evolution analysis is needed whenever more than one factor contributes to a
given situation. Geospatial models are a prime example of this need, requiring joint
analysis of several phenomena, to see how they affect each other—e.g., see our
example from agriculture in Section 2.5.

So far, we have represented one temporal series as a graph, in which the X-axis
represents time and the Y-axis represents the variable being measured. This can
be extended to the problem of co-evolution, in which each series gives origin to a
graph, and all graphs must be treated together. However, in this case the Y-axis can
seldom represent one single measurement unit or scale—e.g., joint analysis of rain
and temperature series.

Figure 8 illustrates such a scenario, for real data used in our experiments. In the
figure, each curve portrays the evolution of crop greenness, as measured by NDVI,
for one given area within the county of Penapolis, in Brazil. Data is extracted from a
series of satellite images for year 2003, at 10 day intervals. Similarity analysis, in the
scenario illustrated in the figure, means that one must find sets of three series (for
the same phenomena) that show similar behavior, for the same time interval.

This figure is particularly interesting, from a practical point of view, because it
shows very different greenness variation patterns, even though data comes from
sugar cane plantations only, and from a single county. Hence, this kind of co-
evolution analysis can help detect anomalies within a spatial unit (in our case, a
county). From it, experts can look for causes of such diversity—e.g., distinct soil types
or management practices, or types of crop. Additional knowledge is also needed to
interpret the curves—e.g., peaks (top greenness) are followed by valleys (reaping
and planting seasons). However, a valley may also appear due to other phenomena—
such as excess rainfall, which kills the plants (and thus causes drop in greenness). In
order to determine such causes, additional series have to be overlaid to this graph—
temperature and rainfall are the most common ones for this domain, as already
mentioned in Section 2.5.

92

Geoinformatica (2011) 15:75–109

Fig. 8 Three different time
series, represented in one
graph. Data extracted from
satellite images, showing
evolution of crop (sugar cane)
greenness in three distinct
areas of the Penapolis county,
Brazil

Section 5 discusses our experiments conducted on such data—for spatial and

temporal correlations.

TIDES can be generalized to deal with co-evolution starting from the same basic
steps of segmentation (Section 4.1), angle classification (Section 4.2) and distance
computation (Section 4.3), with the goal of describing the joint oscillation of the
curves.

We proceed as follows. Consider that we have η different series whose co-
evolution must be described. First, we process each series individually, obtaining
η feature vectors vs. Next, we further reduce the dimensionality of the problem,
transforming these vectors into one single vector (i.e., our co-evolution feature
descriptor), where each point is an η-dimensional element. Once this achieved,
we adapt the distance computation function to deal with these elements. Table 2
contains the additional terminology used in this section.

4.1 Joint segmentation of multiple curves

The segmentation of each series in a co-evolving set will probably result in a different
set of join points, complicating the classification procedures.

Table 2 Symbols used in the
definition of TIDES—
co-evolution of series

CS
η
α
Ttrans

ACT

V S
V N

A set of co-evolving time series
Number of series in CS
Symbol assigned to a multidimensional class
Set of timestamps of join points,
all series in CS confounded

Angular Coefficients at Timestamp

(vector of all angular coefficients at a
given timestamp in Ttrans)

Feature vector for co-evolving series
Normalized feature vector

Geoinformatica (2011) 15:75–109

93

In order to attack this problem we extended TIDES the following way. Let CS =<
S1, S2, ..., Sη > be a set of series whose co-evolution we want to analyze, for a given
time interval. Then, the following steps should be performed.

1. Segment each series in CS, independently, for a fixed number of segments
nseg, defined by a domain expert. This is an initial approximation to the final
number of segments, since the next step requires introducing join points to allow
condensation of all series into one.

2. Perform a normalization procedure, introducing artificial join points in each
series, when needed, so that at the end all series in CS will have the same number
of segments. Unlike the single series analysis, however, the artificial points
introduced become part of each series, forming new segments that are actually
stored. In the single series case, join points were virtual because they were used
only to dynamically compute distances. In order to stress this difference between
these cases, the set of timestamps associated with the join points stored (both
real and artificial) receives the name of Transition Timestamp Set, Ttrans, being
defined by:

Ttrans = ∪i=η

i=1 Ji

(7)

where Ji represents the timestamps associated with the set of artificial and real
join points of series Si ∈ CS.
Once Ttrans is created, we consider CS to have been normalized wrt time units.
Now, CS can be submitted to the subsequent steps of descriptor creation, i.e.,
assignment of class symbols and computation of distances.

Figure 9 illustrates the normalization process. The horizontal line corresponds to
equation Y = 0. For instance, point U P1,3 is a join point belonging to S1 at time
ti = 40, but S2 does not have any join point at this timestamp. Hence, AP is the
artificial point inserted in S2, to allow dimensionality reduction.

At the end of the normalization process, all series in CS will be represented by
the same number of segments, regardless of initial differences in sampling rates. The

Fig. 9 Segmentation of a set
of series for co-evolution
analysis. Normalization
introduces artificial join points

94

Geoinformatica (2011) 15:75–109

projection of the i − th segment of each series into the X-axis will have the same
length li.

4.2 Computing the feature vector for multiple curves

For each timestamp t ∈ Ttrans, we now construct a vector Ct containing the angular
coefficients of series S1, S2, ..., Sη—i.e., Ct[i] represents the angular coefficient of
series i, at timestamp t. The name given to each η-dimensional Ct vector is ACT
(Angular Coef f icients at a Timestamp), used in the subsequent steps of creating the
descriptor.

We now proceed to symbol assignment. However, in the case of multiple series,
this requires more elaborate procedures. Instead of defining a classification function
for a single angular coefficient, we classify ACTs (i.e., we define a scheme that will
assign each ACT vector to one class).

This reduces the dimensionality of the problem, and allows the use of techniques
such as described in Section 3 for single series. In this symbol assignment scheme,
each class is represented by one symbol αi, and li is the length of the projection of the
i-th segment of a series into the X-axis after normalization. The feature vector V S of
the set of series CS becomes:

V S =<< α1, l1 >, < α2, l2 >, ..., < αnt

, lnt

>>

(8)

where nt =| Ttrans | −1.

The definition of V S is similar to the definition of vs (the feature vector of a
single series—see Section 3.2). However, these vectors are very different: in vs, one
symbol yi represents the angular coefficient of a line segment, while in V S symbol αi
represents a vector containing η angular coefficients.

Symbol assignment of angular coefficients for multiple series is performed in two
steps. The first step is analogous to the process for a single series, i.e., each series Si in
CS is analyzed by itself, where for each timestamp t ∈ Ttrans, one must compute the
class of the angular coefficient of Si[t]. We recall that the range of possible angular
coefficients is between (0◦ and 180◦), to be partitioned into ng groups. An angular
coefficient is assigned symbol yci if contained in the range of coefficients of the class
ci (see Eq. 3).

After this step, each series Si
in CS is represented by a vector of symbols
<< yi,1, l1 >, < yi,2, l2 >, ..., < yi,nt
>>. Analogously, the ACT at time t has been
, lnt
transformed into a vector of η symbols. The next step is to represent each ACT by
one single symbol; as a consequence, the set of series CS will be represented by one
single feature vector, where each element “encapsulates” an η-element vector—i.e.,
it is a point in an η-dimensional space.

In this scheme, classes are clusters of these points. Each dimension represents the

angular variation for one of the η series in CS.

The values within the η-dimensional space generated by the classes that describe
an ACT depends of two variables: (i) the cardinality of CS (i.e., η); and (ii) the
number of groups (ng) used to classify a single series. Thus, the number of overall
η
symbols is n
g, and each ACT is assigned one such symbol. The result is a new feature
vector V S, as seen in Eq. 8.

The distance between two vectors V SA and V SB can be computed similarly to the

distance between two vs vectors representing one series each (see Eq. 4).

Geoinformatica (2011) 15:75–109

95

4.3 Distance function between sets of series

Similar to Section 3.3, the distance between two feature vectors requires two steps:
normalization and distance computation. We perform normalization using the same
procedure for comparing two single series. However, we now need to compare two
sets of series, say CSA and CSB. Thus, the normalization process will consider the
transition timestamps defined by each set of series CSk, i.e., all join points of all
series need to be considered. These join points are represented by the elements of
Ttrans of each CS.

Then, after normalization, the set of timestamps in the normalized feature vector

V N is

TTransV N A = TTransV N B = TTransV SA ∪ TTransV SB

(9)

where, for instance, TTransV N A is the set of transition points of vector V NA. The
construction of the join points ensures that

–

|V NA| = |V NB| = |TTransV N A| − 1—i.e., the normalized vectors have the same
size;

– The length of the projection of the i-th line segment on the X axis is the same for

both vectors, i.e., ∀i ∈= {1, ..., |TTransV N|}, l(i,V N A) = l(i,V N B).

Given these properties we can define a distance function between V NA and V NB

based on the Euclidean metrics

DCE =

d(< αi, li >A, < αi, li >B)

|V N A|(cid:2)

i=0

where the distance between two η-dimensional classes is

d(< αi, li >A, < αi, li >B) = d(αi,A, αi,B) ∗ li

(10)

(11)

Hence, there remains to define how to compute the distance between two classes.
A class cei contains a cluster of points in an η-dimensional space (e.g., a rectangular
region for 2D). The distance between two clusters (each of which represented by a
symbol) is defined to be the Euclidean distance between the corresponding centroids,
i.e.,

d(αi,A, αi,B) =

(zi,A − − − zi,B)2

(12)

(cid:3)
(cid:4)
(cid:4)
(cid:5)

η(cid:2)

i=0

where zi,A corresponds to the centroid of the cluster to which αi,A belongs.

Figure 10 illustrates the distance between two classes c1 nd c2 in a 3-dimensional

space.

4.4 Algorithm

The basic principles used in the version of TIDES for analyzing one series are
the same ones for joint analysis of co-evolving series. Algorithm 4 presents the
generalization of Algorithm 1 (that extracts the feature vector for one series) to a
set CS of multiple co-evolving series.

96

Geoinformatica (2011) 15:75–109

Fig. 10 Distance between two
classes in a 3-dimensional
space, where c stands for the
centroid of the corresponding
cluster

Algorithm 4 Co-evolutionFeatureVector(CS, nseg, ng)
1: for i = 1 to |CS| do
2:

end for

Si ← CS[i] {Compute a feature vector vs for each series in CS—repeatedly
invoke Algorithm 1.}
Segment temporal series Si, obtaining a vector vi with nseg line segments;
for j = 1 to nseg do

< p j, p j+1 >← vi[ j];
a j ← computeAngularCoefficient (< p j, p j+1 >);
l j ← projectIntoX (< p j, p j+1 >);
y j ← classifyCoefficient (a j, ng);
vsi[ j] ←< y j, l j >; {vsi is the feature vector of series Si}

3:
4:
5:
6:
7:
8:
9:
10:
11: end for
12: Apply normalization to all vectors vsi, generating normalized vectors vni. {At the
end of normalization, all individual feature vectors will have the same number of
elements, say, |vn1|}
13: for k = 1 to |vn1| do
14:
15:
16:
17: end for
18: RETURN;

ACT[k] ← vs1[k], vs2[k], ..., vsn[k]
αk ←assignSymbol(ACT[k]);
V S[k] ←< αk, lk >; {V S is the feature vector describing co-evolution}

The distance between feature vectors produced by Algorithm 4 can be computed
by repeatedly using the same function as described in Algorithm 8. The only
difference is that now the distance between two vector elements (i.e., symbols) must
be computed taking into consideration the fact that the classes are η-dimensional.
Function assignSymb ol is processed in two steps, and assigns a symbol to each
set of angles within one time interval—see its description in Section 4.2. Like the
single series version of TIDES, the complexity of Algorithm 4 is O(n) to construct
the feature vector, where n is the size of the series with the maximum number of
segments in a co-evolving set. Since we store artificial points, storage space is also
O(n).

Geoinformatica (2011) 15:75–109

97

5 Experimental analysis

This section describes the experiments performed to validate our descriptor, for one
time series (in one and multiple scales) and for multiple time series (co-evolution
analysis). Each section deals with a different kind of issue. Consider a database
containing several time series (or sets of time series in the case of co-evolution
analysis). The goal of similarity experiments is to find, in this database, all series
(sets of series) which are similar to another series (set of series) provided as input.
We call this input (set of) series a query series.

5.1 Datasets used

Three kinds of datasets were used. The first, the Synthetic Control dataset series
from [22], were used to validate two important TIDES features: y-axis invariance
and multiscale analysis. In more detail, the series at [22] correspond to 21 different
datasets, with different sizes of time series. Each dataset has a different number of
elements and classes. The datasets are separated in two main sets: the training and the
test set. We joined both sets, in order to construct a bigger one. In our experiments,
we have used only the Synthetic Control dataset, with a total of 600 time series
(training set and test set together), each of which with 60 points. The time series
are classified into six different classes.

These test datasets contain series that characterize situations where value-based
similarity is more suitable. Since our descriptor, instead, characterizes oscillation
trends, the series used do not present the best conditions for the usual precision
and recall validation. For this reason, our evaluation is based on a combination of
numerical and visual analysis.

For the 600 series database, we conducted 1,200 tests for the monoscale version of

TIDES, and 6,000 tests for multiscale analysis.

Our second test set used real data—monthly average maximum and minimum
temperature readings since 1961—from five Brazilian cities in São Paulo state
(Campinas, Jaboticabal, São Carlos, Sorocaba and Taubaté). We used this data to
construct a set of 1,336 series of 48 points each, and classified them according to the
month where the series started—e.g., all series beginning in January of some year
belong to class 1. This second test set was used to compare the precision of TIDES
against Linear Scan. We selected this kind of phenomenon because temperature
oscillation is similar in a given geographical area, in the same season, even though
values themselves may vary—e.g., São Carlos is always much hotter than Campinas,
but both are cooler in winter.

The third dataset was used for validating the co-evolution descriptor. It is com-
posed by sets of curves that represent the evolution of crop greenness, as measured
by NDVI, for areas of 31 different counties, in Brazil (examples of these sets of
curves can be seen in Figs. 8 and 14). One curve represents the average NDVI value
for a given area within a particular county for a given year, at 10 day intervals. For
each county, three different sets of curves are considered in a range of 8 years (from
1999 to 2006). Therefore, the total number of sets is 744 (3 × 8 × 31). As pointed
out before, similarity analysis, in this scenario, means that one must find sets of
three series (for the same phenomena) that show similar behavior, for the same time
interval.

98

Geoinformatica (2011) 15:75–109

5.2 Invariance to noise in the y-axis

Figure 1 illustrates the problem of noise in the y-axis, where similarity between
the two sub-series is not captured by other methods. This section comments on
experiments conducted to evaluate TIDES when comparing series that present this
sort of relative behavior, for the synthetic data sets. In this case, we used a simpler
(single scale) version of the descriptor.

For each series Si in the synthetic series base, we created a noisy series S(cid:10)

i by

displacing Si by a random δ value wrt Y-axis. S(cid:10)

i was thus constructed as:

S(cid:10)
i

[ j] ← Si[ j] + δ, ∀ j ∈ {1, ..., n}

(13)

In the experiment, it was expected that S(cid:10) should be returned as one of the most
similar series when the query series is S. This was in effect the case: the artificial
series S(cid:10) was always returned as the most similar series (after the S series itself). We
repeated this experiment for all the original 600 series, and for some of the real data
temperature series. This test was conducted to confirm our implementation complies
with TIDES immunity to displacement in the y-axis.

5.3 Introducing multiscale description

One of the advantages of TIDES is that it allows similarity evaluation at different
granularities. This is adequate for cases in which users want to examine a given
phenomenon from distinct scale perspectives—e.g., in some applications in traffic
or economy.

Figures 11 and 12 show the result of a multiscale comparison using TIDES, for two
series in the Synthetic Control dataset—120 and 194. In more detail, Fig. 11 shows
the curves that describe these series for one segment (vn(1)), 10 segments (vn(10)),
and 55 segments (vn(55)), respectively Fig. 11(a–c). The figure also shows that, for

Fig. 11 Multiscale comparison
between series 120 and 194,
using three different
granularities

Geoinformatica (2011) 15:75–109

Fig. 12 Multiscale distance:
series 120 and 194

99

the one-segment representation, the distance computed was 73814,4, whereas for a
55-segment it went down to 277,4.

Suppose the similarity threshold defined by application domain experts is 300—
i.e., D(vn120, vn194) <= 300. Then, the result obtained by TIDES for these three
scales is that they are one-dissimilar, ten-dissimilar, but 55-similar.

Figure 12 shows a curve that plots the distinct distance values between the same
two series (120 and 194), for several scales. Here, at lower granularities they have
very different oscillation tendencies, but as we “zoom into” more detailed scales they
present similar oscillation behavior.

Figure 13 helps understanding our descriptor. It shows the sequence of angular
coefficients of these two series, with time, for the smallest granularity (vn(55)). One
can see that their oscillation patterns are very close, if one considers a larger number
of segments.

5.4 Comparison with linear scan

This section presents a comparison of single granularity TIDES and Linear Scan (a
point-to-point comparison) descriptors, which illustrates their differences, using our
temperature time series dataset. All the series had 47 segments (n = 47), and we used
ng = 100.

Fig. 13 Angle variation: series
120 and 194

100

Geoinformatica (2011) 15:75–109

In this experiment, we conducted two kinds of tests. The first computed the k near-
est neighbors of a query series Q, for the two descriptors—for k = {30, 50, 70, 100}.
Precision was computed based on the number of similar series found in each k-NN
query. This first test used all 1,336 series in the set as query series. Given the seasonal
behavior of temperature, two series were considered to be similar if they started in
the same (or neighboring) months.

The second test was also based on k-NN computation, for the same values of k,
but in this case the result eliminated series collected from the same city as Q. For
instance, if Q concerned the city of Campinas, then the result only contained series
from all other four cities of the temperature testbed. The goal of this second test was
to increase the influence of oscillation in the comparison (and not just the values),
since the temperature in a given county tends to follow similar value patterns over
the years.

To clarify, São Carlos is always warmer than Campinas, because of their geograph-
ical characteristics. In a given season, however, the cities shows similar patterns of
temperature oscillation, but values are distinct. Linear scan will first select all series
from Campinas, at that season, considering them to be closer to each other than any
series from São Carlos. TIDES, on the other hand, will prioritize similar oscillation
trends between São Carlos and Campinas in the same season, and consider them to
be more similar to each other than two series from Campinas in different years.

Table 3 presents the result of our comparison. The column containing percentual

values compares TIDES and Linear Scan using Eq. 14.

comp perc = T I DES − LinScan

LinScan

(14)

where comp perc is positive when TIDES is more accurate, and negative when Linear
Scan is more accurate. The table shows that TIDES is more appropriate than Linear
Scan to describe oscillations, where TEST1 and TEST2 correspond to the first and
second tests performed.

In TEST2, TIDES rapidly presented better results than Linear Scan, for a rela-
tively small number of series returned (see precision for k = 50). The larger the size
of the result, the better TIDES performs (precision for k = 100).

In the first type of test, however, Linear Scan showed good results in the cases
where tests were run with small k. It is only when k increased that the oscillation
factor started to show its influence, in which case TIDES presented a better perfor-
mance (precision when k = 100). All results were validated by experts.

Table 3 Comparison between TIDES and Linear Scan

k

30
50
70
100

TEST 1

Lin. scan

90
85
78
70

TIDES

81
78
76
73

Perc. gain
(−11%)
(−9%)
(−3%)
4%

TEST 2

Lin. scan

78
73
69
62

TIDES

77
74
72
69

Perc. gain
(−1%)
1%
4%
10%

Geoinformatica (2011) 15:75–109

101

(a) Query set: Lençois County, year 1999; 
Distance = 0.00.

(b) Pederneiras County, year 1999; 
Distance = 109.57.

(c) Pontal County, year 1999; 
Distance = 350.32.

(d) Penapolis County, year 2003; 
Distance = 882.31.

Fig. 14 Ranking of sets of NDVI series based on three-series co-evolution pattern. Query set (a) is
the input set of series—the most similar to itself

(a)

(b)

Fig. 15 Average number of sets of NDVI series for each county for the first 100 nearest neighbors.
a Sets of series of the year 1999 are taken as query. b Sets of series of the year 2006 are taken as
query

102

Geoinformatica (2011) 15:75–109

(a)

(b)

Fig. 16 Average number of sets of NDVI series for each county for the first 100 nearest neighbors.
a Sets of series of Batatais County are taken as query. b Sets series of Pederneiras County are taken
as query

5.5 Co-evolution analysis

This section reports experiments conducted to validate the TIDES-based co-
evolution descriptor proposed in this paper. When we speak of a set of series (here
also called three-series), we are referring to three series co-evolving together. Co-
evolution experiments were run with ng = 90 and nseg = 35.

In this experiment, we computed the 100 nearest neighbors of a query defined by a
set of three NDVI series. Each set was taken as query against the entire three-series
database. Figure 14 exemplifies the ranking of sets of series taking into account their
similarity to a given input (another set of series) wrt co-evolution. The input query is

Geoinformatica (2011) 15:75–109

103

the set of NDVI curves of Fig. 14a. Note that each query is associated to a year (from
1999 to 2006) and to a county.

Also notice that the distance is higher for Penapolis county, whose NDVI curves
are of a different year (2003) if compared to the query set (1999). Moreover, the
distance between a set of curves and itself is zero (Fig. 14a), as expected.

We conducted two kinds of tests. In the first test, for each county three-series as
input, we computed how often sets of series of the same county appear among its
nearest 100 neighbors, in average, (from 1999 to 2006). This test aimed to evaluate
if sets of NDVI series coevolve similarly for the same year, regardless of the county.
Figure 15 shows the results obtained when we considered sets of NDVI series of the
years 1999 and 2006 as query. As can be observed, in both cases, sets of series of
the same year of the query are more frequent. This suggests that there is a temporal
correlation between oscillation patterns of sets of NDVI curves.

In the second test, we again computed the average of how often a county, in
an input query, appears among its first 100 nearest neighbors. This test aimed to
evaluate if sets of NDVI series of the same county co-evolve similarly regardless of
the year. Figure 16 shows the results when sets of series of Batatais and Pederneiras
counties are considered as query. When series from Batatais are used as input, sets of
NDVI series of Batatais are returned more frequently within the first 100 positions
of the ranking—which was to be expected. The same result is however not verified
for Pederneiras County. In this case, sets of series of this county are the third most
frequent, its greenness evolution is more frequently similar to those of Rio das Pedras
and Batatais. By using this information, as pointed out before, experts can raise
hypotheses for causes of such diversity.

To support the hypothesis formulation process, spatial correlation analysis can
also be conducted by using the co-evolution descriptor proposed. Figure 17 shows,
for example, the spatial distribution of co-evolution similarity considering a query
containing a set of NDVI curves of Batatais county. The lower the red intensity, the
more similar are the co-evolution oscillation patterns of series of a county. So, the
map shows that Batatais sugar cane behavior is more similar (a) in its neighboring
counties; and (b) at a small cluster of properties SE of the county. This map has sparse
colored polygons because it just analyzes areas of sugar cane plantations, selected by
experts for this analysis.

Fig. 17 Spatial distribution of
co-evolution similarity
considering a query containing
a set of NDVI curves of
Batatais county

104

Geoinformatica (2011) 15:75–109

6 Prototype for end-user visualization

We have developed a prototype to let end-users visually analyze the results of
series matching with TIDES. This prototype can be seen at www.lis.ic.unicamp.
br/∼lmariote/teste_series.phpserie=k, where k is a series number. It supports kN N
search processes, for k = 10, and presents the results graphically.

The architecture of the prototype is organized in two main layers: Presentation
(the user interface) and Search. The Presentation layer was programmed as a set of
PHP scripts, to draw graphs of time series, where X corresponds to the time axis, and
Y the values.

The Search layer contains the TIDES algorithms to construct the feature vectors
and compute distances. It is written in C++, and can be invoked separately. Hence,
it can be used as an independent library. The series base used in the prototype is the
temperature database described in Section 5.1.

The two layers communicate by means of a persistence mechanism in secondary
memory. The Presentation layer receives a request and invokes the Search layer. The
latter performs the mining for the k nearest series, and stores the result in a set of
files, using an internal representation, forwarded back to the presentation layer. This
representation is then decoded, and the graphs are created and presented.

The prototype does not allow parameter tuning, which is part of ongoing work—
e.g., to support a varying number of scales κ, the number of classes (symbols) to be
used in the classification stage ng, or the number of segments in the segmentation
phase nseg. Figure 18 illustrates the result of a user query for the 10 series closest to

Fig. 18 Partial screen copy of prototype—10 series closest to series number 120

Geoinformatica (2011) 15:75–109

105

series 120. Results are presented as a matrix: the series closest to the input is at the top
left corner. Similarity decreases from right to left, top to bottom. As expected, series
120 is the closest to itself. Each series in the result is labeled showing the geographical
region where the data were collected, and the starting month of the series.

The result also provides a link to a page where the user can see all the messages
generated by the mining algorithm. This can help users follow the underlying
comparison process.

Series co-evolution and other series visualization tools appear as part of our
eFarms project—see site proj.lis.ic.unicamp.br/efarms. Some of the figures shown in
the previous sections were screen copies from this site.

7 Conclusions and future work

The number of applications that require management of time series is growing every
day. This has prompted many kinds of research on time series management and
analysis, which frequently rely on similarity search functionalities. This kind of search
is generally centered on comparing evolution patterns of data values.

Our work contributes to this effort, from another perspective, considering other
kinds of need. It proposes a new descriptor—TIDES—whose purpose is to charac-
terize series’ oscillation behavior. We point out two advantages of using TIDES for
this kind of characteristics. First, it is immune to series displacement along the y-axis.
Second, since it is multiscale, it can be customized to distinct application domains,
where oscillation similarity is a matter of time granularity. Multiscale comparison
decreases the problem of semantic gap, letting users better understand oscillation
behavior. Experiments conducted show that TIDES presents better results than one
of the most common techniques used in the literature, linear scan.

As shown in the paper, TIDES can also successfully be used to describe co-
evolving series, using the basic steps of linear segmentation, symbol assignment and
distance computation. There are very few reports in the literature of co-evolution
analysis. Hence, our work also contributes to mining for complex patterns, in which
several phenomena can be analyzed together.

Future and ongoing work involve several activities. Input parameter ng is user-
dependent, to account for specific application domains. A possibility to circumvent
this is to define techniques that, through use of training sets, will determine the most
appropriate value for ng, for each application domain. Another, complementary,
solution, is to develop an evaluation methodology, involving user interaction, with
help of experts in interface design, to tune the scale threshold.

Another extension that can be considered is a hybrid descriptor that combines
TIDES characterization of oscillations with another descriptor that considers value
evolution (e.g., Linear Scan). This might allow a more thorough description of series
behaviour.

We also intend to perform more experiments using large series datasets with real
data. In particular, there is a need for constructing a comprehensive series database
benchmark to test co-evolution, in which data from correlated phenomena must be
stored. Present testbeds do not consider such a possibility.

106

Geoinformatica (2011) 15:75–109

Co-evolution itself presents several challenges. For instance, there is a need to
explore alternatives for indexing series to speed up co-evolution analysis. There are
several results in series indexing, but none that have been tested in this context. One
difficulty inherent to co-evolution analysis is the problem of temporal cause-effect
delays—i.e., when the influence of a phenomenon into another can only be reflected
after a period of time. As mentioned in the paper, there is a strong relationship
between the amount of rain in a region and the productivity of crops in that same
region. However, depending on the kind of crop, the effect is only felt months af-
terwards; analogously, temperature affects crop productivity. Thus, descriptors that
support analysis of co-evolution must be tuned for distinct kinds of delay, which can
only be defined by domain experts, and is moreover sensitive to application needs.
When multiple phenomena are involved (e.g., rainfall, temperature, and biomass
evolution), these delay parameters become dependent on complex mathematical
modeling, and are thus harder to specify.

Acknowledgements This work was partially funded by CPqD Foundation, CAPES, FAPESP,
CNPq grants and CNPq projects WebMAPS and RPG. It is also being partially funded by the
Microsoft Research-FAPESP Virtual institute, under the eFarms project. We thank Jeferson Lobato
Fernandes for providing us with experimental data.

References

1. Agrawal R, Lin KI, Sawhney HS, Shim K (1995) Fast similarity search in the presence of noise,

scaling, and translation in time-series databases. In: 21st VLSB conference, pp 490–501

2. Akyildiz IF, Su W, Sankarasubramaniam Y, Cayirci E (2002) Wireless sensor networks: a survey.

Comput Netw 38(4):393–422

3. Babcock B, Babu S, Datar M, Motwani R, Widom J (2003) Models and issues in data stream

systems. Technical report, Department of Computer Science, Stanford University

4. Cai Y, Ng R (2004) Indexinials. In: Proc ACM SIGMOD conference spatio-temporal trajectories

5. Deshpande A, Guestrin C, Madden S (2004) Model-driven data acquisition in sensor networks.

with Chebyshev polynom

In: Proc 30th VLDB conference

6. Deshpande A, Madden S (2006) MauveDB: supporting model-based user views in database

systems. In: Proc of the 2006 ACM SIGMOD conference, pp 73–84

7. Ding H, Trajcevski G, Scheuermann P, Wang X, Keogh E (2008) Querying and mining of time
series data: experimental comparison of representations and distance measures. In: Proc VLDB
conference

8. Etien A, Salinesi C (2005) Managing requirements in a co-evolution context. In: RE05—

Proceedings of the 13th international conference on requirements engineering

9. Faloutsos C (2002) Tutorial: sensor data mining: similarity search and pattern analysis. In: 28th

VLDB conference

10. Faloutsos C, Ranganathan M, Manolopoulos Y (1994) Fast subsequence matching in time-series
databases. In: Proceedings 1994 ACM SIGMOD conference, Minneapolis, MN, pp 419–429
11. Fu L, Soh L, Samal A (2008) Techniques for computing fitness of use (FoU) for time series

datasets with applications in the geospatial domain. GeoInfo 12(1):91–93

12. Golab L, Oszu M (2003) Issues in data stream management. CM SIGMOD Rec 32:5–14
13. Han J, Kamber M (2002) Data mining: concepts and techniques. In: ACM SIGMOD, vol 31
14. Han J, Pei J, Mortazavi-Asl B, Chen Q, Dayal U, Hsu M (2000) Freespan: frequent pattern-
projected sequential pattern mining. In: KDD ’00: Proceedings of the sixth ACM SIGKDD
international conference on knowledge discovery and data mining, pp 355–359

15. Hugueney B (2003) Representations symboliques de longues series temporelles (Symbolic rep-

resentations of long temporal series). PhD thesis, University Paris 6

Geoinformatica (2011) 15:75–109

107

16. Joliveau M, De Vuyst F (2007) Space-Time summarization of multisensor time series. Case of

missing data. In: Int workshop on spatial and spatio-temporal data mining—SSTDM

17. Junkui L, Yuanzhen W (2007) APCAS: an approximate approach to adaptively segment time
series streams. In: Advances in data and web management, vol 4505. Springer, Berlin, pp 554–
565

18. Keogh E, Chakrabarti K, Pazzani M, Mehrotra S (2001) Locally adaptive dimensionality reduc-
tion for indexing large time series databases. In: Proc ACM SIGMOD conference, pp 151–162
19. Keogh E, Pazzani M (1998) An enhanced representation of time series which allows fast and
accurate classification, clustering and relevance feedback. In Agrawal R, Stolorz P, Piatetsky-
Shapiro G (eds) Fourth international conference on knowledge discovery and data mining
(KDD’98). ACM, New York, pp 239–241

20. Keogh E, Ratanamahatana CA (2005) Exact indexing of dynamic time warping. Knowl Inf Syst

7(3):358–386

21. Keogh E, Smyth P (1997) A probabilistic approach to fast pattern matching in time series
databases. In Heckerman D, Mannila H, Pregibon D, Uthurusamy R (eds) Third international
conference on knowledge discovery and data mining. Newport Beach, CA, USA. AAAI, Menlo
Park, pp 24–30

22. Keogh E, Xi X, Wei L, Ratanamahatana CA (2006) The UCR time series classification/clustering

homepage. www.cs.ucr.edu/∼eamonn/timeseriesdata/

23. Keogh EJ, Chu S, Hart D, Pazzani MJ (2001) An online algorithm for segmenting time series.
In: ICDM ’01: Proceedings of the 2001 IEEE international conference on data mining. IEEE
Computer Society, Washington, DC, pp 289–296

24. Keogh EJ, Pazzani MJ (2000) A simple dimensionality reduction technique for fast similarity
search in large time series databases. In: Knowledge discovery and data mining, current issues
and new applications, 4th Pacific-Asia conference, PAKDD 2000, vol 1805. Springer, Berlin,
pp 122–133

25. Korth H, Jagadish H, Faloutsos C (1997) Efficiently supporting ad hoc queries in large data sets

of time sequences. In: Proc ACM SIGMOD conference

26. Lin J, Keogh E, Lonardi S, Chiu B (2003) A symbolic representation of time series, with
implications for streaming algorithms. In: DMKD ’03: Proceedings of the 8th ACM SIGMOD
workshop on Research issues in data mining and knowledge discovery. ACM, New York, pp 2–11
27. Lin J, Keogh E, Wei L, Lonardi S (2007) Experiencing SAX: a novel symbolic representation of

time series. Data Min Knowl Discov 15:107–144

28. Mainwaring A, Culler D, Polastre J, Szewczyk R, Anderson J (2002) Wireless sensor networks
for habitat monitoring. In: WSNA ’02: Proceedings of the 1st ACM international workshop on
Wireless sensor networks and applications. ACM, New York, pp 88–97

29. Mariote L, Medeiros CB, Torres R (2007) Diagnosing similarity of oscillation trends in time
series. In: International Workshop on spatial and spatio-temporal data mining—SSTDM. LNCS,
pp 643–648

30. Mirmomeni M, Lucas C, Araabi B, Moshiri B (2007) Forecasting solar activity using co-evolution
of models and tests. In: Proc 7th international conference on intelligent systems design and
applications

31. Navarro G (2001) A guided tour to approximate string matching. ACM Comput Surv 33(1):

32. Park S, Lee D, Chu WW (1999) Fast retrieval of similar subsequences in long sequence databases.
In: KDEX ’99: Proceedings of the 1999 workshop on knowledge and data engineering exchange.
IEEE Computer Society, Washington, DC, p 60

33. Patt-Shamir B (2007) A note on efficient aggregate queries in sensor networks. Theor Comp Sci

31–88

370(1–3):254–264

34. Rafiei D, Mendelzon A (1997) Similarity-based queries for time series data. In: SIGMOD ’97:
Proceedings of the 1997 ACM SIGMOD international conference on management of data,
pp 13–25

35. Sacchi L, Larizza C, Combi C, Bellazzi R (2007) Data mining with temporal abstractions: learning

rules from time series. Data Min Knowl Discov 15(2):217–247

36. Shoshani A, Kawagoe K (1986) Temporal data management. In: Twelfth international confer-

ence on very large data bases table of contents, pp 79–88

37. Smeulders AWM, Worring M, Santini S, Gupta A, Jain R (2000) Content-based image retrieval

at the end of the early years. IEEE Trans Pattern Anal Mach Intell 22:1349–1380

108

Geoinformatica (2011) 15:75–109

38. Szewczyk R, Polastre J, Mainwaring A, Culler D (2004) Lessons from a sensor network expedi-

tion. In: Proceedings of the first European workshop on sensor networks (EWSN)

39. Torres RS, Falcao AX, Costa LF (2002) Shape description by image foresting transform. In:
Digital signal processing, 2002. DSP 2002. 2002 14th International conference on, vol 2, pp 1089–
1092

40. Wu H, Salzberg B, Sharp GC, Jiang SB, Shirato H, Kaeli D (2005) Subsequence matching
on structured time series data. In: SIGMOD ’05: Proceedings of the 2005 ACM SIGMOD
international conference on management of data. ACM, New York, pp 682–693

41. Yi B, Sidiropoulos ND, Johnson T, Jagadish HV, Faloutsos C, Biliris A (2000) Online data
mining for co-evolving time sequences. In: ICDE ’00: Proceedings of the 16th international
conference on data engineering. IEEE Computer Society, Washington, DC, p 13

Leonardo E. Mariote received a BSc in Computer Science at the University of Campinas, Brazil,
having his MSc degree awarded by the same university. He was awarded the annual prize of the best
student in CS in that university. He works as a systems analyst at the Tropico telecommunications
system at CPqD Foundation, and is now the head of the Conception and Validation department,
responsible for driving the technical solutions in the development of new projects and platforms.

Claudia Bauzer Medeiros
is full professor of computer science at the University of Campinas
(UNICAMP), Brazil, having received awards for research, teaching, and work concerning women
and IT. She is the head of the database research group in this university, and her projects center
on design and development of scientific databases applications, with emphasis on geographic data,
agro-environmental planning and biodiversity. She is a member of ACM, IEEE and SBC.

Geoinformatica (2011) 15:75–109

109

Ricardo da Silva Torres received a B.Sc. in Computer Engineering from the University of Campinas,
Brazil, in 2000. He got his doctorate in Computer Science at the same university in 2004. He is an
associate professor at the Institute of Computing, University of Campinas. His research interests
include image analysis, content-based image retrieval, databases, digital libraries, and geographic
information systems.

Lucas M. Bueno has a degree in Computer Science Engineering awarded by the University of
Campinas, Brazil, and is now working towards his MSc degree in that university. His area of research
is Content Based Image Retrieval.

